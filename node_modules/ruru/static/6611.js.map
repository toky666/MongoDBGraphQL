{"version":3,"file":"6611.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"],"names":["GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","forEach","index","length","braceVal","bracketVal","res","escapeRegExpCharacters","braceRegExp","map","choice","join","T1","T2","T3","T3_2","T4","T5","CACHE","LRUCache","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","match","parsedPattern","get","test","base","path","basename","endsWith","trivia1","substr","exec","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","slice","split","filter","patternsLength","i","n","withBasenames","find","allPaths","reduce","all","current","concat","trivia3","trivia4and5","regExp","RegExp","lastIndex","error","toRegExp","set","arg2","wrappedPattern","isEqualOrParent","isLinux","ltrim","sep","wrapRelativePattern","targetPath","matchPathEnds","usingPosixSep","posix","nativePath","replace","nativePathEnd","targetPathEnd","hasSibling","parse","undefined","isRelativePattern","resultPattern","expression","Object","getOwnPropertyNames","value","when","result","name","matched","isThenable","then","requiresSiblings","parseExpressionPattern","some","resultExpression","resultPromises","resultPromise","extname","parsedExpression","obj","rp","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"ignoreList":[],"sourceRoot":""}