{"version":3,"file":"2155.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/equals.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../event.js';\nimport { DisposableStore, toDisposable } from '../lifecycle.js';\nimport { BaseObservable, ConvenientObservable, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\nimport { strictEquals } from '../equals.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function observableFromEvent(...args) {\n    let owner;\n    let event;\n    let getValue;\n    if (args.length === 3) {\n        [owner, event, getValue] = args;\n    }\n    else {\n        [event, getValue] = args;\n    }\n    return new FromEventObservable(new DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, strictEquals);\n}\nexport function observableFromEventOpts(options, event, getValue) {\n    return new FromEventObservable(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this.event = event;\n        this._getValue = _getValue;\n        this._getTransaction = _getTransaction;\n        this._equalityComparator = _equalityComparator;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));\n            let didRunTransaction = false;\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    didRunTransaction = true;\n                    subtransaction(this._getTransaction(), (tx) => {\n                        getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n            if (!didRunTransaction) {\n                getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return this._debugNameData.getDebugName(this);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nexport function observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        return new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n    }\n    toString() {\n        return this.debugName;\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved(observable) {\n    const o = new KeepAliveObserver(false, undefined);\n    observable.addObserver(o);\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setKeepObserved(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nexport class KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nexport function derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\nexport function derivedObservableWithWritableCache(owner, computeFn) {\n    let lastValue = undefined;\n    const onChange = observableSignal('derivedObservableWithWritableCache');\n    const observable = derived(owner, reader => {\n        onChange.read(reader);\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return Object.assign(observable, {\n        clearCache: (tx) => {\n            lastValue = undefined;\n            onChange.trigger(tx);\n        },\n        setCache: (newValue, tx) => {\n            lastValue = newValue;\n            onChange.trigger(tx);\n        }\n    });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = new ArrayMap(map, keySelector);\n    const self = derivedOpts({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = new ArrayMap(map);\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = new Map();\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = new Set(this._cache.keys());\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = new DisposableStore();\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\nexport class ValueWithChangeEventFromObservable {\n    constructor(observable) {\n        this.observable = observable;\n    }\n    get onDidChange() {\n        return Event.fromObservableLight(this.observable);\n    }\n    get value() {\n        return this.observable.get();\n    }\n}\nexport function observableFromValueWithChangeEvent(owner, value) {\n    if (value instanceof ValueWithChangeEventFromObservable) {\n        return value.observable;\n    }\n    return observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined(owner, fn) {\n    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals = (a, b) => a === b;\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => arrays.equals(a, b, itemEquals);\n}\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals() {\n    return (a, b) => a.equals(b);\n}\nexport function equalsIfDefined(equalsOrV1, v2, equals) {\n    if (equals !== undefined) {\n        const v1 = equalsOrV1;\n        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n            return v2 === v1;\n        }\n        return equals(v1, v2);\n    }\n    else {\n        const equals = equalsOrV1;\n        return (v1, v2) => {\n            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n                return v2 === v1;\n            }\n            return equals(v1, v2);\n        };\n    }\n}\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!structuralEquals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n            const aObj = a;\n            const bObj = b;\n            const keysA = Object.keys(aObj);\n            const keysB = Object.keys(bObj);\n            const keysBSet = new Set(keysB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            }\n            for (const key of keysA) {\n                if (!keysBSet.has(key)) {\n                    return false;\n                }\n                if (!structuralEquals(aObj[key], bObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nconst objIds = new WeakMap();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet globalObservableLogger;\nexport function setLogger(logger) {\n    globalObservableLogger = logger;\n}\nexport function getLogger() {\n    return globalObservableLogger;\n}\nexport class ConsoleObservableLogger {\n    constructor() {\n        this.indentation = 0;\n        this.changedObservablesSets = new WeakMap();\n    }\n    textToConsoleArgs(text) {\n        return consoleTextToArgs([\n            normalText(repeat('|  ', this.indentation)),\n            text,\n        ]);\n    }\n    formatInfo(info) {\n        if (!info.hadValue) {\n            return [\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n                normalText(` (initial)`),\n            ];\n        }\n        return info.didChange\n            ? [\n                normalText(` `),\n                styled(formatValue(info.oldValue, 70), {\n                    color: 'red',\n                    strikeThrough: true,\n                }),\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n            ]\n            : [normalText(` (unchanged)`)];\n    }\n    handleObservableChanged(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable value changed'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n        ]));\n    }\n    formatChanges(changes) {\n        if (changes.size === 0) {\n            return undefined;\n        }\n        return styled(' (changed deps: ' +\n            [...changes].map((o) => o.debugName).join(', ') +\n            ')', { color: 'gray' });\n    }\n    handleDerivedCreated(derived) {\n        const existingHandleChange = derived.handleChange;\n        this.changedObservablesSets.set(derived, new Set());\n        derived.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(derived).add(observable);\n            return existingHandleChange.apply(derived, [observable, change]);\n        };\n    }\n    handleDerivedRecomputed(derived, info) {\n        const changedObservables = this.changedObservablesSets.get(derived);\n        console.log(...this.textToConsoleArgs([\n            formatKind('derived recomputed'),\n            styled(derived.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }\n        ]));\n        changedObservables.clear();\n    }\n    handleFromEventObservableTriggered(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable from event triggered'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            { data: [{ fn: observable._getValue }] }\n        ]));\n    }\n    handleAutorunCreated(autorun) {\n        const existingHandleChange = autorun.handleChange;\n        this.changedObservablesSets.set(autorun, new Set());\n        autorun.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(autorun).add(observable);\n            return existingHandleChange.apply(autorun, [observable, change]);\n        };\n    }\n    handleAutorunTriggered(autorun) {\n        const changedObservables = this.changedObservablesSets.get(autorun);\n        console.log(...this.textToConsoleArgs([\n            formatKind('autorun'),\n            styled(autorun.debugName, { color: 'BlueViolet' }),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }\n        ]));\n        changedObservables.clear();\n        this.indentation++;\n    }\n    handleAutorunFinished(autorun) {\n        this.indentation--;\n    }\n    handleBeginTransaction(transaction) {\n        let transactionName = transaction.getDebugName();\n        if (transactionName === undefined) {\n            transactionName = '';\n        }\n        console.log(...this.textToConsoleArgs([\n            formatKind('transaction'),\n            styled(transactionName, { color: 'BlueViolet' }),\n            { data: [{ fn: transaction._fn }] }\n        ]));\n        this.indentation++;\n    }\n    handleEndTransaction() {\n        this.indentation--;\n    }\n}\nfunction consoleTextToArgs(text) {\n    const styles = new Array();\n    const data = [];\n    let firstArg = '';\n    function process(t) {\n        if ('length' in t) {\n            for (const item of t) {\n                if (item) {\n                    process(item);\n                }\n            }\n        }\n        else if ('text' in t) {\n            firstArg += `%c${t.text}`;\n            styles.push(t.style);\n            if (t.data) {\n                data.push(...t.data);\n            }\n        }\n        else if ('data' in t) {\n            data.push(...t.data);\n        }\n    }\n    process(text);\n    const result = [firstArg, ...styles];\n    result.push(...data);\n    return result;\n}\nfunction normalText(text) {\n    return styled(text, { color: 'black' });\n}\nfunction formatKind(kind) {\n    return styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\nfunction styled(text, options = {\n    color: 'black',\n}) {\n    function objToCss(styleObj) {\n        return Object.entries(styleObj).reduce((styleString, [propName, propValue]) => {\n            return `${styleString}${propName}:${propValue};`;\n        }, '');\n    }\n    const style = {\n        color: options.color,\n    };\n    if (options.strikeThrough) {\n        style['text-decoration'] = 'line-through';\n    }\n    if (options.bold) {\n        style['font-weight'] = 'bold';\n    }\n    return {\n        text,\n        style: objToCss(style),\n    };\n}\nfunction formatValue(value, availableLen) {\n    switch (typeof value) {\n        case 'number':\n            return '' + value;\n        case 'string':\n            if (value.length + 2 <= availableLen) {\n                return `\"${value}\"`;\n            }\n            return `\"${value.substr(0, availableLen - 7)}\"+...`;\n        case 'boolean':\n            return value ? 'true' : 'false';\n        case 'undefined':\n            return 'undefined';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            if (Array.isArray(value)) {\n                return formatArray(value, availableLen);\n            }\n            return formatObject(value, availableLen);\n        case 'symbol':\n            return value.toString();\n        case 'function':\n            return `[[Function${value.name ? ' ' + value.name : ''}]]`;\n        default:\n            return '' + value;\n    }\n}\nfunction formatArray(value, availableLen) {\n    let result = '[ ';\n    let first = true;\n    for (const val of value) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' ]';\n    return result;\n}\nfunction formatObject(value, availableLen) {\n    let result = '{ ';\n    let first = true;\n    for (const [key, val] of Object.entries(value)) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${key}: ${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' }';\n    return result;\n}\nfunction repeat(str, count) {\n    let result = '';\n    for (let i = 1; i <= count; i++) {\n        result += str;\n    }\n    return result;\n}\nfunction padStr(str, length) {\n    while (str.length < length) {\n        str += ' ';\n    }\n    return str;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LanguagesRegistry } from './languagesRegistry.js';\nimport { firstOrDefault } from '../../../base/common/arrays.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { observableFromEvent } from '../../../base/common/observable.js';\nexport class LanguageService extends Disposable {\n    static { this.instanceCount = 0; }\n    constructor(warnOnOverwrite = false) {\n        super();\n        this._onDidRequestBasicLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;\n        this._onDidRequestRichLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;\n        this._onDidChange = this._register(new Emitter({ leakWarningThreshold: 200 /* https://github.com/microsoft/vscode/issues/119968 */ }));\n        this.onDidChange = this._onDidChange.event;\n        this._requestedBasicLanguages = new Set();\n        this._requestedRichLanguages = new Set();\n        LanguageService.instanceCount++;\n        this._registry = this._register(new LanguagesRegistry(true, warnOnOverwrite));\n        this.languageIdCodec = this._registry.languageIdCodec;\n        this._register(this._registry.onDidChange(() => this._onDidChange.fire()));\n    }\n    dispose() {\n        LanguageService.instanceCount--;\n        super.dispose();\n    }\n    isRegisteredLanguageId(languageId) {\n        return this._registry.isRegisteredLanguageId(languageId);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        return this._registry.getLanguageIdByLanguageName(languageName);\n    }\n    getLanguageIdByMimeType(mimeType) {\n        return this._registry.getLanguageIdByMimeType(mimeType);\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n        return firstOrDefault(languageIds, null);\n    }\n    createById(languageId) {\n        return new LanguageSelection(this.onDidChange, () => {\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    createByFilepathOrFirstLine(resource, firstLine) {\n        return new LanguageSelection(this.onDidChange, () => {\n            const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    _createAndGetLanguageIdentifier(languageId) {\n        if (!languageId || !this.isRegisteredLanguageId(languageId)) {\n            // Fall back to plain text if language is unknown\n            languageId = PLAINTEXT_LANGUAGE_ID;\n        }\n        return languageId;\n    }\n    requestBasicLanguageFeatures(languageId) {\n        if (!this._requestedBasicLanguages.has(languageId)) {\n            this._requestedBasicLanguages.add(languageId);\n            this._onDidRequestBasicLanguageFeatures.fire(languageId);\n        }\n    }\n    requestRichLanguageFeatures(languageId) {\n        if (!this._requestedRichLanguages.has(languageId)) {\n            this._requestedRichLanguages.add(languageId);\n            // Ensure basic features are requested\n            this.requestBasicLanguageFeatures(languageId);\n            // Ensure tokenizers are created\n            TokenizationRegistry.getOrCreate(languageId);\n            this._onDidRequestRichLanguageFeatures.fire(languageId);\n        }\n    }\n}\nclass LanguageSelection {\n    constructor(onDidChangeLanguages, selector) {\n        this._value = observableFromEvent(this, onDidChangeLanguages, () => selector());\n        this.onDidChange = Event.fromObservable(this._value);\n    }\n    get languageId() {\n        return this._value.get();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { parse } from '../../../base/common/glob.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { basename, posix } from '../../../base/common/path.js';\nimport { DataUri } from '../../../base/common/resources.js';\nimport { startsWithUTF8BOM } from '../../../base/common/strings.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nlet registeredAssociations = [];\nlet nonUserRegisteredAssociations = [];\nlet userRegisteredAssociations = [];\n/**\n * Associate a language to the registry (platform).\n * * **NOTE**: This association will lose over associations registered using `registerConfiguredLanguageAssociation`.\n * * **NOTE**: Use `clearPlatformLanguageAssociations` to remove all associations registered using this function.\n */\nexport function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {\n    _registerLanguageAssociation(association, false, warnOnOverwrite);\n}\nfunction _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {\n    // Register\n    const associationItem = toLanguageAssociationItem(association, userConfigured);\n    registeredAssociations.push(associationItem);\n    if (!associationItem.userConfigured) {\n        nonUserRegisteredAssociations.push(associationItem);\n    }\n    else {\n        userRegisteredAssociations.push(associationItem);\n    }\n    // Check for conflicts unless this is a user configured association\n    if (warnOnOverwrite && !associationItem.userConfigured) {\n        registeredAssociations.forEach(a => {\n            if (a.mime === associationItem.mime || a.userConfigured) {\n                return; // same mime or userConfigured is ok\n            }\n            if (associationItem.extension && a.extension === associationItem.extension) {\n                console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filename && a.filename === associationItem.filename) {\n                console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {\n                console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.firstline && a.firstline === associationItem.firstline) {\n                console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n        });\n    }\n}\nfunction toLanguageAssociationItem(association, userConfigured) {\n    return {\n        id: association.id,\n        mime: association.mime,\n        filename: association.filename,\n        extension: association.extension,\n        filepattern: association.filepattern,\n        firstline: association.firstline,\n        userConfigured: userConfigured,\n        filenameLowercase: association.filename ? association.filename.toLowerCase() : undefined,\n        extensionLowercase: association.extension ? association.extension.toLowerCase() : undefined,\n        filepatternLowercase: association.filepattern ? parse(association.filepattern.toLowerCase()) : undefined,\n        filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false\n    };\n}\n/**\n * Clear language associations from the registry (platform).\n */\nexport function clearPlatformLanguageAssociations() {\n    registeredAssociations = registeredAssociations.filter(a => a.userConfigured);\n    nonUserRegisteredAssociations = [];\n}\n/**\n * @see `getMimeTypes`\n */\nexport function getLanguageIds(resource, firstLine) {\n    return getAssociations(resource, firstLine).map(item => item.id);\n}\nfunction getAssociations(resource, firstLine) {\n    let path;\n    if (resource) {\n        switch (resource.scheme) {\n            case Schemas.file:\n                path = resource.fsPath;\n                break;\n            case Schemas.data: {\n                const metadata = DataUri.parseMetaData(resource);\n                path = metadata.get(DataUri.META_DATA_LABEL);\n                break;\n            }\n            case Schemas.vscodeNotebookCell:\n                // File path not relevant for language detection of cell\n                path = undefined;\n                break;\n            default:\n                path = resource.path;\n        }\n    }\n    if (!path) {\n        return [{ id: 'unknown', mime: Mimes.unknown }];\n    }\n    path = path.toLowerCase();\n    const filename = basename(path);\n    // 1.) User configured mappings have highest priority\n    const configuredLanguage = getAssociationByPath(path, filename, userRegisteredAssociations);\n    if (configuredLanguage) {\n        return [configuredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 2.) Registered mappings have middle priority\n    const registeredLanguage = getAssociationByPath(path, filename, nonUserRegisteredAssociations);\n    if (registeredLanguage) {\n        return [registeredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 3.) Firstline has lowest priority\n    if (firstLine) {\n        const firstlineLanguage = getAssociationByFirstline(firstLine);\n        if (firstlineLanguage) {\n            return [firstlineLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n        }\n    }\n    return [{ id: 'unknown', mime: Mimes.unknown }];\n}\nfunction getAssociationByPath(path, filename, associations) {\n    let filenameMatch = undefined;\n    let patternMatch = undefined;\n    let extensionMatch = undefined;\n    // We want to prioritize associations based on the order they are registered so that the last registered\n    // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n    for (let i = associations.length - 1; i >= 0; i--) {\n        const association = associations[i];\n        // First exact name match\n        if (filename === association.filenameLowercase) {\n            filenameMatch = association;\n            break; // take it!\n        }\n        // Longest pattern match\n        if (association.filepattern) {\n            if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {\n                const target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator\n                if (association.filepatternLowercase?.(target)) {\n                    patternMatch = association;\n                }\n            }\n        }\n        // Longest extension match\n        if (association.extension) {\n            if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {\n                if (filename.endsWith(association.extensionLowercase)) {\n                    extensionMatch = association;\n                }\n            }\n        }\n    }\n    // 1.) Exact name match has second highest priority\n    if (filenameMatch) {\n        return filenameMatch;\n    }\n    // 2.) Match on pattern\n    if (patternMatch) {\n        return patternMatch;\n    }\n    // 3.) Match on extension comes next\n    if (extensionMatch) {\n        return extensionMatch;\n    }\n    return undefined;\n}\nfunction getAssociationByFirstline(firstLine) {\n    if (startsWithUTF8BOM(firstLine)) {\n        firstLine = firstLine.substr(1);\n    }\n    if (firstLine.length > 0) {\n        // We want to prioritize associations based on the order they are registered so that the last registered\n        // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n        for (let i = registeredAssociations.length - 1; i >= 0; i--) {\n            const association = registeredAssociations[i];\n            if (!association.firstline) {\n                continue;\n            }\n            const matches = firstLine.match(association.firstline);\n            if (matches && matches.length > 0) {\n                return association;\n            }\n        }\n    }\n    return undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\nimport { clearPlatformLanguageAssociations, getLanguageIds, registerPlatformLanguageAssociation } from './languagesAssociations.js';\nimport { ModesRegistry, PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst NULL_LANGUAGE_ID = 'vs.editor.nullLanguage';\nexport class LanguageIdCodec {\n    constructor() {\n        this._languageIdToLanguage = [];\n        this._languageToLanguageId = new Map();\n        this._register(NULL_LANGUAGE_ID, 0 /* LanguageId.Null */);\n        this._register(PLAINTEXT_LANGUAGE_ID, 1 /* LanguageId.PlainText */);\n        this._nextLanguageId = 2;\n    }\n    _register(language, languageId) {\n        this._languageIdToLanguage[languageId] = language;\n        this._languageToLanguageId.set(language, languageId);\n    }\n    register(language) {\n        if (this._languageToLanguageId.has(language)) {\n            return;\n        }\n        const languageId = this._nextLanguageId++;\n        this._register(language, languageId);\n    }\n    encodeLanguageId(languageId) {\n        return this._languageToLanguageId.get(languageId) || 0 /* LanguageId.Null */;\n    }\n    decodeLanguageId(languageId) {\n        return this._languageIdToLanguage[languageId] || NULL_LANGUAGE_ID;\n    }\n}\nexport class LanguagesRegistry extends Disposable {\n    static { this.instanceCount = 0; }\n    constructor(useModesRegistry = true, warnOnOverwrite = false) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        LanguagesRegistry.instanceCount++;\n        this._warnOnOverwrite = warnOnOverwrite;\n        this.languageIdCodec = new LanguageIdCodec();\n        this._dynamicLanguages = [];\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        if (useModesRegistry) {\n            this._initializeFromRegistry();\n            this._register(ModesRegistry.onDidChangeLanguages((m) => {\n                this._initializeFromRegistry();\n            }));\n        }\n    }\n    dispose() {\n        LanguagesRegistry.instanceCount--;\n        super.dispose();\n    }\n    _initializeFromRegistry() {\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        clearPlatformLanguageAssociations();\n        const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);\n        this._registerLanguages(desc);\n    }\n    _registerLanguages(desc) {\n        for (const d of desc) {\n            this._registerLanguage(d);\n        }\n        // Rebuild fast path maps\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        Object.keys(this._languages).forEach((langId) => {\n            const language = this._languages[langId];\n            if (language.name) {\n                this._nameMap[language.name] = language.identifier;\n            }\n            language.aliases.forEach((alias) => {\n                this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n            });\n            language.mimetypes.forEach((mimetype) => {\n                this._mimeTypesMap[mimetype] = language.identifier;\n            });\n        });\n        Registry.as(Extensions.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds());\n        this._onDidChange.fire();\n    }\n    _registerLanguage(lang) {\n        const langId = lang.id;\n        let resolvedLanguage;\n        if (hasOwnProperty.call(this._languages, langId)) {\n            resolvedLanguage = this._languages[langId];\n        }\n        else {\n            this.languageIdCodec.register(langId);\n            resolvedLanguage = {\n                identifier: langId,\n                name: null,\n                mimetypes: [],\n                aliases: [],\n                extensions: [],\n                filenames: [],\n                configurationFiles: [],\n                icons: []\n            };\n            this._languages[langId] = resolvedLanguage;\n        }\n        this._mergeLanguage(resolvedLanguage, lang);\n    }\n    _mergeLanguage(resolvedLanguage, lang) {\n        const langId = lang.id;\n        let primaryMime = null;\n        if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n            resolvedLanguage.mimetypes.push(...lang.mimetypes);\n            primaryMime = lang.mimetypes[0];\n        }\n        if (!primaryMime) {\n            primaryMime = `text/x-${langId}`;\n            resolvedLanguage.mimetypes.push(primaryMime);\n        }\n        if (Array.isArray(lang.extensions)) {\n            if (lang.configuration) {\n                // insert first as this appears to be the 'primary' language definition\n                resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);\n            }\n            else {\n                resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);\n            }\n            for (const extension of lang.extensions) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, extension: extension }, this._warnOnOverwrite);\n            }\n        }\n        if (Array.isArray(lang.filenames)) {\n            for (const filename of lang.filenames) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filename: filename }, this._warnOnOverwrite);\n                resolvedLanguage.filenames.push(filename);\n            }\n        }\n        if (Array.isArray(lang.filenamePatterns)) {\n            for (const filenamePattern of lang.filenamePatterns) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);\n            }\n        }\n        if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n            let firstLineRegexStr = lang.firstLine;\n            if (firstLineRegexStr.charAt(0) !== '^') {\n                firstLineRegexStr = '^' + firstLineRegexStr;\n            }\n            try {\n                const firstLineRegex = new RegExp(firstLineRegexStr);\n                if (!regExpLeadsToEndlessLoop(firstLineRegex)) {\n                    registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);\n                }\n            }\n            catch (err) {\n                // Most likely, the regex was bad\n                console.warn(`[${lang.id}]: Invalid regular expression \\`${firstLineRegexStr}\\`: `, err);\n            }\n        }\n        resolvedLanguage.aliases.push(langId);\n        let langAliases = null;\n        if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n            if (lang.aliases.length === 0) {\n                // signal that this language should not get a name\n                langAliases = [null];\n            }\n            else {\n                langAliases = lang.aliases;\n            }\n        }\n        if (langAliases !== null) {\n            for (const langAlias of langAliases) {\n                if (!langAlias || langAlias.length === 0) {\n                    continue;\n                }\n                resolvedLanguage.aliases.push(langAlias);\n            }\n        }\n        const containsAliases = (langAliases !== null && langAliases.length > 0);\n        if (containsAliases && langAliases[0] === null) {\n            // signal that this language should not get a name\n        }\n        else {\n            const bestName = (containsAliases ? langAliases[0] : null) || langId;\n            if (containsAliases || !resolvedLanguage.name) {\n                resolvedLanguage.name = bestName;\n            }\n        }\n        if (lang.configuration) {\n            resolvedLanguage.configurationFiles.push(lang.configuration);\n        }\n        if (lang.icon) {\n            resolvedLanguage.icons.push(lang.icon);\n        }\n    }\n    isRegisteredLanguageId(languageId) {\n        if (!languageId) {\n            return false;\n        }\n        return hasOwnProperty.call(this._languages, languageId);\n    }\n    getRegisteredLanguageIds() {\n        return Object.keys(this._languages);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        const languageNameLower = languageName.toLowerCase();\n        if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n            return null;\n        }\n        return this._lowercaseNameMap[languageNameLower];\n    }\n    getLanguageIdByMimeType(mimeType) {\n        if (!mimeType) {\n            return null;\n        }\n        if (hasOwnProperty.call(this._mimeTypesMap, mimeType)) {\n            return this._mimeTypesMap[mimeType];\n        }\n        return null;\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        if (!resource && !firstLine) {\n            return [];\n        }\n        return getLanguageIds(resource, firstLine);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n    return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges(options, fn) {\n    const store = new DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nexport class AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleAutorunCreated(this);\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = this.createChangeSummary?.();\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from './autorun.js';\nimport { observableValue, transaction } from './base.js';\nimport { CancellationError } from '../errors.js';\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise {\n    static fromFn(fn) {\n        return new ObservablePromise(fn());\n    }\n    constructor(promise) {\n        this._value = observableValue(this, undefined);\n        /**\n         * The current state of the promise.\n         * Is `undefined` if the promise didn't resolve yet.\n         */\n        this.promiseResult = this._value;\n        this.promise = promise.then(value => {\n            transaction(tx => {\n                /** @description onPromiseResolved */\n                this._value.set(new PromiseResult(value, undefined), tx);\n            });\n            return value;\n        }, error => {\n            transaction(tx => {\n                /** @description onPromiseRejected */\n                this._value.set(new PromiseResult(undefined, error), tx);\n            });\n            throw error;\n        });\n    }\n}\nexport class PromiseResult {\n    constructor(\n    /**\n     * The value of the resolved promise.\n     * Undefined if the promise rejected.\n     */\n    data, \n    /**\n     * The error in case of a rejected promise.\n     * Undefined if the promise resolved.\n     */\n    error) {\n        this.data = data;\n        this.error = error;\n    }\n}\nexport function waitForState(observable, predicate, isError, cancellationToken) {\n    if (!predicate) {\n        predicate = state => state !== null && state !== undefined;\n    }\n    return new Promise((resolve, reject) => {\n        let isImmediateRun = true;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => {\n            /** @description waitForState.state */\n            return {\n                isFinished: predicate(state),\n                error: isError ? isError(state) : false,\n                state\n            };\n        });\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const { isFinished, error, state } = stateObs.read(reader);\n            if (isFinished || error) {\n                if (isImmediateRun) {\n                    // The variable `d` is not initialized yet\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                if (error) {\n                    reject(error === true ? state : error);\n                }\n                else {\n                    resolve(state);\n                }\n            }\n        });\n        if (cancellationToken) {\n            const dc = cancellationToken.onCancellationRequested(() => {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n            });\n            if (cancellationToken.isCancellationRequested) {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n                return;\n            }\n        }\n        isImmediateRun = false;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BaseObservable, TransactionImpl } from './base.js';\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._isUpToDate = true;\n        this._deltas = [];\n        this._updateCounter = 0;\n        this._value = initialValue;\n    }\n    get() {\n        this._update();\n        return this._value;\n    }\n    _update() {\n        if (this._isUpToDate) {\n            return;\n        }\n        this._isUpToDate = true;\n        if (this._deltas.length > 0) {\n            for (const observer of this.observers) {\n                for (const change of this._deltas) {\n                    observer.handleChange(this, change);\n                }\n            }\n            this._deltas.length = 0;\n        }\n        else {\n            for (const observer of this.observers) {\n                observer.handleChange(this, undefined);\n            }\n        }\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            for (const observer of this.observers) {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._update();\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this._updateCounter > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this._updateCounter > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            this._isUpToDate = false;\n            this._setValue(value);\n            if (change !== undefined) {\n                this._deltas.push(change);\n            }\n            tx.updateObserver({\n                beginUpdate: () => this._beginUpdate(),\n                endUpdate: () => this._endUpdate(),\n                handleChange: (observable, change) => { },\n                handlePossibleChange: (observable) => { },\n            }, this);\n            if (this._updateCounter > 1) {\n                // We already started begin/end update, so we need to manually call handlePossibleChange\n                for (const observer of this.observers) {\n                    observer.handlePossibleChange(this);\n                }\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { ObservableValue } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nexport function observableValueOpts(options, initialValue) {\n    if (options.lazy) {\n        return new LazyObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n    }\n    return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    /**\n     * Ensures that this observable is observed. This keeps the cache alive.\n     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n     * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n     */\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        getLogger()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        getLogger()?.handleEndTransaction();\n    }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nexport function getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nexport function getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport function derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals);\n    }\n    return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, strictEquals);\n}\nexport function derivedWithSetter(owner, computeFn, setter) {\n    return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals, setter);\n}\nexport function derivedOpts(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? strictEquals);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? strictEquals);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        if (!store) {\n            store = new DisposableStore();\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, strictEquals);\n}\nexport class Derived extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, this.createChangeSummary?.());\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = this.createChangeSummary?.();\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        getLogger()?.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\nexport class DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\n"],"names":["constObservable","value","ConstObservable","ConvenientObservable","constructor","super","this","debugName","toString","get","addObserver","observer","removeObserver","observableFromEvent","args","owner","event","getValue","length","FromEventObservable","DebugNameData","undefined","globalTransaction","strictEquals","observableFromEventOpts","options","debugReferenceFn","equalsFn","BaseObservable","_debugNameData","_getValue","_getTransaction","_equalityComparator","hasValue","handleEvent","newValue","oldValue","didChange","didRunTransaction","subtransaction","tx","getLogger","handleFromEventObservableTriggered","change","hadValue","o","observers","updateObserver","handleChange","name","getDebugName","onFirstObserverAdded","subscription","onLastObserverRemoved","dispose","observableSignalFromEvent","FromEventObservableSignal","Observer","batchEventsGlobally","fn","didSet","transaction","observableSignal","debugNameOrOwner","ObservableSignal","_owner","_debugName","trigger","keepObserved","observable","KeepAliveObserver","toDisposable","recomputeInitiallyAndOnChange","handleValue","reportChanges","_setKeepObserved","_setRecomputeInitiallyAndOnChange","_forceRecompute","_handleValue","_counter","beginUpdate","endUpdate","handlePossibleChange","derivedObservableWithCache","computeFn","lastValue","derivedOpts","reader","derivedObservableWithWritableCache","onChange","derived","read","Object","assign","clearCache","setCache","mapObservableArrayCached","items","map","keySelector","m","ArrayMap","setItems","getItems","_map","_keySelector","_cache","Map","_items","forEach","entry","store","clear","newItems","itemsToRemove","Set","keys","item","key","delete","DisposableStore","out","set","push","ValueWithChangeEventFromObservable","onDidChange","Event","fromObservableLight","observableFromValueWithChangeEvent","derivedConstOnceDefined","a","b","itemsEquals","itemEquals","equals","equalsIfDefined","equalsOrV1","v2","v1","structuralEquals","Array","isArray","i","getPrototypeOf","prototype","aObj","bObj","keysA","keysB","keysBSet","has","WeakMap","globalObservableLogger","setLogger","logger","ConsoleObservableLogger","indentation","changedObservablesSets","textToConsoleArgs","text","styles","data","firstArg","process","t","style","result","consoleTextToArgs","normalText","repeat","formatInfo","info","styled","formatValue","color","strikeThrough","handleObservableChanged","console","log","formatKind","formatChanges","changes","size","join","handleDerivedCreated","existingHandleChange","add","apply","handleDerivedRecomputed","changedObservables","referenceFn","_computeFn","handleAutorunCreated","autorun","handleAutorunTriggered","_runFn","handleAutorunFinished","handleBeginTransaction","transactionName","_fn","handleEndTransaction","kind","str","padStr","bold","styleObj","entries","reduce","styleString","propName","propValue","availableLen","substr","first","val","formatArray","formatObject","count","LanguageService","Disposable","instanceCount","warnOnOverwrite","_onDidRequestBasicLanguageFeatures","_register","Emitter","onDidRequestBasicLanguageFeatures","_onDidRequestRichLanguageFeatures","onDidRequestRichLanguageFeatures","_onDidChange","leakWarningThreshold","_requestedBasicLanguages","_requestedRichLanguages","_registry","LanguagesRegistry","languageIdCodec","fire","isRegisteredLanguageId","languageId","getLanguageIdByLanguageName","languageName","getLanguageIdByMimeType","mimeType","guessLanguageIdByFilepathOrFirstLine","resource","firstLine","languageIds","firstOrDefault","createById","LanguageSelection","_createAndGetLanguageIdentifier","createByFilepathOrFirstLine","PLAINTEXT_LANGUAGE_ID","requestBasicLanguageFeatures","requestRichLanguageFeatures","TokenizationRegistry","getOrCreate","onDidChangeLanguages","selector","_value","fromObservable","registeredAssociations","nonUserRegisteredAssociations","userRegisteredAssociations","registerPlatformLanguageAssociation","association","userConfigured","associationItem","id","mime","filename","extension","filepattern","firstline","filenameLowercase","toLowerCase","extensionLowercase","filepatternLowercase","parse","filepatternOnPath","indexOf","posix","sep","toLanguageAssociationItem","warn","_registerLanguageAssociation","clearPlatformLanguageAssociations","filter","getLanguageIds","path","scheme","Schemas","file","fsPath","DataUri","parseMetaData","META_DATA_LABEL","vscodeNotebookCell","Mimes","unknown","basename","configuredLanguage","getAssociationByPath","registeredLanguage","firstlineLanguage","startsWithUTF8BOM","matches","match","getAssociationByFirstline","getAssociations","associations","filenameMatch","patternMatch","extensionMatch","target","endsWith","hasOwnProperty","NULL_LANGUAGE_ID","LanguageIdCodec","_languageIdToLanguage","_languageToLanguageId","_nextLanguageId","language","register","encodeLanguageId","decodeLanguageId","useModesRegistry","_warnOnOverwrite","_dynamicLanguages","_languages","_mimeTypesMap","_nameMap","_lowercaseNameMap","_initializeFromRegistry","ModesRegistry","desc","concat","getLanguages","_registerLanguages","d","_registerLanguage","langId","identifier","aliases","alias","mimetypes","mimetype","Registry","as","Extensions","Configuration","registerOverrideIdentifiers","getRegisteredLanguageIds","lang","resolvedLanguage","call","extensions","filenames","configurationFiles","icons","_mergeLanguage","primaryMime","configuration","filenamePatterns","filenamePattern","firstLineRegexStr","charAt","firstLineRegex","RegExp","regExpLeadsToEndlessLoop","err","langAliases","langAlias","containsAliases","bestName","icon","languageNameLower","AutorunObserver","autorunOpts","autorunHandleChanges","createEmptyChangeSummary","autorunWithStoreHandleChanges","disposable","changeSummary","autorunWithStore","createChangeSummary","_handleChange","state","updateCount","disposed","dependencies","dependenciesToBeRemoved","_runIfNeeded","trackDisposable","markAsDisposed","emptySet","isDisposed","assert","assertFn","changedObservable","readObservable","ObservablePromise","fromFn","promise","observableValue","promiseResult","then","PromiseResult","error","waitForState","predicate","isError","cancellationToken","Promise","resolve","reject","isImmediateRun","shouldDispose","stateObs","isFinished","dc","onCancellationRequested","CancellationError","isCancellationRequested","LazyObservableValue","initialValue","_isUpToDate","_deltas","_updateCounter","_update","_beginUpdate","_endUpdate","r","shouldCallBeginUpdate","shouldCallEndUpdate","_tx","TransactionImpl","_setValue","finish","observableValueOpts","lazy","ObservableValue","_recomputeInitiallyAndOnChange","_keepObserved","_derived","_globalTransaction","_setDerivedOpts","TChange","fnOrOwner","fnOrUndefined","getFunctionName","exec","flatten","arguments","len","async","asyncTransaction","_getDebugName","updatingObservers","nameOrOwner","debugNameData","disposableObservableValue","DisposableObservableValue","debugNameSource","countPerName","cachedDebugName","cached","dbgName","self","ownerStr","ownerId","className","obj","ctor","getClassName","countPerClassName","formatOwner","findKey","computeDebugName","fnSrc","trim","computeFnOrOwner","Derived","derivedWithSetter","setter","DerivedWithSetter","derivedHandleChanges","equalityComparer","derivedWithStore","computeFnOrUndefined","derivedDisposable","_handleLastObserverRemoved","_recomputeIfNeeded","_observable","propagateBeginUpdate","shouldReact","wasUpToDate","handleLastObserverRemoved","equalityComparator"],"ignoreList":[],"sourceRoot":""}