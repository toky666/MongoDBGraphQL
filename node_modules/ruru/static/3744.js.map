{"version":3,"file":"3744.js","mappings":"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","sources":["webpack://ruru/../../node_modules/langium/lib/utils/errors.js","webpack://ruru/../../node_modules/langium/lib/languages/generated/ast.js","webpack://ruru/../../node_modules/lodash-es/_baseMap.js","webpack://ruru/../../node_modules/lodash-es/_baseSet.js","webpack://ruru/../../node_modules/lodash-es/_basePickBy.js","webpack://ruru/../../node_modules/lodash-es/clone.js","webpack://ruru/../../node_modules/lodash-es/last.js","webpack://ruru/../../node_modules/lodash-es/isString.js","webpack://ruru/../../node_modules/langium/lib/parser/token-builder.js","webpack://ruru/../../node_modules/langium/lib/utils/regexp-utils.js","webpack://ruru/../../node_modules/lodash-es/_trimmedEndIndex.js","webpack://ruru/../../node_modules/lodash-es/_baseTrim.js","webpack://ruru/../../node_modules/lodash-es/toNumber.js","webpack://ruru/../../node_modules/lodash-es/toFinite.js","webpack://ruru/../../node_modules/langium/lib/syntax-tree.js","webpack://ruru/../../node_modules/vscode-uri/lib/esm/index.mjs","webpack://ruru/../../node_modules/lodash-es/toInteger.js","webpack://ruru/../../node_modules/langium/lib/utils/stream.js","webpack://ruru/../../node_modules/lodash-es/_hasUnicode.js","webpack://ruru/../../node_modules/langium/lib/workspace/file-system-provider.js","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-T53DSG4Q.mjs","webpack://ruru/../../node_modules/lodash-es/findIndex.js","webpack://ruru/../../node_modules/lodash-es/find.js","webpack://ruru/../../node_modules/lodash-es/_createFind.js","webpack://ruru/../../node_modules/vscode-jsonrpc/lib/common/ral.js","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs","webpack://ruru/../../node_modules/lodash-es/flatten.js","webpack://ruru/../../node_modules/chevrotain/lib/src/version.js","webpack://ruru/../../node_modules/@chevrotain/utils/lib/src/to-fast-properties.js","webpack://ruru/../../node_modules/lodash-es/_baseSlice.js","webpack://ruru/../../node_modules/lodash-es/drop.js","webpack://ruru/../../node_modules/lodash-es/assign.js","webpack://ruru/../../node_modules/lodash-es/pickBy.js","webpack://ruru/../../node_modules/lodash-es/isRegExp.js","webpack://ruru/../../node_modules/lodash-es/_baseIsRegExp.js","webpack://ruru/../../node_modules/@chevrotain/gast/lib/src/model.js","webpack://ruru/../../node_modules/@chevrotain/gast/lib/src/visitor.js","webpack://ruru/../../node_modules/lodash-es/_baseSome.js","webpack://ruru/../../node_modules/lodash-es/some.js","webpack://ruru/../../node_modules/lodash-es/includes.js","webpack://ruru/../../node_modules/lodash-es/_arrayEvery.js","webpack://ruru/../../node_modules/lodash-es/_baseEvery.js","webpack://ruru/../../node_modules/lodash-es/every.js","webpack://ruru/../../node_modules/@chevrotain/gast/lib/src/helpers.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/rest.js","webpack://ruru/../../node_modules/lodash-es/uniq.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/first.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/constants.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/follow.js","webpack://ruru/../../node_modules/lodash-es/negate.js","webpack://ruru/../../node_modules/lodash-es/reject.js","webpack://ruru/../../node_modules/lodash-es/indexOf.js","webpack://ruru/../../node_modules/lodash-es/difference.js","webpack://ruru/../../node_modules/lodash-es/_baseDifference.js","webpack://ruru/../../node_modules/lodash-es/compact.js","webpack://ruru/../../node_modules/lodash-es/head.js","webpack://ruru/../../node_modules/@chevrotain/utils/lib/src/print.js","webpack://ruru/../../node_modules/chevrotain/lib/src/scan/reg_exp_parser.js","webpack://ruru/../../node_modules/chevrotain/lib/src/scan/reg_exp.js","webpack://ruru/../../node_modules/chevrotain/lib/src/scan/lexer.js","webpack://ruru/../../node_modules/@chevrotain/utils/lib/src/timer.js","webpack://ruru/../../node_modules/chevrotain/lib/src/scan/tokens.js","webpack://ruru/../../node_modules/chevrotain/lib/src/scan/lexer_errors_public.js","webpack://ruru/../../node_modules/chevrotain/lib/src/scan/lexer_public.js","webpack://ruru/../../node_modules/chevrotain/lib/src/scan/tokens_public.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/errors_public.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/resolver.js","webpack://ruru/../../node_modules/lodash-es/_arrayAggregator.js","webpack://ruru/../../node_modules/lodash-es/_baseAggregator.js","webpack://ruru/../../node_modules/lodash-es/groupBy.js","webpack://ruru/../../node_modules/lodash-es/_createAggregator.js","webpack://ruru/../../node_modules/lodash-es/dropRight.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/interpreter.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/lookahead.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/checks.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/exceptions_public.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/keys.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/cst/cst.js","webpack://ruru/../../node_modules/chevrotain/lib/src/lang/lang_extensions.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/parser.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js","webpack://ruru/../../node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js","webpack://ruru/../../node_modules/@chevrotain/cst-dts-gen/lib/src/model.js","webpack://ruru/../../node_modules/lodash-es/_unicodeToArray.js","webpack://ruru/../../node_modules/lodash-es/_stringToArray.js","webpack://ruru/../../node_modules/lodash-es/_asciiToArray.js","webpack://ruru/../../node_modules/lodash-es/upperFirst.js","webpack://ruru/../../node_modules/lodash-es/_createCaseFirst.js","webpack://ruru/../../node_modules/lodash-es/_castSlice.js","webpack://ruru/../../node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js","webpack://ruru/../../node_modules/@chevrotain/cst-dts-gen/lib/src/api.js","webpack://ruru/../../node_modules/chevrotain/lib/src/diagrams/render_public.js","webpack://ruru/../../node_modules/chevrotain/lib/src/api.js","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-S6J4BHB3.mjs","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-LBM3YZW2.mjs","webpack://ruru/../../node_modules/vscode-jsonrpc/lib/common/events.js","webpack://ruru/../../node_modules/lodash-es/_baseHas.js","webpack://ruru/../../node_modules/lodash-es/has.js","webpack://ruru/../../node_modules/lodash-es/min.js","webpack://ruru/../../node_modules/lodash-es/map.js","webpack://ruru/../../node_modules/langium/lib/utils/cst-utils.js","webpack://ruru/../../node_modules/langium/lib/utils/ast-utils.js","webpack://ruru/../../node_modules/lodash-es/defaults.js","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-76Q3JFCE.mjs","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs","webpack://ruru/../../node_modules/langium/lib/utils/grammar-loader.js","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs","webpack://ruru/../../node_modules/lodash-es/_baseLt.js","webpack://ruru/../../node_modules/vscode-jsonrpc/lib/common/cancellation.js","webpack://ruru/../../node_modules/lodash-es/_baseExtremum.js","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs","webpack://ruru/../../node_modules/langium/lib/dependency-injection.js","webpack://ruru/../../node_modules/vscode-jsonrpc/lib/common/is.js","webpack://ruru/../../node_modules/chevrotain-allstar/lib/atn.js","webpack://ruru/../../node_modules/chevrotain-allstar/lib/dfa.js","webpack://ruru/../../node_modules/chevrotain-allstar/lib/all-star-lookahead.js","webpack://ruru/../../node_modules/lodash-es/uniqBy.js","webpack://ruru/../../node_modules/langium/lib/parser/cst-node-builder.js","webpack://ruru/../../node_modules/langium/lib/parser/langium-parser.js","webpack://ruru/../../node_modules/langium/lib/parser/parser-builder-base.js","webpack://ruru/../../node_modules/langium/lib/utils/promise-utils.js","webpack://ruru/../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js","webpack://ruru/../../node_modules/langium/lib/workspace/documents.js","webpack://ruru/../../node_modules/langium/lib/references/linker.js","webpack://ruru/../../node_modules/langium/lib/references/name-provider.js","webpack://ruru/../../node_modules/langium/lib/utils/uri-utils.js","webpack://ruru/../../node_modules/langium/lib/validation/validation-registry.js","webpack://ruru/../../node_modules/langium/lib/validation/document-validator.js","webpack://ruru/../../node_modules/langium/lib/references/references.js","webpack://ruru/../../node_modules/langium/lib/utils/collections.js","webpack://ruru/../../node_modules/langium/lib/references/scope-computation.js","webpack://ruru/../../node_modules/langium/lib/references/scope.js","webpack://ruru/../../node_modules/langium/lib/utils/caching.js","webpack://ruru/../../node_modules/langium/lib/references/scope-provider.js","webpack://ruru/../../node_modules/langium/lib/serializer/json-serializer.js","webpack://ruru/../../node_modules/langium/lib/service-registry.js","webpack://ruru/../../node_modules/langium/lib/workspace/ast-descriptions.js","webpack://ruru/../../node_modules/langium/lib/workspace/ast-node-locator.js","webpack://ruru/../../node_modules/langium/lib/utils/disposable.js","webpack://ruru/../../node_modules/langium/lib/workspace/configuration.js","webpack://ruru/../../node_modules/langium/lib/workspace/document-builder.js","webpack://ruru/../../node_modules/langium/lib/workspace/index-manager.js","webpack://ruru/../../node_modules/langium/lib/workspace/workspace-manager.js","webpack://ruru/../../node_modules/langium/lib/parser/lexer.js","webpack://ruru/../../node_modules/langium/lib/documentation/jsdoc.js","webpack://ruru/../../node_modules/langium/lib/documentation/documentation-provider.js","webpack://ruru/../../node_modules/langium/lib/documentation/comment-provider.js","webpack://ruru/../../node_modules/langium/lib/parser/async-parser.js","webpack://ruru/../../node_modules/langium/lib/workspace/workspace-lock.js","webpack://ruru/../../node_modules/langium/lib/serializer/hydrator.js","webpack://ruru/../../node_modules/langium/lib/default-module.js","webpack://ruru/../../node_modules/langium/lib/languages/grammar-config.js","webpack://ruru/../../node_modules/langium/lib/parser/langium-parser-builder.js","webpack://ruru/../../node_modules/langium/lib/parser/completion-parser-builder.js","webpack://ruru/../../node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js","webpack://ruru/../../node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js","webpack://ruru/../../node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js","webpack://ruru/../../node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js","webpack://ruru/../../node_modules/lodash-es/flatMap.js","webpack://ruru/../../node_modules/langium/lib/utils/grammar-utils.js","webpack://ruru/../../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-LHMN2FUI.mjs","webpack://ruru/../../node_modules/langium/lib/parser/value-converter.js"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class ErrorWithLocation extends Error {\n    constructor(node, message) {\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n}\nexport function assertUnreachable(_) {\n    throw new Error('Error! The input value was not handled.');\n}\n//# sourceMappingURL=errors.js.map","/******************************************************************************\n * This file was generated by langium-cli 3.3.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\nimport { AbstractAstReflection } from '../../syntax-tree.js';\nexport const LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\n};\nexport const AbstractRule = 'AbstractRule';\nexport function isAbstractRule(item) {\n    return reflection.isInstance(item, AbstractRule);\n}\nexport const AbstractType = 'AbstractType';\nexport function isAbstractType(item) {\n    return reflection.isInstance(item, AbstractType);\n}\nexport const Condition = 'Condition';\nexport function isCondition(item) {\n    return reflection.isInstance(item, Condition);\n}\nexport function isFeatureName(item) {\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\n}\nexport function isPrimitiveType(item) {\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\n}\nexport const TypeDefinition = 'TypeDefinition';\nexport function isTypeDefinition(item) {\n    return reflection.isInstance(item, TypeDefinition);\n}\nexport const ValueLiteral = 'ValueLiteral';\nexport function isValueLiteral(item) {\n    return reflection.isInstance(item, ValueLiteral);\n}\nexport const AbstractElement = 'AbstractElement';\nexport function isAbstractElement(item) {\n    return reflection.isInstance(item, AbstractElement);\n}\nexport const ArrayLiteral = 'ArrayLiteral';\nexport function isArrayLiteral(item) {\n    return reflection.isInstance(item, ArrayLiteral);\n}\nexport const ArrayType = 'ArrayType';\nexport function isArrayType(item) {\n    return reflection.isInstance(item, ArrayType);\n}\nexport const BooleanLiteral = 'BooleanLiteral';\nexport function isBooleanLiteral(item) {\n    return reflection.isInstance(item, BooleanLiteral);\n}\nexport const Conjunction = 'Conjunction';\nexport function isConjunction(item) {\n    return reflection.isInstance(item, Conjunction);\n}\nexport const Disjunction = 'Disjunction';\nexport function isDisjunction(item) {\n    return reflection.isInstance(item, Disjunction);\n}\nexport const Grammar = 'Grammar';\nexport function isGrammar(item) {\n    return reflection.isInstance(item, Grammar);\n}\nexport const GrammarImport = 'GrammarImport';\nexport function isGrammarImport(item) {\n    return reflection.isInstance(item, GrammarImport);\n}\nexport const InferredType = 'InferredType';\nexport function isInferredType(item) {\n    return reflection.isInstance(item, InferredType);\n}\nexport const Interface = 'Interface';\nexport function isInterface(item) {\n    return reflection.isInstance(item, Interface);\n}\nexport const NamedArgument = 'NamedArgument';\nexport function isNamedArgument(item) {\n    return reflection.isInstance(item, NamedArgument);\n}\nexport const Negation = 'Negation';\nexport function isNegation(item) {\n    return reflection.isInstance(item, Negation);\n}\nexport const NumberLiteral = 'NumberLiteral';\nexport function isNumberLiteral(item) {\n    return reflection.isInstance(item, NumberLiteral);\n}\nexport const Parameter = 'Parameter';\nexport function isParameter(item) {\n    return reflection.isInstance(item, Parameter);\n}\nexport const ParameterReference = 'ParameterReference';\nexport function isParameterReference(item) {\n    return reflection.isInstance(item, ParameterReference);\n}\nexport const ParserRule = 'ParserRule';\nexport function isParserRule(item) {\n    return reflection.isInstance(item, ParserRule);\n}\nexport const ReferenceType = 'ReferenceType';\nexport function isReferenceType(item) {\n    return reflection.isInstance(item, ReferenceType);\n}\nexport const ReturnType = 'ReturnType';\nexport function isReturnType(item) {\n    return reflection.isInstance(item, ReturnType);\n}\nexport const SimpleType = 'SimpleType';\nexport function isSimpleType(item) {\n    return reflection.isInstance(item, SimpleType);\n}\nexport const StringLiteral = 'StringLiteral';\nexport function isStringLiteral(item) {\n    return reflection.isInstance(item, StringLiteral);\n}\nexport const TerminalRule = 'TerminalRule';\nexport function isTerminalRule(item) {\n    return reflection.isInstance(item, TerminalRule);\n}\nexport const Type = 'Type';\nexport function isType(item) {\n    return reflection.isInstance(item, Type);\n}\nexport const TypeAttribute = 'TypeAttribute';\nexport function isTypeAttribute(item) {\n    return reflection.isInstance(item, TypeAttribute);\n}\nexport const UnionType = 'UnionType';\nexport function isUnionType(item) {\n    return reflection.isInstance(item, UnionType);\n}\nexport const Action = 'Action';\nexport function isAction(item) {\n    return reflection.isInstance(item, Action);\n}\nexport const Alternatives = 'Alternatives';\nexport function isAlternatives(item) {\n    return reflection.isInstance(item, Alternatives);\n}\nexport const Assignment = 'Assignment';\nexport function isAssignment(item) {\n    return reflection.isInstance(item, Assignment);\n}\nexport const CharacterRange = 'CharacterRange';\nexport function isCharacterRange(item) {\n    return reflection.isInstance(item, CharacterRange);\n}\nexport const CrossReference = 'CrossReference';\nexport function isCrossReference(item) {\n    return reflection.isInstance(item, CrossReference);\n}\nexport const EndOfFile = 'EndOfFile';\nexport function isEndOfFile(item) {\n    return reflection.isInstance(item, EndOfFile);\n}\nexport const Group = 'Group';\nexport function isGroup(item) {\n    return reflection.isInstance(item, Group);\n}\nexport const Keyword = 'Keyword';\nexport function isKeyword(item) {\n    return reflection.isInstance(item, Keyword);\n}\nexport const NegatedToken = 'NegatedToken';\nexport function isNegatedToken(item) {\n    return reflection.isInstance(item, NegatedToken);\n}\nexport const RegexToken = 'RegexToken';\nexport function isRegexToken(item) {\n    return reflection.isInstance(item, RegexToken);\n}\nexport const RuleCall = 'RuleCall';\nexport function isRuleCall(item) {\n    return reflection.isInstance(item, RuleCall);\n}\nexport const TerminalAlternatives = 'TerminalAlternatives';\nexport function isTerminalAlternatives(item) {\n    return reflection.isInstance(item, TerminalAlternatives);\n}\nexport const TerminalGroup = 'TerminalGroup';\nexport function isTerminalGroup(item) {\n    return reflection.isInstance(item, TerminalGroup);\n}\nexport const TerminalRuleCall = 'TerminalRuleCall';\nexport function isTerminalRuleCall(item) {\n    return reflection.isInstance(item, TerminalRuleCall);\n}\nexport const UnorderedGroup = 'UnorderedGroup';\nexport function isUnorderedGroup(item) {\n    return reflection.isInstance(item, UnorderedGroup);\n}\nexport const UntilToken = 'UntilToken';\nexport function isUntilToken(item) {\n    return reflection.isInstance(item, UntilToken);\n}\nexport const Wildcard = 'Wildcard';\nexport function isWildcard(item) {\n    return reflection.isInstance(item, Wildcard);\n}\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\n    getAllTypes() {\n        return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\n    }\n    computeIsSubtype(subtype, supertype) {\n        switch (subtype) {\n            case Action:\n            case Alternatives:\n            case Assignment:\n            case CharacterRange:\n            case CrossReference:\n            case EndOfFile:\n            case Group:\n            case Keyword:\n            case NegatedToken:\n            case RegexToken:\n            case RuleCall:\n            case TerminalAlternatives:\n            case TerminalGroup:\n            case TerminalRuleCall:\n            case UnorderedGroup:\n            case UntilToken:\n            case Wildcard: {\n                return this.isSubtype(AbstractElement, supertype);\n            }\n            case ArrayLiteral:\n            case NumberLiteral:\n            case StringLiteral: {\n                return this.isSubtype(ValueLiteral, supertype);\n            }\n            case ArrayType:\n            case ReferenceType:\n            case SimpleType:\n            case UnionType: {\n                return this.isSubtype(TypeDefinition, supertype);\n            }\n            case BooleanLiteral: {\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n            }\n            case Conjunction:\n            case Disjunction:\n            case Negation:\n            case ParameterReference: {\n                return this.isSubtype(Condition, supertype);\n            }\n            case InferredType:\n            case Interface:\n            case Type: {\n                return this.isSubtype(AbstractType, supertype);\n            }\n            case ParserRule: {\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n            }\n            case TerminalRule: {\n                return this.isSubtype(AbstractRule, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    getReferenceType(refInfo) {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            case 'Action:type':\n            case 'CrossReference:type':\n            case 'Interface:superTypes':\n            case 'ParserRule:returnType':\n            case 'SimpleType:typeRef': {\n                return AbstractType;\n            }\n            case 'Grammar:hiddenTokens':\n            case 'ParserRule:hiddenTokens':\n            case 'RuleCall:rule': {\n                return AbstractRule;\n            }\n            case 'Grammar:usedGrammars': {\n                return Grammar;\n            }\n            case 'NamedArgument:parameter':\n            case 'ParameterReference:parameter': {\n                return Parameter;\n            }\n            case 'TerminalRuleCall:rule': {\n                return TerminalRule;\n            }\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n    getTypeMetaData(type) {\n        switch (type) {\n            case AbstractElement: {\n                return {\n                    name: AbstractElement,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case ArrayLiteral: {\n                return {\n                    name: ArrayLiteral,\n                    properties: [\n                        { name: 'elements', defaultValue: [] }\n                    ]\n                };\n            }\n            case ArrayType: {\n                return {\n                    name: ArrayType,\n                    properties: [\n                        { name: 'elementType' }\n                    ]\n                };\n            }\n            case BooleanLiteral: {\n                return {\n                    name: BooleanLiteral,\n                    properties: [\n                        { name: 'true', defaultValue: false }\n                    ]\n                };\n            }\n            case Conjunction: {\n                return {\n                    name: Conjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Disjunction: {\n                return {\n                    name: Disjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Grammar: {\n                return {\n                    name: Grammar,\n                    properties: [\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'imports', defaultValue: [] },\n                        { name: 'interfaces', defaultValue: [] },\n                        { name: 'isDeclared', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'rules', defaultValue: [] },\n                        { name: 'types', defaultValue: [] },\n                        { name: 'usedGrammars', defaultValue: [] }\n                    ]\n                };\n            }\n            case GrammarImport: {\n                return {\n                    name: GrammarImport,\n                    properties: [\n                        { name: 'path' }\n                    ]\n                };\n            }\n            case InferredType: {\n                return {\n                    name: InferredType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case Interface: {\n                return {\n                    name: Interface,\n                    properties: [\n                        { name: 'attributes', defaultValue: [] },\n                        { name: 'name' },\n                        { name: 'superTypes', defaultValue: [] }\n                    ]\n                };\n            }\n            case NamedArgument: {\n                return {\n                    name: NamedArgument,\n                    properties: [\n                        { name: 'calledByName', defaultValue: false },\n                        { name: 'parameter' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Negation: {\n                return {\n                    name: Negation,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NumberLiteral: {\n                return {\n                    name: NumberLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Parameter: {\n                return {\n                    name: Parameter,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case ParameterReference: {\n                return {\n                    name: ParameterReference,\n                    properties: [\n                        { name: 'parameter' }\n                    ]\n                };\n            }\n            case ParserRule: {\n                return {\n                    name: ParserRule,\n                    properties: [\n                        { name: 'dataType' },\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'definition' },\n                        { name: 'entry', defaultValue: false },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'inferredType' },\n                        { name: 'name' },\n                        { name: 'parameters', defaultValue: [] },\n                        { name: 'returnType' },\n                        { name: 'wildcard', defaultValue: false }\n                    ]\n                };\n            }\n            case ReferenceType: {\n                return {\n                    name: ReferenceType,\n                    properties: [\n                        { name: 'referenceType' }\n                    ]\n                };\n            }\n            case ReturnType: {\n                return {\n                    name: ReturnType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case SimpleType: {\n                return {\n                    name: SimpleType,\n                    properties: [\n                        { name: 'primitiveType' },\n                        { name: 'stringType' },\n                        { name: 'typeRef' }\n                    ]\n                };\n            }\n            case StringLiteral: {\n                return {\n                    name: StringLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case TerminalRule: {\n                return {\n                    name: TerminalRule,\n                    properties: [\n                        { name: 'definition' },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hidden', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Type: {\n                return {\n                    name: Type,\n                    properties: [\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case TypeAttribute: {\n                return {\n                    name: TypeAttribute,\n                    properties: [\n                        { name: 'defaultValue' },\n                        { name: 'isOptional', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case UnionType: {\n                return {\n                    name: UnionType,\n                    properties: [\n                        { name: 'types', defaultValue: [] }\n                    ]\n                };\n            }\n            case Action: {\n                return {\n                    name: Action,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'inferredType' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Alternatives: {\n                return {\n                    name: Alternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Assignment: {\n                return {\n                    name: Assignment,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case CharacterRange: {\n                return {\n                    name: CharacterRange,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'left' },\n                        { name: 'lookahead' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case CrossReference: {\n                return {\n                    name: CrossReference,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'deprecatedSyntax', defaultValue: false },\n                        { name: 'lookahead' },\n                        { name: 'terminal' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case EndOfFile: {\n                return {\n                    name: EndOfFile,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Group: {\n                return {\n                    name: Group,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'guardCondition' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Keyword: {\n                return {\n                    name: Keyword,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NegatedToken: {\n                return {\n                    name: NegatedToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case RegexToken: {\n                return {\n                    name: RegexToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'regex' }\n                    ]\n                };\n            }\n            case RuleCall: {\n                return {\n                    name: RuleCall,\n                    properties: [\n                        { name: 'arguments', defaultValue: [] },\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case TerminalAlternatives: {\n                return {\n                    name: TerminalAlternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalGroup: {\n                return {\n                    name: TerminalGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalRuleCall: {\n                return {\n                    name: TerminalRuleCall,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case UnorderedGroup: {\n                return {\n                    name: UnorderedGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case UntilToken: {\n                return {\n                    name: UntilToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case Wildcard: {\n                return {\n                    name: Wildcard,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\nexport const reflection = new LangiumGrammarAstReflection();\n//# sourceMappingURL=ast.js.map","import baseEach from './_baseEach.js';\nimport isArrayLike from './isArrayLike.js';\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nexport default baseMap;\n","import assignValue from './_assignValue.js';\nimport castPath from './_castPath.js';\nimport isIndex from './_isIndex.js';\nimport isObject from './isObject.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nexport default baseSet;\n","import baseGet from './_baseGet.js';\nimport baseSet from './_baseSet.js';\nimport castPath from './_castPath.js';\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nexport default basePickBy;\n","import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nexport default clone;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n","import baseGetTag from './_baseGetTag.js';\nimport isArray from './isArray.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nexport default isString;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Lexer } from 'chevrotain';\nimport { isKeyword, isParserRule, isTerminalRule } from '../languages/generated/ast.js';\nimport { streamAllContents } from '../utils/ast-utils.js';\nimport { getAllReachableRules, terminalRegex } from '../utils/grammar-utils.js';\nimport { getCaseInsensitivePattern, isWhitespace, partialMatches } from '../utils/regexp-utils.js';\nimport { stream } from '../utils/stream.js';\nexport class DefaultTokenBuilder {\n    constructor() {\n        /**\n         * The list of diagnostics stored during the lexing process of a single text.\n         */\n        this.diagnostics = [];\n    }\n    buildTokens(grammar, options) {\n        const reachableRules = stream(getAllReachableRules(grammar, false));\n        const terminalTokens = this.buildTerminalTokens(reachableRules);\n        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n        terminalTokens.forEach(terminalToken => {\n            const pattern = terminalToken.PATTERN;\n            if (typeof pattern === 'object' && pattern && 'test' in pattern && isWhitespace(pattern)) {\n                tokens.unshift(terminalToken);\n            }\n            else {\n                tokens.push(terminalToken);\n            }\n        });\n        // We don't need to add the EOF token explicitly.\n        // It is automatically available at the end of the token stream.\n        return tokens;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    flushLexingReport(text) {\n        return { diagnostics: this.popDiagnostics() };\n    }\n    popDiagnostics() {\n        const diagnostics = [...this.diagnostics];\n        this.diagnostics = [];\n        return diagnostics;\n    }\n    buildTerminalTokens(rules) {\n        return rules.filter(isTerminalRule).filter(e => !e.fragment)\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\n    }\n    buildTerminalToken(terminal) {\n        const regex = terminalRegex(terminal);\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n        const tokenType = {\n            name: terminal.name,\n            PATTERN: pattern,\n        };\n        if (typeof pattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        if (terminal.hidden) {\n            // Only skip tokens that are able to accept whitespace\n            tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : 'hidden';\n        }\n        return tokenType;\n    }\n    requiresCustomPattern(regex) {\n        if (regex.flags.includes('u') || regex.flags.includes('s')) {\n            // Unicode and dotall regexes are not supported by Chevrotain.\n            return true;\n        }\n        else if (regex.source.includes('?<=') || regex.source.includes('?<!')) {\n            // Negative and positive lookbehind are not supported by Chevrotain yet.\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    regexPatternFunction(regex) {\n        const stickyRegex = new RegExp(regex, regex.flags + 'y');\n        return (text, offset) => {\n            stickyRegex.lastIndex = offset;\n            const execResult = stickyRegex.exec(text);\n            return execResult;\n        };\n    }\n    buildKeywordTokens(rules, terminalTokens, options) {\n        return rules\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\n            .filter(isParserRule)\n            .flatMap(rule => streamAllContents(rule).filter(isKeyword))\n            .distinct(e => e.value).toArray()\n            // Sort keywords by descending length\n            .sort((a, b) => b.value.length - a.value.length)\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n    }\n    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n        const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);\n        const tokenType = {\n            name: keyword.value,\n            PATTERN: keywordPattern,\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n        };\n        if (typeof keywordPattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        return tokenType;\n    }\n    buildKeywordPattern(keyword, caseInsensitive) {\n        return caseInsensitive ?\n            new RegExp(getCaseInsensitivePattern(keyword.value)) :\n            keyword.value;\n    }\n    findLongerAlt(keyword, terminalTokens) {\n        return terminalTokens.reduce((longerAlts, token) => {\n            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && partialMatches('^' + pattern.source + '$', keyword.value)) {\n                longerAlts.push(token);\n            }\n            return longerAlts;\n        }, []);\n    }\n}\n//# sourceMappingURL=token-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';\nexport const NEWLINE_REGEXP = /\\r?\\n/gm;\nconst regexpParser = new RegExpParser();\n/**\n * This class is in charge of heuristically identifying start/end tokens of terminals.\n *\n * The way this works is by doing the following:\n * 1. Traverse the regular expression in the \"start state\"\n * 2. Add any encountered sets/single characters to the \"start regexp\"\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\n * 5. If we re-encounter any variable-length content we reset the end stack\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\n *\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\n */\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\n    constructor() {\n        super(...arguments);\n        this.isStarting = true;\n        this.endRegexpStack = [];\n        this.multiline = false;\n    }\n    get endRegex() {\n        return this.endRegexpStack.join('');\n    }\n    reset(regex) {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = '';\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n    visitGroup(node) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n    visitCharacter(node) {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === '\\n') {\n            this.multiline = true;\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const escapedChar = escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) {\n                this.startRegexp += escapedChar;\n            }\n        }\n    }\n    visitSet(node) {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean('\\n'.match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) {\n                this.startRegexp += set;\n            }\n        }\n    }\n    visitChildren(node) {\n        if (node.type === 'Group') {\n            // Ignore children of groups with quantifier (+/*/?)\n            // These groups are unrelated to start/end tokens of terminals\n            const group = node;\n            if (group.quantifier) {\n                return;\n            }\n        }\n        super.visitChildren(node);\n    }\n}\nconst visitor = new TerminalRegExpVisitor();\nexport function getTerminalParts(regexp) {\n    try {\n        if (typeof regexp !== 'string') {\n            regexp = regexp.source;\n        }\n        regexp = `/${regexp}/`;\n        const pattern = regexpParser.pattern(regexp);\n        const parts = [];\n        for (const alternative of pattern.value.value) {\n            visitor.reset(regexp);\n            visitor.visit(alternative);\n            parts.push({\n                start: visitor.startRegexp,\n                end: visitor.endRegex\n            });\n        }\n        return parts;\n    }\n    catch (_a) {\n        return [];\n    }\n}\nexport function isMultilineComment(regexp) {\n    try {\n        if (typeof regexp === 'string') {\n            regexp = new RegExp(regexp);\n        }\n        regexp = regexp.toString();\n        visitor.reset(regexp);\n        // Parsing the pattern might fail (since it's user code)\n        visitor.visit(regexpParser.pattern(regexp));\n        return visitor.multiline;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * A set of all characters that are considered whitespace by the '\\s' RegExp character class.\n * Taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).\n */\nexport const whitespaceCharacters = ('\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007' +\n    '\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').split('');\nexport function isWhitespace(value) {\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\n    return whitespaceCharacters.some((ws) => regexp.test(ws));\n}\nexport function escapeRegExp(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nexport function getCaseInsensitivePattern(keyword) {\n    return Array.prototype.map.call(keyword, letter => /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join('');\n}\n/**\n * Determines whether the given input has a partial match with the specified regex.\n * @param regex The regex to partially match against\n * @param input The input string\n * @returns Whether any match exists.\n */\nexport function partialMatches(regex, input) {\n    const partial = partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n/**\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\n * @param regex The input regex to be converted.\n * @returns A partial regex constructed from the input regex.\n */\nexport function partialRegExp(regex) {\n    if (typeof regex === 'string') {\n        regex = new RegExp(regex);\n    }\n    const re = regex, source = regex.source;\n    let i = 0;\n    function process() {\n        let result = '', tmp;\n        function appendRaw(nbChars) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n        function appendOptional(nbChars) {\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\n            i += nbChars;\n        }\n        while (i < source.length) {\n            switch (source[i]) {\n                case '\\\\':\n                    switch (source[i + 1]) {\n                        case 'c':\n                            appendOptional(3);\n                            break;\n                        case 'x':\n                            appendOptional(4);\n                            break;\n                        case 'u':\n                            if (re.unicode) {\n                                if (source[i + 2] === '{') {\n                                    appendOptional(source.indexOf('}', i) - i + 1);\n                                }\n                                else {\n                                    appendOptional(6);\n                                }\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'p':\n                        case 'P':\n                            if (re.unicode) {\n                                appendOptional(source.indexOf('}', i) - i + 1);\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'k':\n                            appendOptional(source.indexOf('>', i) - i + 1);\n                            break;\n                        default:\n                            appendOptional(2);\n                            break;\n                    }\n                    break;\n                case '[':\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source) || [];\n                    appendOptional(tmp[0].length);\n                    break;\n                case '|':\n                case '^':\n                case '$':\n                case '*':\n                case '+':\n                case '?':\n                    appendRaw(1);\n                    break;\n                case '{':\n                    tmp = /\\{\\d+,?\\d*\\}/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source);\n                    if (tmp) {\n                        appendRaw(tmp[0].length);\n                    }\n                    else {\n                        appendOptional(1);\n                    }\n                    break;\n                case '(':\n                    if (source[i + 1] === '?') {\n                        switch (source[i + 2]) {\n                            case ':':\n                                result += '(?:';\n                                i += 3;\n                                result += process() + '|$)';\n                                break;\n                            case '=':\n                                result += '(?=';\n                                i += 3;\n                                result += process() + ')';\n                                break;\n                            case '!':\n                                tmp = i;\n                                i += 3;\n                                process();\n                                result += source.substr(tmp, i - tmp);\n                                break;\n                            case '<':\n                                switch (source[i + 3]) {\n                                    case '=':\n                                    case '!':\n                                        tmp = i;\n                                        i += 4;\n                                        process();\n                                        result += source.substr(tmp, i - tmp);\n                                        break;\n                                    default:\n                                        appendRaw(source.indexOf('>', i) - i + 1);\n                                        result += process() + '|$)';\n                                        break;\n                                }\n                                break;\n                        }\n                    }\n                    else {\n                        appendRaw(1);\n                        result += process() + '|$)';\n                    }\n                    break;\n                case ')':\n                    ++i;\n                    return result;\n                default:\n                    appendOptional(1);\n                    break;\n            }\n        }\n        return result;\n    }\n    return new RegExp(process(), regex.flags);\n}\n//# sourceMappingURL=regexp-utils.js.map","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import toNumber from './toNumber.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nexport default toFinite;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport function isAstNode(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$type === 'string';\n}\nexport function isReference(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$refText === 'string';\n}\nexport function isAstNodeDescription(obj) {\n    return typeof obj === 'object' && obj !== null\n        && typeof obj.name === 'string'\n        && typeof obj.type === 'string'\n        && typeof obj.path === 'string';\n}\nexport function isLinkingError(obj) {\n    return typeof obj === 'object' && obj !== null\n        && isAstNode(obj.container)\n        && isReference(obj.reference)\n        && typeof obj.message === 'string';\n}\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nexport class AbstractAstReflection {\n    constructor() {\n        this.subtypes = {};\n        this.allSubtypes = {};\n    }\n    isInstance(node, type) {\n        return isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n    isSubtype(subtype, supertype) {\n        if (subtype === supertype) {\n            return true;\n        }\n        let nested = this.subtypes[subtype];\n        if (!nested) {\n            nested = this.subtypes[subtype] = {};\n        }\n        const existing = nested[supertype];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n    getAllSubTypes(type) {\n        const existing = this.allSubtypes[type];\n        if (existing) {\n            return existing;\n        }\n        else {\n            const allTypes = this.getAllTypes();\n            const types = [];\n            for (const possibleSubType of allTypes) {\n                if (this.isSubtype(possibleSubType, type)) {\n                    types.push(possibleSubType);\n                }\n            }\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n}\nexport function isCompositeCstNode(node) {\n    return typeof node === 'object' && node !== null && Array.isArray(node.content);\n}\nexport function isLeafCstNode(node) {\n    return typeof node === 'object' && node !== null && typeof node.tokenType === 'object';\n}\nexport function isRootCstNode(node) {\n    return isCompositeCstNode(node) && typeof node.fullText === 'string';\n}\n//# sourceMappingURL=syntax-tree.js.map","var LIB;(()=>{\"use strict\";var t={470:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",i=0,o=-1,s=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(o===h-1||1===s);else if(o!==h-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var a=n.lastIndexOf(\"/\");if(a!==n.length-1){-1===a?(n=\"\",i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf(\"/\"),o=h,s=0;continue}}else if(2===n.length||1===n.length){n=\"\",i=0,o=h,s=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",i=2)}else n.length>0?n+=\"/\"+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n=\"\",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+\"/\"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&i&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+=\"/\"+i)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s<a?s:a,f=-1,u=0;u<=c;++u){if(u===c){if(a>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u)}var g=\"\";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===g.length?g+=\"..\":g+=\"/..\");return g.length>0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?\"/\":\".\":n&&1===i?\"//\":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var h=r.length-1,a=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===a&&(s=!1,a=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(o=n):(h=-1,o=a))}return i===o?o=a:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?\"\":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,h=t.length-1;h>=0;--h){var a=t.charCodeAt(h);if(47!==a)-1===i&&(o=!1,i=h+1),46===a?-1===r?r=h:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=h+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?\"\":t.slice(r,i)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root=\"/\",n=1):n=0;for(var s=-1,h=0,a=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===a&&(c=!1,a=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){h=f+1;break}return-1===s||-1===a||0===u||1===u&&s===a-1&&s===h+1?-1!==a&&(r.base=r.name=0===h&&o?t.slice(1,a):t.slice(h,a)):(0===h&&o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h>0?r.dir=t.slice(0,h-1):o&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var n={};(()=>{let t;if(r.r(n),r.d(n,{URI:()=>f,Utils:()=>P}),\"object\"==typeof process)t=\"win32\"===process.platform;else if(\"object\"==typeof navigator){let e=navigator.userAgent;t=e.indexOf(\"Windows\")>=0}const e=/^\\w[\\w\\d+.-]*$/,i=/^\\//,o=/^\\/\\//;function s(t,r){if(!t.scheme&&r)throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t.authority}\", path: \"${t.path}\", query: \"${t.query}\", fragment: \"${t.fragment}\"}`);if(t.scheme&&!e.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!i.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(o.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}const h=\"\",a=\"/\",c=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;class f{static isUri(t){return t instanceof f||!!t&&\"string\"==typeof t.authority&&\"string\"==typeof t.fragment&&\"string\"==typeof t.path&&\"string\"==typeof t.query&&\"string\"==typeof t.scheme&&\"string\"==typeof t.fsPath&&\"function\"==typeof t.with&&\"function\"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){\"object\"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==a&&(e=a+e):e=a}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,s(this,o))}get fsPath(){return m(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new l(e,r,n,i,o)}static parse(t,e=!1){const r=c.exec(t);return r?new l(r[2]||h,C(r[4]||h),C(r[5]||h),C(r[7]||h),C(r[9]||h),e):new l(h,h,h,h,h)}static file(e){let r=h;if(t&&(e=e.replace(/\\\\/g,a)),e[0]===a&&e[1]===a){const t=e.indexOf(a,2);-1===t?(r=e.substring(2),e=a):(r=e.substring(2,t),e=e.substring(t)||a)}return new l(\"file\",r,e,h,h)}static from(t){const e=new l(t.scheme,t.authority,t.path,t.query,t.fragment);return s(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof f)return t;{const e=new l(t);return e._formatted=t.external,e._fsPath=t._sep===u?t.fsPath:null,e}}return t}}const u=t?1:void 0;class l extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=m(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=u),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const g={58:\"%3A\",47:\"%2F\",63:\"%3F\",35:\"%23\",91:\"%5B\",93:\"%5D\",64:\"%40\",33:\"%21\",36:\"%24\",38:\"%26\",39:\"%27\",40:\"%28\",41:\"%29\",42:\"%2A\",43:\"%2B\",44:\"%2C\",59:\"%3B\",61:\"%3D\",32:\"%20\"};function d(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=g[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function p(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=g[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function m(e,r){let n;return n=e.authority&&e.path.length>1&&\"file\"===e.scheme?`//${e.authority}${e.path}`:47===e.path.charCodeAt(0)&&(e.path.charCodeAt(1)>=65&&e.path.charCodeAt(1)<=90||e.path.charCodeAt(1)>=97&&e.path.charCodeAt(1)<=122)&&58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&&(n=n.replace(/\\//g,\"\\\\\")),n}function y(t,e){const r=e?p:d;let n=\"\",{scheme:i,authority:o,path:s,query:h,fragment:c}=t;if(i&&(n+=i,n+=\":\"),(o||\"file\"===i)&&(n+=a,n+=a),o){let t=o.indexOf(\"@\");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(\":\"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=\":\",n+=r(e.substr(t+1),!1,!0)),n+=\"@\"}o=o.toLowerCase(),t=o.lastIndexOf(\":\"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return h&&(n+=\"?\",n+=r(h,!1,!1)),c&&(n+=\"#\",n+=e?c:d(c,!1,!1)),n}function v(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+v(t.substr(3)):t}}const b=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function C(t){return t.match(b)?t.replace(b,(t=>v(t))):t}var A=r(470);const w=A.posix||A,x=\"/\";var P;!function(t){t.joinPath=function(t,...e){return t.with({path:w.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==x&&(r=x+r,n=!0);let i=w.resolve(r,...e);return n&&i[0]===x&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===x)return t;let e=w.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=\"\"),t.with({path:e})},t.basename=function(t){return w.basename(t.path)},t.extname=function(t){return w.extname(t.path)}}(P||(P={}))})(),LIB=n})();export const{URI,Utils}=LIB;\n//# sourceMappingURL=index.mjs.map","import toFinite from './toFinite.js';\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nexport default toInteger;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * The default implementation of `Stream` works with two input functions:\n *  - The first function creates the initial state of an iteration.\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\n */\nexport class StreamImpl {\n    constructor(startFn, nextFn) {\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n    isEmpty() {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n    count() {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n    toArray() {\n        const result = [];\n        const iterator = this.iterator();\n        let next;\n        do {\n            next = iterator.next();\n            if (next.value !== undefined) {\n                result.push(next.value);\n            }\n        } while (!next.done);\n        return result;\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap(keyFn, valueFn) {\n        const entryStream = this.map(element => [\n            keyFn ? keyFn(element) : element,\n            valueFn ? valueFn(element) : element\n        ]);\n        return new Map(entryStream);\n    }\n    toString() {\n        return this.join();\n    }\n    concat(other) {\n        return new StreamImpl(() => ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }), state => {\n            let result;\n            if (!state.firstDone) {\n                do {\n                    result = this.nextFn(state.first);\n                    if (!result.done) {\n                        return result;\n                    }\n                } while (!result.done);\n                state.firstDone = true;\n            }\n            do {\n                result = state.iterator.next();\n                if (!result.done) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    join(separator = ',') {\n        const iterator = this.iterator();\n        let value = '';\n        let result;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) {\n                    value += separator;\n                }\n                value += toString(result.value);\n            }\n            addSeparator = true;\n        } while (!result.done);\n        return value;\n    }\n    indexOf(searchElement, fromIndex = 0) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (index >= fromIndex && next.value === searchElement) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    every(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (!predicate(next.value)) {\n                return false;\n            }\n            next = iterator.next();\n        }\n        return true;\n    }\n    some(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    forEach(callbackfn) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n    map(callbackfn) {\n        return new StreamImpl(this.startFn, (state) => {\n            const { done, value } = this.nextFn(state);\n            if (done) {\n                return DONE_RESULT;\n            }\n            else {\n                return { done: false, value: callbackfn(value) };\n            }\n        });\n    }\n    filter(predicate) {\n        return new StreamImpl(this.startFn, state => {\n            let result;\n            do {\n                result = this.nextFn(state);\n                if (!result.done && predicate(result.value)) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    nonNullable() {\n        return this.filter(e => e !== undefined && e !== null);\n    }\n    reduce(callbackfn, initialValue) {\n        const iterator = this.iterator();\n        let previousValue = initialValue;\n        let next = iterator.next();\n        while (!next.done) {\n            if (previousValue === undefined) {\n                previousValue = next.value;\n            }\n            else {\n                previousValue = callbackfn(previousValue, next.value);\n            }\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n    reduceRight(callbackfn, initialValue) {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n    recursiveReduce(iterator, callbackfn, initialValue) {\n        const next = iterator.next();\n        if (next.done) {\n            return initialValue;\n        }\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === undefined) {\n            return next.value;\n        }\n        return callbackfn(previousValue, next.value);\n    }\n    find(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return next.value;\n            }\n            next = iterator.next();\n        }\n        return undefined;\n    }\n    findIndex(predicate) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    includes(searchElement) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (next.value === searchElement) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    flatMap(callbackfn) {\n        return new StreamImpl(() => ({ this: this.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = this.nextFn(state.this);\n                if (!done) {\n                    const mapped = callbackfn(value);\n                    if (isIterable(mapped)) {\n                        state.iterator = mapped[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: mapped };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    flat(depth) {\n        if (depth === undefined) {\n            depth = 1;\n        }\n        if (depth <= 0) {\n            return this;\n        }\n        const stream = depth > 1 ? this.flat(depth - 1) : this;\n        return new StreamImpl(() => ({ this: stream.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = stream.nextFn(state.this);\n                if (!done) {\n                    if (isIterable(value)) {\n                        state.iterator = value[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: value };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    head() {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) {\n            return undefined;\n        }\n        return result.value;\n    }\n    tail(skipCount = 1) {\n        return new StreamImpl(() => {\n            const state = this.startFn();\n            for (let i = 0; i < skipCount; i++) {\n                const next = this.nextFn(state);\n                if (next.done) {\n                    return state;\n                }\n            }\n            return state;\n        }, this.nextFn);\n    }\n    limit(maxSize) {\n        return new StreamImpl(() => ({ size: 0, state: this.startFn() }), state => {\n            state.size++;\n            if (state.size > maxSize) {\n                return DONE_RESULT;\n            }\n            return this.nextFn(state.state);\n        });\n    }\n    distinct(by) {\n        return new StreamImpl(() => ({ set: new Set(), internalState: this.startFn() }), state => {\n            let result;\n            do {\n                result = this.nextFn(state.internalState);\n                if (!result.done) {\n                    const value = by ? by(result.value) : result.value;\n                    if (!state.set.has(value)) {\n                        state.set.add(value);\n                        return result;\n                    }\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    exclude(other, key) {\n        const otherKeySet = new Set();\n        for (const item of other) {\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter(e => {\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n}\nfunction toString(item) {\n    if (typeof item === 'string') {\n        return item;\n    }\n    if (typeof item === 'undefined') {\n        return 'undefined';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof item.toString === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return item.toString();\n    }\n    return Object.prototype.toString.call(item);\n}\nfunction isIterable(obj) {\n    return !!obj && typeof obj[Symbol.iterator] === 'function';\n}\n/**\n * An empty stream of any type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const EMPTY_STREAM = new StreamImpl(() => undefined, () => DONE_RESULT);\n/**\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\n */\nexport const DONE_RESULT = Object.freeze({ done: true, value: undefined });\n/**\n * Create a stream from one or more iterables or array-likes.\n */\nexport function stream(...collections) {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof StreamImpl) {\n            return collection;\n        }\n        if (isIterable(collection)) {\n            return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());\n        }\n        if (typeof collection.length === 'number') {\n            return new StreamImpl(() => ({ index: 0 }), (state) => {\n                if (state.index < collection.length) {\n                    return { done: false, value: collection[state.index++] };\n                }\n                else {\n                    return DONE_RESULT;\n                }\n            });\n        }\n    }\n    if (collections.length > 1) {\n        return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (!next.done) {\n                        return next;\n                    }\n                    state.iterator = undefined;\n                }\n                if (state.array) {\n                    if (state.arrIndex < state.array.length) {\n                        return { done: false, value: state.array[state.arrIndex++] };\n                    }\n                    state.array = undefined;\n                    state.arrIndex = 0;\n                }\n                if (state.collIndex < collections.length) {\n                    const collection = collections[state.collIndex++];\n                    if (isIterable(collection)) {\n                        state.iterator = collection[Symbol.iterator]();\n                    }\n                    else if (collection && typeof collection.length === 'number') {\n                        state.array = collection;\n                    }\n                }\n            } while (state.iterator || state.array || state.collIndex < collections.length);\n            return DONE_RESULT;\n        });\n    }\n    return EMPTY_STREAM;\n}\n/**\n * The default implementation of `TreeStream` takes a root element and a function that computes the\n * children of its argument. Whether the root node included in the stream is controlled with the\n * `includeRoot` option, which defaults to `false`.\n */\nexport class TreeStreamImpl extends StreamImpl {\n    constructor(root, children, options) {\n        super(() => ({\n            iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n            pruned: false\n        }), state => {\n            if (state.pruned) {\n                state.iterators.pop();\n                state.pruned = false;\n            }\n            while (state.iterators.length > 0) {\n                const iterator = state.iterators[state.iterators.length - 1];\n                const next = iterator.next();\n                if (next.done) {\n                    state.iterators.pop();\n                }\n                else {\n                    state.iterators.push(children(next.value)[Symbol.iterator]());\n                    return next;\n                }\n            }\n            return DONE_RESULT;\n        });\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            prune: () => {\n                iterator.state.pruned = true;\n            },\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n}\n/**\n * A set of utility functions that reduce a stream to a single value.\n */\nexport var Reduction;\n(function (Reduction) {\n    /**\n     * Compute the sum of a number stream.\n     */\n    function sum(stream) {\n        return stream.reduce((a, b) => a + b, 0);\n    }\n    Reduction.sum = sum;\n    /**\n     * Compute the product of a number stream.\n     */\n    function product(stream) {\n        return stream.reduce((a, b) => a * b, 0);\n    }\n    Reduction.product = product;\n    /**\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function min(stream) {\n        return stream.reduce((a, b) => Math.min(a, b));\n    }\n    Reduction.min = min;\n    /**\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function max(stream) {\n        return stream.reduce((a, b) => Math.max(a, b));\n    }\n    Reduction.max = max;\n})(Reduction || (Reduction = {}));\n//# sourceMappingURL=stream.js.map","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nexport default hasUnicode;\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class EmptyFileSystemProvider {\n    readFile() {\n        throw new Error('No file system is available.');\n    }\n    async readDirectory() {\n        return [];\n    }\n}\nexport const EmptyFileSystem = {\n    fileSystemProvider: () => new EmptyFileSystemProvider()\n};\n//# sourceMappingURL=file-system-provider.js.map","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  MermaidGeneratedSharedModule,\n  PieGeneratedModule,\n  __name\n} from \"./chunk-FPAJGGOC.mjs\";\n\n// src/language/pie/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/pie/tokenBuilder.ts\nvar PieTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PieTokenBuilder\");\n  }\n  constructor() {\n    super([\"pie\", \"showData\"]);\n  }\n};\n\n// src/language/pie/valueConverter.ts\nvar PieValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"PieValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name !== \"PIE_SECTION_LABEL\") {\n      return void 0;\n    }\n    return input.replace(/\"/g, \"\").trim();\n  }\n};\n\n// src/language/pie/module.ts\nvar PieModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PieTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new PieValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPieServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Pie = inject(\n    createDefaultCoreModule({ shared }),\n    PieGeneratedModule,\n    PieModule\n  );\n  shared.ServiceRegistry.register(Pie);\n  return { shared, Pie };\n}\n__name(createPieServices, \"createPieServices\");\n\nexport {\n  PieModule,\n  createPieServices\n};\n","import baseFindIndex from './_baseFindIndex.js';\nimport baseIteratee from './_baseIteratee.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nexport default findIndex;\n","import createFind from './_createFind.js';\nimport findIndex from './findIndex.js';\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nexport default find;\n","import baseIteratee from './_baseIteratee.js';\nimport isArrayLike from './isArrayLike.js';\nimport keys from './keys.js';\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nexport default createFind;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports.default = RAL;\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  MermaidGeneratedSharedModule,\n  TreemapGeneratedModule,\n  __name\n} from \"./chunk-FPAJGGOC.mjs\";\n\n// src/language/treemap/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/treemap/tokenBuilder.ts\nvar TreemapTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"TreemapTokenBuilder\");\n  }\n  constructor() {\n    super([\"treemap\"]);\n  }\n};\n\n// src/language/treemap/valueConverter.ts\nvar classDefRegex = /classDef\\s+([A-Z_a-z]\\w+)(?:\\s+([^\\n\\r;]*))?;?/;\nvar TreemapValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"TreemapValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name === \"NUMBER2\") {\n      return parseFloat(input.replace(/,/g, \"\"));\n    } else if (rule.name === \"SEPARATOR\") {\n      return input.substring(1, input.length - 1);\n    } else if (rule.name === \"STRING2\") {\n      return input.substring(1, input.length - 1);\n    } else if (rule.name === \"INDENTATION\") {\n      return input.length;\n    } else if (rule.name === \"ClassDef\") {\n      if (typeof input !== \"string\") {\n        return input;\n      }\n      const match = classDefRegex.exec(input);\n      if (match) {\n        return {\n          $type: \"ClassDefStatement\",\n          className: match[1],\n          styleText: match[2] || void 0\n        };\n      }\n    }\n    return void 0;\n  }\n};\n\n// src/language/treemap/treemap-validator.ts\nfunction registerValidationChecks(services) {\n  const validator = services.validation.TreemapValidator;\n  const registry = services.validation.ValidationRegistry;\n  if (registry) {\n    const checks = {\n      Treemap: validator.checkSingleRoot.bind(validator)\n      // Remove unused validation for TreemapRow\n    };\n    registry.register(checks, validator);\n  }\n}\n__name(registerValidationChecks, \"registerValidationChecks\");\nvar TreemapValidator = class {\n  static {\n    __name(this, \"TreemapValidator\");\n  }\n  /**\n   * Validates that a treemap has only one root node.\n   * A root node is defined as a node that has no indentation.\n   */\n  checkSingleRoot(doc, accept) {\n    let rootNodeIndentation;\n    for (const row of doc.TreemapRows) {\n      if (!row.item) {\n        continue;\n      }\n      if (rootNodeIndentation === void 0 && // Check if this is a root node (no indentation)\n      row.indent === void 0) {\n        rootNodeIndentation = 0;\n      } else if (row.indent === void 0) {\n        accept(\"error\", \"Multiple root nodes are not allowed in a treemap.\", {\n          node: row,\n          property: \"item\"\n        });\n      } else if (rootNodeIndentation !== void 0 && rootNodeIndentation >= parseInt(row.indent, 10)) {\n        accept(\"error\", \"Multiple root nodes are not allowed in a treemap.\", {\n          node: row,\n          property: \"item\"\n        });\n      }\n    }\n  }\n};\n\n// src/language/treemap/module.ts\nvar TreemapModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new TreemapTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new TreemapValueConverter(), \"ValueConverter\")\n  },\n  validation: {\n    TreemapValidator: /* @__PURE__ */ __name(() => new TreemapValidator(), \"TreemapValidator\")\n  }\n};\nfunction createTreemapServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Treemap = inject(\n    createDefaultCoreModule({ shared }),\n    TreemapGeneratedModule,\n    TreemapModule\n  );\n  shared.ServiceRegistry.register(Treemap);\n  registerValidationChecks(Treemap);\n  return { shared, Treemap };\n}\n__name(createTreemapServices, \"createTreemapServices\");\n\nexport {\n  TreemapModule,\n  createTreemapServices\n};\n","import baseFlatten from './_baseFlatten.js';\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n","// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nexport const VERSION = \"11.0.3\";\n//# sourceMappingURL=version.js.map","// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast) {\n    function FakeConstructor() { }\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast;\n    const fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess();\n    fakeAccess();\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    if (1)\n        return toBecomeFast;\n    // Eval prevents optimization of this method (even though this is dead code)\n    // - https://esbuild.github.io/content-types/#direct-eval\n    /* istanbul ignore next */\n    // tslint:disable-next-line\n    (0, eval)(toBecomeFast);\n}\n//# sourceMappingURL=to-fast-properties.js.map","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nexport default drop;\n","import assignValue from './_assignValue.js';\nimport copyObject from './_copyObject.js';\nimport createAssigner from './_createAssigner.js';\nimport isArrayLike from './isArrayLike.js';\nimport isPrototype from './_isPrototype.js';\nimport keys from './keys.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'c': 3 }\n */\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\n\nexport default assign;\n","import arrayMap from './_arrayMap.js';\nimport baseIteratee from './_baseIteratee.js';\nimport basePickBy from './_basePickBy.js';\nimport getAllKeysIn from './_getAllKeysIn.js';\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { 'a': 1, 'c': 3 }\n */\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee(predicate);\n  return basePickBy(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\n\nexport default pickBy;\n","import baseIsRegExp from './_baseIsRegExp.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nexport default isRegExp;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nexport default baseIsRegExp;\n","import { assign, forEach, isRegExp, isString, map, pickBy } from \"lodash-es\";\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nexport class AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(_definition) {\n        this._definition = _definition;\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        forEach(this.definition, (prod) => {\n            prod.accept(visitor);\n        });\n    }\n}\nexport class NonTerminal extends AbstractProduction {\n    constructor(options) {\n        super([]);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    set definition(definition) {\n        // immutable\n    }\n    get definition() {\n        if (this.referencedRule !== undefined) {\n            return this.referencedRule.definition;\n        }\n        return [];\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n}\nexport class Rule extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.orgText = \"\";\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternative extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.ignoreAmbiguities = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Option extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Repetition extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternation extends AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        this.ignoreAmbiguities = false;\n        this.hasPredicates = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Terminal {\n    constructor(options) {\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    accept(visitor) {\n        visitor.visit(this);\n    }\n}\nexport function serializeGrammar(topRules) {\n    return map(topRules, serializeProduction);\n}\nexport function serializeProduction(node) {\n    function convertDefinition(definition) {\n        return map(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n        const serializedNonTerminal = {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n    }\n    else if (node instanceof Alternative) {\n        return {\n            type: \"Alternative\",\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: \"Option\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: \"RepetitionMandatory\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: \"RepetitionMandatoryWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: \"RepetitionWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: \"Repetition\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: \"Alternation\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Terminal) {\n        const serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: tokenLabel(node.terminalType),\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedTerminal.terminalLabel = node.label;\n        }\n        const pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = isRegExp(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: \"Rule\",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition),\n        };\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=model.js.map","import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport class GAstVisitor {\n    visit(node) {\n        const nodeAny = node;\n        switch (nodeAny.constructor) {\n            case NonTerminal:\n                return this.visitNonTerminal(nodeAny);\n            case Alternative:\n                return this.visitAlternative(nodeAny);\n            case Option:\n                return this.visitOption(nodeAny);\n            case RepetitionMandatory:\n                return this.visitRepetitionMandatory(nodeAny);\n            case RepetitionMandatoryWithSeparator:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case RepetitionWithSeparator:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case Repetition:\n                return this.visitRepetition(nodeAny);\n            case Alternation:\n                return this.visitAlternation(nodeAny);\n            case Terminal:\n                return this.visitTerminal(nodeAny);\n            case Rule:\n                return this.visitRule(nodeAny);\n            /* c8 ignore next 2 */\n            default:\n                throw Error(\"non exhaustive match\");\n        }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) { }\n    /* c8 ignore next */\n    visitAlternative(node) { }\n    /* c8 ignore next */\n    visitOption(node) { }\n    /* c8 ignore next */\n    visitRepetition(node) { }\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) { }\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) { }\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) { }\n    /* c8 ignore next */\n    visitAlternation(node) { }\n    /* c8 ignore next */\n    visitTerminal(node) { }\n    /* c8 ignore next */\n    visitRule(node) { }\n}\n//# sourceMappingURL=visitor.js.map","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nexport default baseSome;\n","import arraySome from './_arraySome.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseSome from './_baseSome.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default some;\n","import baseIndexOf from './_baseIndexOf.js';\nimport isArrayLike from './isArrayLike.js';\nimport isString from './isString.js';\nimport toInteger from './toInteger.js';\nimport values from './values.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\nexport default includes;\n","/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport default arrayEvery;\n","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nexport default baseEvery;\n","import arrayEvery from './_arrayEvery.js';\nimport baseEvery from './_baseEvery.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default every;\n","import { every, includes, some } from \"lodash-es\";\nimport { AbstractProduction, Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport function isSequenceProd(prod) {\n    return (prod instanceof Alternative ||\n        prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionMandatory ||\n        prod instanceof RepetitionMandatoryWithSeparator ||\n        prod instanceof RepetitionWithSeparator ||\n        prod instanceof Terminal ||\n        prod instanceof Rule);\n}\nexport function isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional = prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionWithSeparator;\n    if (isDirectlyOptional) {\n        return true;\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n        // for OR its enough for just one of the alternatives to be optional\n        return some(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n        // avoiding stack overflow due to infinite recursion\n        return false;\n    }\n    else if (prod instanceof AbstractProduction) {\n        if (prod instanceof NonTerminal) {\n            alreadyVisited.push(prod);\n        }\n        return every(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else {\n        return false;\n    }\n}\nexport function isBranchingProd(prod) {\n    return prod instanceof Alternation;\n}\nexport function getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=helpers.js.map","import { drop, forEach } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport class RestWalker {\n    walk(prod, prevRest = []) {\n        forEach(prod.definition, (subProd, index) => {\n            const currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternative) {\n                this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    }\n    walkTerminal(terminal, currRest, prevRest) { }\n    walkProdRef(refProd, currRest, prevRest) { }\n    walkFlat(flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        const fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        const fullManyRest = [\n            new Option({ definition: manyProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    }\n    walkOr(orProd, currRest, prevRest) {\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        const fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, (alt) => {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            const prodWrapper = new Alternative({ definition: [alt] });\n            this.walk(prodWrapper, fullOrRest);\n        });\n    }\n}\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n        new Option({\n            definition: [\n                new Terminal({ terminalType: repSepProd.separator }),\n            ].concat(repSepProd.definition),\n        }),\n    ];\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map","import baseUniq from './_baseUniq.js';\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nexport default uniq;\n","import { flatten, map, uniq } from \"lodash-es\";\nimport { isBranchingProd, isOptionalProd, isSequenceProd, NonTerminal, Terminal, } from \"@chevrotain/gast\";\nexport function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function firstForSequence(prod) {\n    let firstSet = [];\n    const seq = prod.definition;\n    let nextSubProdIdx = 0;\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    let currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return uniq(firstSet);\n}\nexport function firstForBranching(prod) {\n    const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n        return first(innerProd);\n    });\n    return uniq(flatten(allAlternativesFirsts));\n}\nexport function firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map","// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\";\n//# sourceMappingURL=constants.js.map","import { RestWalker } from \"./rest.js\";\nimport { first } from \"./first.js\";\nimport { assign, forEach } from \"lodash-es\";\nimport { IN } from \"../constants.js\";\nimport { Alternative } from \"@chevrotain/gast\";\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n        super();\n        this.topProd = topProd;\n        this.follows = {};\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.follows;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        const fullRest = currRest.concat(prevRest);\n        const restProd = new Alternative({ definition: fullRest });\n        const t_in_topProd_follows = first(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    }\n}\nexport function computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {};\n    forEach(topProductions, (topProd) => {\n        const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        assign(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nexport function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + IN;\n}\nexport function buildInProdFollowPrefix(terminal) {\n    const terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + IN;\n}\n//# sourceMappingURL=follow.js.map","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nexport default negate;\n","import arrayFilter from './_arrayFilter.js';\nimport baseFilter from './_baseFilter.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport negate from './negate.js';\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.filter\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * _.reject(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.reject(users, { 'age': 40, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.reject(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.reject(users, 'active');\n * // => objects for ['barney']\n */\nfunction reject(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, negate(baseIteratee(predicate, 3)));\n}\n\nexport default reject;\n","import baseIndexOf from './_baseIndexOf.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nexport default indexOf;\n","import baseDifference from './_baseDifference.js';\nimport baseFlatten from './_baseFlatten.js';\nimport baseRest from './_baseRest.js';\nimport isArrayLikeObject from './isArrayLikeObject.js';\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nexport default difference;\n","import SetCache from './_SetCache.js';\nimport arrayIncludes from './_arrayIncludes.js';\nimport arrayIncludesWith from './_arrayIncludesWith.js';\nimport arrayMap from './_arrayMap.js';\nimport baseUnary from './_baseUnary.js';\nimport cacheHas from './_cacheHas.js';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseDifference;\n","/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default compact;\n","/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nexport default head;\n","export function PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n        console.error(`Error: ${msg}`);\n    }\n}\nexport function PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n        // TODO: modify docs accordingly\n        console.warn(`Warning: ${msg}`);\n    }\n}\n//# sourceMappingURL=print.js.map","import { RegExpParser, } from \"@chevrotain/regexp-to-ast\";\nlet regExpAstCache = {};\nconst regExpParser = new RegExpParser();\nexport function getRegExpAst(regExp) {\n    const regExpStr = regExp.toString();\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n    }\n    else {\n        const regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\nexport function clearRegExpParserCache() {\n    regExpAstCache = {};\n}\n//# sourceMappingURL=reg_exp_parser.js.map","import { BaseRegExpVisitor, } from \"@chevrotain/regexp-to-ast\";\nimport { every, find, forEach, includes, isArray, values } from \"lodash-es\";\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer.js\";\nconst complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport const failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n        const ast = getRegExpAst(regExp);\n        const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                PRINT_WARNING(`${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            let msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            PRINT_ERROR(`${failedOptimizationPrefixMsg}\\n` +\n                `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n                `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n                \"\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (let i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            const terms = ast.value;\n            for (let i = 0; i < terms.length; i++) {\n                const term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                const atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        forEach(atom.value, (code) => {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                const range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= minOptimizationVal) {\n                                        const minUnOptVal = range.from >= minOptimizationVal\n                                            ? range.from\n                                            : minOptimizationVal;\n                                        const maxUnOptVal = range.to;\n                                        const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                                        const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                                        for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code);\n    const upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        const lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return find(setNode.value, (codeOrRange) => {\n        if (typeof codeOrRange === \"number\") {\n            return includes(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            const range = codeOrRange;\n            return (find(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    const quantifier = ast.quantifier;\n    if (quantifier && quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return isArray(ast.value)\n        ? every(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nclass CharCodeFinder extends BaseRegExpVisitor {\n    constructor(targetCharCodes) {\n        super();\n        this.targetCharCodes = targetCharCodes;\n        this.found = false;\n    }\n    visitChildren(node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        super.visitChildren(node);\n    }\n    visitCharacter(node) {\n        if (includes(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    }\n    visitSet(node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    }\n}\nexport function canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        const ast = getRegExpAst(pattern);\n        const charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return (find(pattern, (char) => {\n            return includes(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\n//# sourceMappingURL=reg_exp.js.map","import { BaseRegExpVisitor } from \"@chevrotain/regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType, } from \"./lexer_public.js\";\nimport { compact, defaults, difference, filter, find, first, flatten, forEach, has, includes, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, reduce, reject, values, } from \"lodash-es\";\nimport { PRINT_ERROR } from \"@chevrotain/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices, } from \"./reg_exp.js\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\nconst PATTERN = \"PATTERN\";\nexport const DEFAULT_MODE = \"defaultMode\";\nexport const MODES = \"modes\";\nexport let SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n    SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n    SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: (msg, action) => action(),\n    });\n    const tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n        initCharCodeToOptimizedIndexMap();\n    });\n    let onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", () => {\n        onlyRelevantTypes = reject(tokenTypes, (currType) => {\n            return currType[PATTERN] === Lexer.NA;\n        });\n    });\n    let hasCustom = false;\n    let allTransformedPatterns;\n    tracer(\"Transform Patterns\", () => {\n        hasCustom = false;\n        allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n            const currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if (isRegExp(currPattern)) {\n                const regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\" &&\n                    !currPattern.ignoreCase) {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !includes([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\",\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if (isFunction(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (typeof currPattern === \"object\") {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    const wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    let patternIdxToType;\n    let patternIdxToGroup;\n    let patternIdxToLongerAltIdxArr;\n    let patternIdxToPushMode;\n    let patternIdxToPopMode;\n    tracer(\"misc mapping\", () => {\n        patternIdxToType = map(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);\n        patternIdxToGroup = map(onlyRelevantTypes, (clazz) => {\n            const groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if (isString(groupName)) {\n                return groupName;\n            }\n            else if (isUndefined(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) => {\n            const longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                const longerAltIdxArr = isArray(longerAltType)\n                    ? map(longerAltType, (type) => indexOf(onlyRelevantTypes, type))\n                    : [indexOf(onlyRelevantTypes, longerAltType)];\n                return longerAltIdxArr;\n            }\n        });\n        patternIdxToPushMode = map(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);\n        patternIdxToPopMode = map(onlyRelevantTypes, (clazz) => has(clazz, \"POP_MODE\"));\n    });\n    let patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", () => {\n        const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false);\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    return !!tokType.LINE_BREAKS;\n                }\n                else {\n                    return (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n                        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN));\n                }\n            });\n        }\n    });\n    let patternIdxToIsCustom;\n    let patternIdxToShort;\n    let emptyGroups;\n    let patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", () => {\n        patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n        emptyGroups = reduce(onlyRelevantTypes, (acc, clazz) => {\n            const groupName = clazz.GROUP;\n            if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdxArr[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx],\n            };\n        });\n    });\n    let canBeOptimized = true;\n    let charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", () => {\n            charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, (result, currTokType, idx) => {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    const charCode = currTokType.PATTERN.charCodeAt(0);\n                    const optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if (isArray(currTokType.START_CHARS_HINT)) {\n                    let lastOptimizedIdx;\n                    forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n                        const charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        /* istanbul ignore else */\n                        // - Difficult to check this scenario effects as it is only a performance\n                        //   optimization that does not change correctness\n                        if (lastOptimizedIdx !== currOptimizedIdx) {\n                            lastOptimizedIdx = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if (isRegExp(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                                `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if (isEmpty(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        forEach(optimizedCodes, (code) => {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                            `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized,\n    };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n    let errors = [];\n    const missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    const invalidResult = findInvalidPatterns(missingResult.valid);\n    const validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    let errors = [];\n    const withRegExpPatterns = filter(tokenTypes, (currTokType) => isRegExp(currTokType[PATTERN]));\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nexport function findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n        return !has(currType, PATTERN);\n    });\n    const errors = map(tokenTypesWithMissingPattern, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors, valid };\n}\nexport function findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return (!isRegExp(pattern) &&\n            !isFunction(pattern) &&\n            !has(pattern, \"exec\") &&\n            !isString(pattern));\n    });\n    const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors, valid };\n}\nconst end_of_input = /[^\\\\][$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitEndAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    const errors = map(invalidRegex, (currType) => {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        return pattern.test(\"\");\n    });\n    const errors = map(matchesEmptyString, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitStartAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    const errors = map(invalidRegex, (currType) => {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = filter(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n    });\n    const errors = map(invalidFlags, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(tokenTypes) {\n    const found = [];\n    let identicalPatterns = map(tokenTypes, (outerType) => {\n        return reduce(tokenTypes, (result, innerType) => {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !includes(found, innerType) &&\n                innerType.PATTERN !== Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = compact(identicalPatterns);\n    const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n        return currIdenticalSet.length > 1;\n    });\n    const errors = map(duplicatePatterns, (setOfIdentical) => {\n        const tokenTypeNames = map(setOfIdentical, (currType) => {\n            return currType.name;\n        });\n        const dupPatternSrc = first(setOfIdentical).PATTERN;\n        return {\n            message: `The same RegExp pattern ->${dupPatternSrc}<-` +\n                `has been used in all of the following Token Types: ${tokenTypeNames.join(\", \")} <-`,\n            type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical,\n        };\n    });\n    return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n    const invalidTypes = filter(tokenTypes, (clazz) => {\n        if (!has(clazz, \"GROUP\")) {\n            return false;\n        }\n        const group = clazz.GROUP;\n        return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n    });\n    const errors = map(invalidTypes, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = filter(tokenTypes, (clazz) => {\n        return (clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE));\n    });\n    const errors = map(invalidModes, (tokType) => {\n        const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n            `which does not exist`;\n        return {\n            message: msg,\n            type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType],\n        };\n    });\n    return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n    const errors = [];\n    const canBeTested = reduce(tokenTypes, (result, tokType, idx) => {\n        const pattern = tokType.PATTERN;\n        if (pattern === Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n            result.push({ str: pattern, idx, tokenType: tokType });\n        }\n        else if (isRegExp(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    forEach(tokenTypes, (tokType, testIdx) => {\n        forEach(canBeTested, ({ str, idx, tokenType }) => {\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                const msg = `Token: ->${tokenType.name}<- can never be matched.\\n` +\n                    `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n                    `in the lexer's definition.\\n` +\n                    `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n                errors.push({\n                    message: msg,\n                    type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType],\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        const regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if (isFunction(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if (has(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    const metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\",\n    ];\n    return (find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined);\n}\nexport function addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`^(?:${pattern.source})`, flags);\n}\nexport function addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`${pattern.source}`, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = [];\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n        });\n    }\n    if (!has(lexerDefinition, MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                MODES +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n        });\n    }\n    if (has(lexerDefinition, MODES) &&\n        has(lexerDefinition, DEFAULT_MODE) &&\n        !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n                `which does not exist\\n`,\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n        });\n    }\n    if (has(lexerDefinition, MODES)) {\n        forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n            forEach(currModeValue, (currTokType, currIdx) => {\n                if (isUndefined(currTokType)) {\n                    errors.push({\n                        message: `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n                            `<${currModeName}> at index: <${currIdx}>\\n`,\n                        type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n                    });\n                }\n                else if (has(currTokType, \"LONGER_ALT\")) {\n                    const longerAlt = isArray(currTokType.LONGER_ALT)\n                        ? currTokType.LONGER_ALT\n                        : [currTokType.LONGER_ALT];\n                    forEach(longerAlt, (currLongerAlt) => {\n                        if (!isUndefined(currLongerAlt) &&\n                            !includes(currModeValue, currLongerAlt)) {\n                            errors.push({\n                                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n                            });\n                        }\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = [];\n    let hasAnyLineBreak = false;\n    const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n    const concreteTokenTypes = reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);\n    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        forEach(concreteTokenTypes, (tokType) => {\n            const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                const message = buildLineBreakIssueMessage(tokType, currIssue);\n                const warningDescriptor = {\n                    message,\n                    type: currIssue.issue,\n                    tokenType: tokType,\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n        });\n    }\n    return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {};\n    const groupKeys = keys(emptyGroups);\n    forEach(groupKeys, (currKey) => {\n        const currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if (isArray(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        return false;\n    }\n    else if (isFunction(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if (has(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if (isString(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        const len = text.length;\n        for (let i = this.lastIndex; i < len; i++) {\n            const c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0,\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if (isRegExp(tokType.PATTERN)) {\n            try {\n                // TODO: why is the casting suddenly needed?\n                canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message,\n                };\n            }\n            return false;\n        }\n        else if (isString(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nexport function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            `\\t Root cause: ${details.errMsg}.\\n` +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    const charCodes = map(charsOrCodes, (numOrString) => {\n        if (isString(numOrString)) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nexport const minOptimizationVal = 256;\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap = [];\nexport function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (let i = 0; i < 65536; i++) {\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map","export function timer(func) {\n    const start = new Date().getTime();\n    const val = func();\n    const end = new Date().getTime();\n    const total = end - start;\n    return { time: total, value: val };\n}\n//# sourceMappingURL=timer.js.map","import { clone, compact, difference, flatten, forEach, has, includes, isArray, isEmpty, map, } from \"lodash-es\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport let tokenShortNameIdx = 1;\nexport const tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    const tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    forEach(tokenTypesAndParents, (tokType) => {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexport function expandCategories(tokenTypes) {\n    let result = clone(tokenTypes);\n    let categories = tokenTypes;\n    let searching = true;\n    while (searching) {\n        categories = compact(flatten(map(categories, (currTokType) => currTokType.CATEGORIES)));\n        const newCategories = difference(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !isArray(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, (val, key) => {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, (pathNode) => {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    forEach(nextNode.CATEGORIES, (nextCategory) => {\n        const newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!includes(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexport function hasShortKeyProperty(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n    return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map","export const defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage(token) {\n        return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n    },\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return (`unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` + ` skipped ${length} characters.`);\n    },\n};\n//# sourceMappingURL=lexer_errors_public.js.map","import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns, } from \"./lexer.js\";\nimport { assign, clone, forEach, identity, isArray, isEmpty, isUndefined, keys, last, map, noop, reduce, reject, } from \"lodash-es\";\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\";\nimport { augmentTokenTypes } from \"./tokens.js\";\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public.js\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser.js\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nconst DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true,\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nexport class Lexer {\n    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        // Duplicated from the parser's perf trace trait to allow future extraction\n        // of the lexer to a separate package.\n        this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n            // No need to optimize this using NOOP pattern because\n            // It is not called in a hot spot...\n            if (this.traceInitPerf === true) {\n                this.traceInitIndent++;\n                const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    console.log(`${indent}--> <${phaseDesc}>`);\n                }\n                const { time, value } = timer(phaseImpl);\n                /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n                const traceMethod = time > 10 ? console.warn : console.log;\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n                }\n                this.traceInitIndent--;\n                return value;\n            }\n            else {\n                return phaseImpl();\n            }\n        };\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = assign({}, DEFAULT_LEXER_CONFIG, config);\n        const traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", () => {\n            let actualDefinition;\n            let hasOnlySingleMode = true;\n            this.TRACE_INIT(\"Lexer Config handling\", () => {\n                if (this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n                this.trackEndLines = /full/i.test(this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if (isArray(lexerDefinition)) {\n                    actualDefinition = {\n                        modes: { defaultMode: clone(lexerDefinition) },\n                        defaultMode: DEFAULT_MODE,\n                    };\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = clone(lexerDefinition);\n                }\n            });\n            if (this.config.skipValidations === false) {\n                this.TRACE_INIT(\"performRuntimeChecks\", () => {\n                    this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n                this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n                    this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n                actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) => isUndefined(currTokType));\n            });\n            const allModeNames = keys(actualDefinition.modes);\n            forEach(actualDefinition.modes, (currModDef, currModName) => {\n                this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n                    this.modes.push(currModName);\n                    if (this.config.skipValidations === false) {\n                        this.TRACE_INIT(`validatePatterns`, () => {\n                            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if (isEmpty(this.lexerDefinitionErrors)) {\n                        augmentTokenTypes(currModDef);\n                        let currAnalyzeResult;\n                        this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                            currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: this.TRACE_INIT,\n                            });\n                        });\n                        this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult.patternIdxToConfig;\n                        this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult.charCodeToPatternIdxToConfig;\n                        this.emptyGroups = assign({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n                        this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n                        this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult.canBeOptimized;\n                    }\n                });\n            });\n            this.defaultMode = actualDefinition.defaultMode;\n            if (!isEmpty(this.lexerDefinitionErrors) &&\n                !this.config.deferDefinitionErrorsHandling) {\n                const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n                    return error.message;\n                });\n                const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n                PRINT_WARNING(warningDescriptor.message);\n            });\n            this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (SUPPORT_STICKY) {\n                    this.chopInput = identity;\n                    this.match = this.matchWithTest;\n                }\n                else {\n                    this.updateLastIndex = noop;\n                    this.match = this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    this.handleModes = noop;\n                }\n                if (this.trackStartLines === false) {\n                    this.computeNewColumn = identity;\n                }\n                if (this.trackEndLines === false) {\n                    this.updateTokenEndLineColumnLocation = noop;\n                }\n                if (/full/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createFullToken;\n                }\n                else if (/onlyStart/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`);\n                }\n                if (this.hasCustom) {\n                    this.addToken = this.addTokenUsingPush;\n                    this.handlePayload = this.handlePayloadWithCustom;\n                }\n                else {\n                    this.addToken = this.addTokenUsingMemberAccess;\n                    this.handlePayload = this.handlePayloadNoCustom;\n                }\n            });\n            this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n                const unOptimizedModes = reduce(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n                    throw Error(`Lexer Modes: < ${unOptimizedModes.join(\", \")} > cannot be optimized.\\n` +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n                clearRegExpParserCache();\n            });\n            this.TRACE_INIT(\"toFastProperties\", () => {\n                toFastProperties(this);\n            });\n        });\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n        if (!isEmpty(this.lexerDefinitionErrors)) {\n            const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n                return error.message;\n            });\n            const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        return this.tokenizeInternal(text, initialMode);\n    }\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    tokenizeInternal(text, initialMode) {\n        let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        const orgText = text;\n        const orgLength = orgText.length;\n        let offset = 0;\n        let matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        const guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        const matchedTokens = new Array(guessedNumberOfTokens);\n        const errors = [];\n        let line = this.trackStartLines ? 1 : undefined;\n        let column = this.trackStartLines ? 1 : undefined;\n        const groups = cloneEmptyGroups(this.emptyGroups);\n        const trackLines = this.trackStartLines;\n        const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        let currModePatternsLength = 0;\n        let patternIdxToConfig = [];\n        let currCharCodeToPatternIdxToConfig = [];\n        const modeStack = [];\n        const emptyArray = [];\n        Object.freeze(emptyArray);\n        let getPossiblePatterns;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        const pop_mode = (popToken) => {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine,\n                    column: popToken.startColumn,\n                    length: popToken.image.length,\n                    message: msg,\n                });\n            }\n            else {\n                modeStack.pop();\n                const newMode = last(modeStack);\n                patternIdxToConfig = this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig =\n                    this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig =\n                this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        let currConfig;\n        const recoveryEnabled = this.config.recoveryEnabled;\n        while (offset < orgLength) {\n            matchedImage = null;\n            const nextCharCode = orgText.charCodeAt(offset);\n            const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            const chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                const currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                const singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAlt = currConfig.longerAlt;\n                    if (longerAlt !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        const longerAltLength = longerAlt.length;\n                        for (k = 0; k < longerAltLength; k++) {\n                            const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                            const longerAltPattern = longerAltConfig.pattern;\n                            altPayload = null;\n                            // single Char can never be a longer alt so no need to test it.\n                            // manually in-lined because > 600 chars won't be in-lined in V8\n                            if (longerAltConfig.isCustom === true) {\n                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                                if (match !== null) {\n                                    matchAltImage = match[0];\n                                    if (match.payload !== undefined) {\n                                        altPayload = match.payload;\n                                    }\n                                }\n                                else {\n                                    matchAltImage = null;\n                                }\n                            }\n                            else {\n                                this.updateLastIndex(longerAltPattern, offset);\n                                matchAltImage = this.match(longerAltPattern, text, offset);\n                            }\n                            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                                matchedImage = matchAltImage;\n                                payload = altPayload;\n                                currConfig = longerAltConfig;\n                                // Exit the loop early after matching one of the longer alternatives\n                                // The first matched alternative takes precedence\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    let numOfLTsInMatch = 0;\n                    let foundTerminator;\n                    let lastLTEndOffset;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                const errorStartOffset = offset;\n                const errorLine = line;\n                const errorColumn = column;\n                let foundResyncPoint = recoveryEnabled === false;\n                while (foundResyncPoint === false && offset < orgLength) {\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        const currConfig = patternIdxToConfig[j];\n                        const currPattern = currConfig.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        const singleCharCode = currConfig.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                column = this.computeNewColumn(column, errLength);\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg,\n                });\n                if (recoveryEnabled === false) {\n                    break;\n                }\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors,\n        };\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            const pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    }\n    chopInput(text, length) {\n        return text.substring(length);\n    }\n    updateLastIndex(regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        let lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image,\n            startOffset,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image,\n            startOffset,\n            startLine,\n            startColumn,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image,\n            startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine,\n            endLine: startLine,\n            startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    }\n    handlePayloadNoCustom(token, payload) { }\n    handlePayloadWithCustom(token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    }\n    matchWithTest(pattern, text, offset) {\n        const found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    }\n    matchWithExec(pattern, text) {\n        const regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : null;\n    }\n}\nLexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\nLexer.NA = /NOT_APPLICABLE/;\n//# sourceMappingURL=lexer_public.js.map","import { has, isString, isUndefined } from \"lodash-es\";\nimport { Lexer } from \"./lexer_public.js\";\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens.js\";\nexport function tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\nexport function tokenName(tokType) {\n    return tokType.name;\n}\nexport function hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nconst PARENT = \"parent\";\nconst CATEGORIES = \"categories\";\nconst LABEL = \"label\";\nconst GROUP = \"group\";\nconst PUSH_MODE = \"push_mode\";\nconst POP_MODE = \"pop_mode\";\nconst LONGER_ALT = \"longer_alt\";\nconst LINE_BREAKS = \"line_breaks\";\nconst START_CHARS_HINT = \"start_chars_hint\";\nexport function createToken(config) {\n    return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n    const pattern = config.pattern;\n    const tokenType = {};\n    tokenType.name = config.name;\n    if (!isUndefined(pattern)) {\n        tokenType.PATTERN = pattern;\n    }\n    if (has(config, PARENT)) {\n        throw (\"The parent property is no longer supported.\\n\" +\n            \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\");\n    }\n    if (has(config, CATEGORIES)) {\n        // casting to ANY as this will be fixed inside `augmentTokenTypes``\n        tokenType.CATEGORIES = config[CATEGORIES];\n    }\n    augmentTokenTypes([tokenType]);\n    if (has(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n    }\n    if (has(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n    }\n    if (has(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n    }\n    if (has(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n    }\n    if (has(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n    }\n    if (has(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n    }\n    if (has(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n    }\n    return tokenType;\n}\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\nexport function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image,\n        startOffset,\n        endOffset,\n        startLine,\n        endLine,\n        startColumn,\n        endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType,\n    };\n}\nexport function tokenMatcher(token, tokType) {\n    return tokenStructuredMatcher(token, tokType);\n}\n//# sourceMappingURL=tokens_public.js.map","import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport { getProductionDslName, NonTerminal, Rule, Terminal, } from \"@chevrotain/gast\";\nexport const defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n        const hasLabel = hasTokenLabel(expected);\n        const expectedMsg = hasLabel\n            ? `--> ${tokenLabel(expected)} <--`\n            : `token of type --> ${expected.name} <--`;\n        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n        return msg;\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n            const nextValidTokenSequences = map(allLookAheadPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\", \")}]`);\n            const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n            const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\"\\n\")}`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const nextValidTokenSequences = map(expectedIterationPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\",\")}]`);\n            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n                `<${nextValidTokenSequences.join(\" ,\")}>`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n};\nObject.freeze(defaultParserErrorProvider);\nexport const defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    },\n};\nexport const defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        const topLevelName = topLevelRule.name;\n        const duplicateProd = first(duplicateProds);\n        const index = duplicateProd.idx;\n        const dslName = getProductionDslName(duplicateProd);\n        const extraArgument = getExtraProductionArgument(duplicateProd);\n        const hasExplicitIndex = index > 0;\n        let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError(rule) {\n        const errMsg = `Namespace conflict found in grammar.\\n` +\n            `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n            `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n            `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n            `and Non-Terminal names start with a lower case letter.`;\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\\n` +\n            `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n            `For Further details.`;\n        return errMsg;\n    },\n    buildAlternationAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}>` +\n            ` inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n        currMessage =\n            currMessage +\n                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n                `For Further details.`;\n        return currMessage;\n    },\n    buildEmptyRepetitionError(options) {\n        let dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n            `This could lead to an infinite loop.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError(options) {\n        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n            ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n            `Only the last alternative may be an empty alternative.`;\n        return errMsg;\n    },\n    buildTooManyAlternativesError(options) {\n        const errMsg = `An Alternation cannot have more than 256 alternatives:\\n` +\n            `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`;\n        return errMsg;\n    },\n    buildLeftRecursionError(options) {\n        const ruleName = options.topLevelRule.name;\n        const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name);\n        const leftRecursivePath = `${ruleName} --> ${pathNames\n            .concat([ruleName])\n            .join(\" --> \")}`;\n        const errMsg = `Left Recursion found in grammar.\\n` +\n            `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n            `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n            ` To fix this refactor your grammar to remove the left recursion.\\n` +\n            `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError(options) {\n        let ruleName;\n        if (options.topLevelRule instanceof Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n        return errMsg;\n    },\n};\n//# sourceMappingURL=errors_public.js.map","import { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { forEach, values } from \"lodash-es\";\nimport { GAstVisitor } from \"@chevrotain/gast\";\nexport function resolveGrammar(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nexport class GastRefResolverVisitor extends GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n        super();\n        this.nameToTopRule = nameToTopRule;\n        this.errMsgProvider = errMsgProvider;\n        this.errors = [];\n    }\n    resolveRefs() {\n        forEach(values(this.nameToTopRule), (prod) => {\n            this.currTopLevel = prod;\n            prod.accept(this);\n        });\n    }\n    visitNonTerminal(node) {\n        const ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName,\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    }\n}\n//# sourceMappingURL=resolver.js.map","/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nexport default arrayAggregator;\n","import baseEach from './_baseEach.js';\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nexport default baseAggregator;\n","import baseAssignValue from './_baseAssignValue.js';\nimport createAggregator from './_createAggregator.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nexport default groupBy;\n","import arrayAggregator from './_arrayAggregator.js';\nimport baseAggregator from './_baseAggregator.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nexport default createAggregator;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nexport default dropRight;\n","import { clone, drop, dropRight, first as _first, forEach, isEmpty, last, } from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nexport class AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n        super();\n        this.topProd = topProd;\n        this.path = path;\n        this.possibleTokTypes = [];\n        this.nextProductionName = \"\";\n        this.nextProductionOccurrence = 0;\n        this.found = false;\n        this.isAtEndOfPath = false;\n    }\n    startWalking() {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    }\n    walk(prod, prevRest = []) {\n        // stop scanning once we found the path\n        if (!this.found) {\n            super.walk(prod, prevRest);\n        }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            const fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    }\n    updateExpectedNext() {\n        // need to consume the Terminal\n        if (isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    }\n}\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n        super(topProd, path);\n        this.path = path;\n        this.nextTerminalName = \"\";\n        this.nextTerminalOccurrence = 0;\n        this.nextTerminalName = this.path.lastTok.name;\n        this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            const fullRest = currRest.concat(prevRest);\n            const restProd = new Alternative({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    }\n}\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n        super();\n        this.topRule = topRule;\n        this.occurrence = occurrence;\n        this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined,\n        };\n    }\n    startWalking() {\n        this.walk(this.topRule);\n        return this.result;\n    }\n}\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            const firstAfterMany = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            super.walkMany(manyProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            const firstAfterManySep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            super.walkManySep(manySepProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n        }\n    }\n}\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            const firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n        }\n    }\n}\nexport function possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = clone(currPath);\n    let result = [];\n    let i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        const prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            const newDef = [\n                new Alternative({ definition: prod.definition }),\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            forEach(prod.definition, (currAlt) => {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if (isEmpty(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i),\n    });\n    return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    let foundCompletePath = false;\n    const tokenVectorLength = tokenVector.length;\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    const result = [];\n    const possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: [],\n    });\n    while (!isEmpty(possiblePaths)) {\n        const currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        const currDef = currPath.def;\n        const currIdx = currPath.idx;\n        const currRuleStack = currPath.ruleStack;\n        const currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (isEmpty(currDef)) {\n            continue;\n        }\n        const prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            const nextPath = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: dropRight(currRuleStack),\n                occurrenceStack: dropRight(currOccurrenceStack),\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                const nextIdx = currIdx + 1;\n                const actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    const nextPath = {\n                        idx: nextIdx,\n                        def: drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack,\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof NonTerminal) {\n            const newRuleStack = clone(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            const newOccurrenceStack = clone(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            const nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            const nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (let i = prod.definition.length - 1; i >= 0; i--) {\n                const currAlt = prod.definition[i];\n                const currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = clone(currRuleStack);\n    newRuleStack.push(topRule.name);\n    const newCurrOccurrenceStack = clone(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack,\n    };\n}\n//# sourceMappingURL=interpreter.js.map","import { every, flatten, forEach, has, isEmpty, map, reduce } from \"lodash-es\";\nimport { possiblePathsFrom } from \"./interpreter.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../scan/tokens.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, } from \"@chevrotain/gast\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === \"Option\") {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition || prod === \"Repetition\") {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory ||\n        prod === \"RepetitionMandatory\") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator ||\n        prod === \"RepetitionMandatoryWithSeparator\") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator ||\n        prod === \"RepetitionWithSeparator\") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation || prod === \"Alternation\") {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function getLookaheadPaths(options) {\n    const { occurrence, rule, prodType, maxLookahead } = options;\n    const type = getProdType(prodType);\n    if (type === PROD_TYPE.ALTERNATION) {\n        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n    }\n    else {\n        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n    }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length;\n    const areAllOneTokenLookahead = every(alts, (currAlt) => {\n        return every(currAlt, (currPath) => {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            const predicates = map(orAlts, (currAlt) => currAlt.GATE);\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                const currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        const singleTokenAlts = map(alts, (currAlt) => {\n            return flatten(currAlt);\n        });\n        const choiceToAlt = reduce(singleTokenAlts, (result, currAlt, idx) => {\n            forEach(currAlt, (currTokType) => {\n                if (!has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    if (!has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, {});\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            const nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = every(alt, (currPath) => {\n        return currPath.length === 1;\n    });\n    const numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        const singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            isEmpty(singleTokensTypes[0].categoryMatches)) {\n            const expectedTokenType = singleTokensTypes[0];\n            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n            };\n        }\n        else {\n            const choiceToAlt = reduce(singleTokensTypes, (result, currTokType, idx) => {\n                result[currTokType.tokenTypeIdx] = true;\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                const nextToken = this.LA(1);\n                return choiceToAlt[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (let j = 0; j < numOfPaths; j++) {\n                const currPath = alt[j];\n                const currPathLength = currPath.length;\n                for (let i = 0; i < currPathLength; i++) {\n                    const nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nclass RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n        super();\n        this.topProd = topProd;\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.restDef;\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            super.walkOption(optionProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            super.walkOption(atLeastOneProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(atLeastOneSepProd, currRest, prevRest);\n        }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            super.walkOption(manyProd, currRest, prevRest);\n        }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(manySepProd, currRest, prevRest);\n        }\n    }\n}\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n        super();\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n        this.targetRef = targetRef;\n        this.result = [];\n    }\n    checkIsTarget(node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    }\n    visitOption(node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    }\n    visitRepetition(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    }\n    visitRepetitionMandatory(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    }\n    visitRepetitionWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    }\n    visitAlternation(node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    }\n}\nfunction initializeArrayOfArrays(size) {\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    let keys = [\"\"];\n    for (let i = 0; i < path.length; i++) {\n        const tokType = path[i];\n        const longerKeys = [];\n        for (let j = 0; j < keys.length; j++) {\n            const currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (let t = 0; t < tokType.categoryMatches.length; t++) {\n                const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            const searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n    const finalResult = initializeArrayOfArrays(partialAlts.length);\n    const altsHashes = map(partialAlts, (currAltPaths) => {\n        const dict = {};\n        forEach(currAltPaths, (item) => {\n            const keys = pathToHashKeys(item.partialPath);\n            forEach(keys, (currKey) => {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    let newData = partialAlts;\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n        const currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        // alternatives loop\n        for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            const currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                const prefixKeys = pathToHashKeys(currPathPrefix);\n                const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n                    const currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (let j = 0; j < prefixKeys.length; j++) {\n                            const currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    forEach(newPartialPathsAndSuffixes, (item) => {\n                        const prefixKeys = pathToHashKeys(item.partialPath);\n                        forEach(prefixKeys, (key) => {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    const insideDef = insideDefVisitor.result;\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    const afterDef = afterDefWalker.startWalking();\n    const insideFlat = new AlternativeGAST({ definition: insideDef });\n    const afterFlat = new AlternativeGAST({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n        const otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (let j = 0; j < otherPath.length; j++) {\n            const searchTok = searchPath[j];\n            const otherTok = otherPath[j];\n            const matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        every(prefix, (tokType, idx) => {\n            const otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, (singleAltPaths) => every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))));\n}\n//# sourceMappingURL=lookahead.js.map","import { clone, compact, difference, drop, dropRight, filter, first, flatMap, flatten, forEach, groupBy, includes, isEmpty, map, pickBy, reduce, reject, values, } from \"lodash-es\";\nimport { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, getProductionDslName, isOptionalProd, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath, } from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\nexport function validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName,\n    });\n    return map(lookaheadValidationErrorMessages, (errorMessage) => (Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)));\n}\nexport function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = flatMap(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n    const duplicateRulesError = flatMap(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    const productionGroups = groupBy(allRuleProductions, identifyProductionForDuplicates);\n    const duplicates = pickBy(productionGroups, (currGroup) => {\n        return currGroup.length > 1;\n    });\n    const errors = map(values(duplicates), (currDuplicates) => {\n        const firstProd = first(currDuplicates);\n        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        const dslName = getProductionDslName(firstProd);\n        const defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx,\n        };\n        const param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nexport class OccurrenceValidationCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitNonTerminal(subrule) {\n        this.allProductions.push(subrule);\n    }\n    visitOption(option) {\n        this.allProductions.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n    visitAlternation(or) {\n        this.allProductions.push(or);\n    }\n    visitTerminal(terminal) {\n        this.allProductions.push(terminal);\n    }\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = [];\n    const occurrences = reduce(allRules, (result, curRule) => {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className,\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name,\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = [];\n    let errMsg;\n    if (!includes(definedRulesNames, ruleName)) {\n        errMsg =\n            `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n                `as it is not defined in any of the super grammars `;\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName,\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = [];\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        const ruleName = topRule.name;\n        const foundLeftRecursion = includes(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path,\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName,\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n        const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n            const newPath = clone(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    let result = [];\n    if (isEmpty(definition)) {\n        return result;\n    }\n    const firstProd = first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof AlternativeGAST ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    const isFirstOptional = isOptionalProd(firstProd);\n    const hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        const rest = drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nclass OrCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.alternations = [];\n    }\n    visitAlternation(node) {\n        this.alternations.push(node);\n    }\n}\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        const exceptLast = dropRight(currOr.definition);\n        return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n            const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n            if (isEmpty(possibleFirstInAlt)) {\n                return [\n                    {\n                        message: errMsgProvider.buildEmptyAlternationError({\n                            topLevelRule: topLevelRule,\n                            alternation: currOr,\n                            emptyChoiceIdx: currAltIdx,\n                        }),\n                        type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                        ruleName: topLevelRule.name,\n                        occurrence: currOr.idx,\n                        alternative: currAltIdx + 1,\n                    },\n                ];\n            }\n            else {\n                return [];\n            }\n        });\n    });\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    let ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n    const errors = flatMap(ors, (currOr) => {\n        const currOccurrence = currOr.idx;\n        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\nexport class RepetitionCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n}\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        if (currOr.definition.length > 255) {\n            return [\n                {\n                    message: errMsgProvider.buildTooManyAlternativesError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                    }),\n                    type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                },\n            ];\n        }\n        else {\n            return [];\n        }\n    });\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = [];\n    forEach(topLevelRules, (currTopRule) => {\n        const collectorVisitor = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor);\n        const allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, (currProd) => {\n            const prodType = getProdType(currProd);\n            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            const currOccurrence = currProd.idx;\n            const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            const pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                const errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd,\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name,\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = [];\n    const identicalAmbiguities = reduce(alternatives, (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, (currPath) => {\n            const altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath,\n                });\n            }\n        });\n        return result;\n    }, []);\n    const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n        const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n        const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path,\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: currAmbDescriptor.alts,\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = reduce(alternatives, (result, currAlt, idx) => {\n        const currPathsAndIdx = map(currAlt, (currPath) => {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    const errors = compact(flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return [];\n        }\n        const targetIdx = currPathAndIdx.idx;\n        const targetPath = currPathAndIdx.path;\n        const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n            const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path,\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices,\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = [];\n    const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n    forEach(topLevels, (currRule) => {\n        const currRuleName = currRule.name;\n        if (includes(tokenNames, currRuleName)) {\n            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName,\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map","import { includes } from \"lodash-es\";\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nconst RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nclass RecognitionException extends Error {\n    constructor(message, token) {\n        super(message);\n        this.token = token;\n        this.resyncedTokens = [];\n        // fix prototype chain when typescript target is ES5\n        Object.setPrototypeOf(this, new.target.prototype);\n        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nexport class MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = MISMATCHED_TOKEN_EXCEPTION;\n    }\n}\nexport class NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = NO_VIABLE_ALT_EXCEPTION;\n    }\n}\nexport class NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n        super(message, token);\n        this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n    }\n}\nexport class EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = EARLY_EXIT_EXCEPTION;\n    }\n}\n//# sourceMappingURL=exceptions_public.js.map","import { createTokenInstance, EOF, tokenMatcher, } from \"../../../scan/tokens_public.js\";\nimport { clone, dropRight, find, flatten, has, includes, isEmpty, map, } from \"lodash-es\";\nimport { MismatchedTokenException } from \"../../exceptions_public.js\";\nimport { IN } from \"../../constants.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nexport const EOF_FOLLOW_KEY = {};\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport class InRuleRecoveryException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = IN_RULE_RECOVERY_EXCEPTION;\n    }\n}\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n    initRecoverable(config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    }\n    getTokenToInsert(tokType) {\n        const tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n        return true;\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n        return true;\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        // TODO: can the resyncTokenType be cached?\n        const reSyncTokType = this.findReSyncTokenType();\n        const savedLexerState = this.exportLexerState();\n        const resyncedTokens = [];\n        let passedResyncPoint = false;\n        const nextTokenWithoutResync = this.LA(1);\n        let currToken = this.LA(1);\n        const generateErrorMessage = () => {\n            const previousToken = this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = dropRight(resyncedTokens);\n            this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        const follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            const tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            const nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (isEmpty(follows)) {\n            return false;\n        }\n        const mismatchedTok = this.LA(1);\n        const isMisMatchedTokInFollows = find(follows, (possibleFollowsTokType) => {\n            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n        const followKey = this.getCurrFollowKey();\n        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return includes(currentRuleReSyncSet, tokenTypeIdx);\n    }\n    findReSyncTokenType() {\n        const allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        let nextToken = this.LA(1);\n        let k = 2;\n        while (true) {\n            const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n                const canMatch = tokenMatcher(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    }\n    getCurrFollowKey() {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName),\n        };\n    }\n    buildFullFollowKeyStack() {\n        const explicitRuleStack = this.RULE_STACK;\n        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return map(explicitRuleStack, (ruleName, idx) => {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n            };\n        });\n    }\n    flattenFollowSet() {\n        const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n            return this.getFollowSetFromFollowKey(currKey);\n        });\n        return flatten(followStack);\n    }\n    getFollowSetFromFollowKey(followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    }\n    reSyncTo(tokType) {\n        const resyncedTokens = [];\n        let nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return dropRight(resyncedTokens);\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n        const pathRuleStack = this.getHumanReadableRuleStack();\n        const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);\n        const grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule,\n        };\n        return grammarPath;\n    }\n    getHumanReadableRuleStack() {\n        return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n    }\n}\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    let firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        const currRuleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[currRuleName];\n        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token;\n    let nextTokIdx = firstAfterRepInfo.occurrence;\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map","// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nexport const BITS_FOR_METHOD_TYPE = 4;\nexport const BITS_FOR_OCCURRENCE_IDX = 8;\nexport const BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx;\n}\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n//# sourceMappingURL=keys.js.map","import { flatMap, isEmpty } from \"lodash-es\";\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser.js\";\nimport { validateAmbiguousAlternationAlternatives, validateEmptyOrAlternative, validateNoLeftRecursion, validateSomeNonEmptyLookaheadPath, } from \"./checks.js\";\nimport { buildAlternativesLookAheadFunc, buildLookaheadFuncForOptionalProd, buildLookaheadFuncForOr, buildSingleAlternativeLookaheadFunction, getProdType, } from \"./lookahead.js\";\nexport class LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        this.maxLookahead =\n            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    validate(options) {\n        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if (isEmpty(leftRecursionErrors)) {\n            const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            const allErrors = [\n                ...leftRecursionErrors,\n                ...emptyAltErrors,\n                ...ambiguousAltsErrors,\n                ...emptyRepetitionErrors,\n            ];\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    }\n    validateNoLeftRecursion(rules) {\n        return flatMap(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateEmptyOrAlternatives(rules) {\n        return flatMap(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n        return flatMap(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n        return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n    }\n    buildLookaheadForAlternation(options) {\n        return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n    }\n    buildLookaheadForOptional(options) {\n        return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n    }\n}\n//# sourceMappingURL=llk_lookahead.js.map","import { forEach, has } from \"lodash-es\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { GAstVisitor, getProductionDslName, } from \"@chevrotain/gast\";\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead.js\";\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n    initLooksAhead(config) {\n        this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = has(config, \"maxLookahead\")\n            ? config.maxLookahead // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n            ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n            : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n        this.lookAheadFuncsCache = new Map();\n    }\n    preComputeLookaheadFunctions(rules) {\n        forEach(rules, (currRule) => {\n            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n                const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator, } = collectMethods(currRule);\n                forEach(alternation, (currProd) => {\n                    const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n                        const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                            prodOccurrence: currProd.idx,\n                            rule: currRule,\n                            maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                            hasPredicates: currProd.hasPredicates,\n                            dynamicTokensEnabled: this.dynamicTokensEnabled,\n                        });\n                        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n                        this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                forEach(repetition, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(option, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatory, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatoryWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n            });\n        });\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n                prodOccurrence,\n                rule,\n                maxLookahead: prodMaxLookahead || this.maxLookahead,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n                prodType,\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            this.setLaFuncCache(key, laFunc);\n        });\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n    }\n    getLaFuncFromCache(key) {\n        return this.lookAheadFuncsCache.get(key);\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    }\n}\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    reset() {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    visitOption(option) {\n        this.dslMethods.option.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.dslMethods.repetition.push(many);\n    }\n    visitAlternation(or) {\n        this.dslMethods.alternation.push(or);\n    }\n}\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nexport function collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    const dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\n//# sourceMappingURL=looksahead.js.map","/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\n//# sourceMappingURL=cst.js.map","const NAME = \"name\";\nexport function defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue,\n    });\n}\n//# sourceMappingURL=lang_extensions.js.map","import { compact, filter, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map, } from \"lodash-es\";\nimport { defineNameProp } from \"../../lang/lang_extensions.js\";\nexport function defaultVisit(ctx, param) {\n    const childrenNames = keys(ctx);\n    const childrenNamesLength = childrenNames.length;\n    for (let i = 0; i < childrenNamesLength; i++) {\n        const currChildName = childrenNames[i];\n        const currChildArray = ctx[currChildName];\n        const currChildArrayLength = currChildArray.length;\n        for (let j = 0; j < currChildArrayLength; j++) {\n            const currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n    const semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if (isArray(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if (isUndefined(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!isEmpty(semanticDefinitionErrors)) {\n                const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n                    `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`);\n            }\n        },\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    const withDefaultsProto = Object.create(baseConstructor.prototype);\n    forEach(ruleNames, (ruleName) => {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nexport function validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    return missingErrors;\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = filter(ruleNames, (currRuleName) => {\n        return isFunction(visitorInstance[currRuleName]) === false;\n    });\n    const errors = map(missingRuleNames, (currRuleName) => {\n        return {\n            msg: `Missing visitor method: <${currRuleName}> on ${(visitorInstance.constructor.name)} CST Visitor.`,\n            type: CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName,\n        };\n    });\n    return compact(errors);\n}\n//# sourceMappingURL=cst_visitor.js.map","import { forEach, has, isArray, isFunction, last as peek, some, } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nimport { Lexer } from \"../../../scan/lexer_public.js\";\nimport { augmentTokenTypes, hasShortKeyProperty, } from \"../../../scan/tokens.js\";\nimport { createToken, createTokenInstance, } from \"../../../scan/tokens_public.js\";\nimport { END_OF_FILE } from \"../parser.js\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys.js\";\nconst RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\",\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nconst RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {},\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n    initGastRecorder(config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    }\n    enableRecording() {\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", () => {\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                this[`CONSUME${idx}`] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                this[`SUBRULE${idx}`] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                this[`OPTION${idx}`] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                this[`OR${idx}`] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                this[`MANY${idx}`] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                this[`MANY_SEP${idx}`] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            }\n            // DSL methods with the idx(suffix) as an argument\n            this[`consume`] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            this[`subrule`] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            this[`option`] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            this[`or`] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            this[`many`] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            this[`atLeastOne`] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            this.ACTION = this.ACTION_RECORD;\n            this.BACKTRACK = this.BACKTRACK_RECORD;\n            this.LA = this.LA_RECORD;\n        });\n    }\n    disableRecording() {\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", () => {\n            const that = this;\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                delete that[`CONSUME${idx}`];\n                delete that[`SUBRULE${idx}`];\n                delete that[`OPTION${idx}`];\n                delete that[`OR${idx}`];\n                delete that[`MANY${idx}`];\n                delete that[`MANY_SEP${idx}`];\n                delete that[`AT_LEAST_ONE${idx}`];\n                delete that[`AT_LEAST_ONE_SEP${idx}`];\n            }\n            delete that[`consume`];\n            delete that[`subrule`];\n            delete that[`option`];\n            delete that[`or`];\n            delete that[`many`];\n            delete that[`atLeastOne`];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n        // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n        return () => true;\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return END_OF_FILE;\n    }\n    topLevelRuleRecord(name, def) {\n        try {\n            const newTopLevelRule = new Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n        return recordProd.call(this, Option, actionORMethodDef, occurrence);\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const ruleName = ruleToCall.ruleName;\n        const newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!hasShortKeyProperty(tokType)) {\n            const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    }\n}\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    const newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    // Only an array of alternatives\n    const hasOptions = isArray(mainProdArg) === false;\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    const newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    });\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE));\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    forEach(alts, (currAlt) => {\n        const currAltFlat = new Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (has(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(this);\n        this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : `${idx}`;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n            `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`);\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map","import { clone, forEach, has, isEmpty, map, values } from \"lodash-es\";\nimport { toFastProperties } from \"@chevrotain/utils\";\nimport { computeAllProdsFollows } from \"../grammar/follow.js\";\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public.js\";\nimport { defaultGrammarValidatorErrorProvider, defaultParserErrorProvider, } from \"../errors_public.js\";\nimport { resolveGrammar, validateGrammar, } from \"../grammar/gast/gast_resolver_public.js\";\nimport { Recoverable } from \"./traits/recoverable.js\";\nimport { LooksAhead } from \"./traits/looksahead.js\";\nimport { TreeBuilder } from \"./traits/tree_builder.js\";\nimport { LexerAdapter } from \"./traits/lexer_adapter.js\";\nimport { RecognizerApi } from \"./traits/recognizer_api.js\";\nimport { RecognizerEngine } from \"./traits/recognizer_engine.js\";\nimport { ErrorHandler } from \"./traits/error_handler.js\";\nimport { ContentAssist } from \"./traits/context_assist.js\";\nimport { GastRecorder } from \"./traits/gast_recorder.js\";\nimport { PerformanceTracer } from \"./traits/perf_tracer.js\";\nimport { applyMixins } from \"./utils/apply_mixins.js\";\nimport { validateLookahead } from \"../grammar/checks.js\";\nexport const END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nexport const DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false,\n});\nexport const DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n});\nexport var ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nexport function EMPTY_ALT(value = undefined) {\n    return function () {\n        return value;\n    };\n}\nexport class Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" +\n            \"\\t\\nUse the **instance** method with the same name instead.\");\n    }\n    performSelfAnalysis() {\n        this.TRACE_INIT(\"performSelfAnalysis\", () => {\n            let defErrorsMsgs;\n            this.selfAnalysisDone = true;\n            const className = this.className;\n            this.TRACE_INIT(\"toFastProps\", () => {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                toFastProperties(this);\n            });\n            this.TRACE_INIT(\"Grammar Recording\", () => {\n                try {\n                    this.enableRecording();\n                    // Building the GAST\n                    forEach(this.definedRulesNames, (currRuleName) => {\n                        const wrappedRule = this[currRuleName];\n                        const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        let recordedRuleGast;\n                        this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    this.disableRecording();\n                }\n            });\n            let resolverErrors = [];\n            this.TRACE_INIT(\"Grammar Resolving\", () => {\n                resolverErrors = resolveGrammar({\n                    rules: values(this.gastProductionsCache),\n                });\n                this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n            });\n            this.TRACE_INIT(\"Grammar Validations\", () => {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if (isEmpty(resolverErrors) && this.skipValidations === false) {\n                    const validationErrors = validateGrammar({\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        errMsgProvider: defaultGrammarValidatorErrorProvider,\n                        grammarName: className,\n                    });\n                    const lookaheadValidationErrors = validateLookahead({\n                        lookaheadStrategy: this.lookaheadStrategy,\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        grammarName: className,\n                    });\n                    this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if (isEmpty(this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (this.recoveryEnabled) {\n                    this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n                        const allFollows = computeAllProdsFollows(values(this.gastProductionsCache));\n                        this.resyncFollows = allFollows;\n                    });\n                }\n                this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n                    var _a, _b;\n                    (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                        rules: values(this.gastProductionsCache),\n                    });\n                    this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !isEmpty(this.definitionErrors)) {\n                defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message);\n                throw new Error(`Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n            }\n        });\n    }\n    constructor(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        const that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if (has(config, \"ignoredIssues\")) {\n            throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n                \"For further details.\");\n        }\n        this.skipValidations = has(config, \"skipValidations\")\n            ? config.skipValidations // casting assumes the end user passing the correct type\n            : DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n}\n// Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n// (normally during the parser's constructor).\n// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n// for example: duplicate rule names, referencing an unresolved subrule, ect...\n// This flag should not be enabled during normal usage, it is used in special situations, for example when\n// needing to display the parser definition errors in some GUI(online playground).\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n]);\nexport class CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = true;\n        super(tokenVocabulary, configClone);\n    }\n}\nexport class EmbeddedActionsParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = false;\n        super(tokenVocabulary, configClone);\n    }\n}\n//# sourceMappingURL=parser.js.map","export function applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n        const baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n            if (propName === \"constructor\") {\n                return;\n            }\n            const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\n//# sourceMappingURL=apply_mixins.js.map","import { defaults, forEach } from \"lodash-es\";\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver.js\";\nimport { validateGrammar as orgValidateGrammar } from \"../checks.js\";\nimport { defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider, } from \"../../errors_public.js\";\nexport function resolveGrammar(options) {\n    const actualOptions = defaults(options, {\n        errMsgProvider: defaultGrammarResolverErrorProvider,\n    });\n    const topRulesTable = {};\n    forEach(options.rules, (rule) => {\n        topRulesTable[rule.name] = rule;\n    });\n    return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\nexport function validateGrammar(options) {\n    options = defaults(options, {\n        errMsgProvider: defaultGrammarValidatorErrorProvider,\n    });\n    return orgValidateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n//# sourceMappingURL=gast_resolver_public.js.map","import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset, } from \"../../cst/cst.js\";\nimport { has, isUndefined, keys, noop } from \"lodash-es\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults, } from \"../../cst/cst_visitor.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n    initTreeBuilder(config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop;\n            this.cstFinallyStateUpdate = noop;\n            this.cstPostTerminal = noop;\n            this.cstPostNonTerminal = noop;\n            this.cstPostRule = noop;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = noop;\n            }\n            else {\n                throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n            }\n        }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n        const nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n        const cstNode = {\n            name: fullRuleName,\n            children: Object.create(null),\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    }\n    cstFinallyStateUpdate() {\n        this.CST_STACK.pop();\n    }\n    cstPostRuleFull(ruleCstNode) {\n        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n        const prevToken = this.LA(0);\n        // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    }\n    cstPostTerminal(key, consumedToken) {\n        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n    getBaseCstVisitorConstructor() {\n        if (isUndefined(this.baseCstVisitorConstructor)) {\n            const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n        if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    }\n    getLastExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    }\n    getPreviousExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n        const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    }\n}\n//# sourceMappingURL=tree_builder.js.map","import { END_OF_FILE } from \"../parser.js\";\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n    initLexerAdapter() {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    }\n    set input(newInput) {\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        if (this.selfAnalysisDone !== true) {\n            throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n        }\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        this.reset();\n        this.tokVector = newInput;\n        this.tokVectorLength = newInput.length;\n    }\n    get input() {\n        return this.tokVector;\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return END_OF_FILE;\n        }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n        const soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    }\n    consumeToken() {\n        this.currIdx++;\n    }\n    exportLexerState() {\n        return this.currIdx;\n    }\n    importLexerState(newState) {\n        this.currIdx = newState;\n    }\n    resetLexerState() {\n        this.currIdx = -1;\n    }\n    moveToTerminatedState() {\n        this.currIdx = this.tokVector.length - 1;\n    }\n    getLexerPosition() {\n        return this.exportLexerState();\n    }\n}\n//# sourceMappingURL=lexer_adapter.js.map","import { clone, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values, } from \"lodash-es\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException, } from \"../../exceptions_public.js\";\nimport { PROD_TYPE } from \"../../grammar/lookahead.js\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker, } from \"../../grammar/interpreter.js\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser.js\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable.js\";\nimport { EOF } from \"../../../scan/tokens_public.js\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../../scan/tokens.js\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (isArray(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (isEmpty(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (isArray(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (has(tokenVocabulary, \"modes\") &&\n            every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            const allTokenTypes = flatten(values(tokenVocabulary.modes));\n            const uniqueTokens = uniq(allTokenTypes);\n            this.tokensMap = reduce(uniqueTokens, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (isObject(tokenVocabulary)) {\n            this.tokensMap = clone(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        this.tokensMap[\"EOF\"] = EOF;\n        const allTokenTypes = has(tokenVocabulary, \"modes\")\n            ? flatten(values(tokenVocabulary.modes))\n            : values(tokenVocabulary);\n        const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches));\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokenStructuredMatcherNoCategories\n            : tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        augmentTokenTypes(values(this.tokensMap));\n    }\n    defineRule(ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n                `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n        }\n        const resyncEnabled = has(config, \"resyncEnabled\")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.resyncEnabled;\n        const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        let invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    const cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n        const isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if (isRecognitionException(e)) {\n            const recogError = e;\n            if (reSyncEnabled) {\n                const reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc(e);\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc(e);\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n        const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            let notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterAtLeastOneSepWalker,\n            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookaheadFunction = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookaheadFunction;\n                lookaheadFunction = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        let notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterManySepWalker,\n            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n        }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker,\n        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    }\n    doSingleRepetition(action) {\n        const beforeIteration = this.getLexerPosition();\n        action.call(this);\n        const afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    }\n    orInternal(altsOrOpts, occurrence) {\n        const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        const laFunc = this.getLaFuncFromCache(laKey);\n        const altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            const chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    }\n    ruleFinallyStateUpdate() {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            const firstRedundantTok = this.LA(1);\n            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n        let ruleResult;\n        try {\n            const args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    }\n    subruleInternalError(e, options, ruleName) {\n        if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    }\n    consumeInternal(tokType, idx, options) {\n        let consumedToken;\n        try {\n            const nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    }\n    consumeInternalError(tokType, nextToken, options) {\n        let msg;\n        const previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n        }\n        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    }\n    saveRecogState() {\n        // errors is a getter which will clone the errors array\n        const savedErrors = this.errors;\n        const savedRuleStack = clone(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n        };\n    }\n    reloadRecogState(newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    }\n    isBackTracking() {\n        return this.isBackTrackingStack.length !== 0;\n    }\n    getCurrRuleFullName() {\n        const shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    }\n    shortRuleNameToFullName(shortName) {\n        return this.shortRuleNameToFull[shortName];\n    }\n    isAtEndOfInput() {\n        return this.tokenMatcher(this.LA(1), EOF);\n    }\n    reset() {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    }\n}\n//# sourceMappingURL=recognizer_engine.js.map","import { includes, values } from \"lodash-es\";\nimport { isRecognitionException } from \"../../exceptions_public.js\";\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser.js\";\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public.js\";\nimport { validateRuleIsOverridden } from \"../../grammar/checks.js\";\nimport { serializeGrammar } from \"@chevrotain/gast\";\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n    ACTION(impl) {\n        return impl.call(this);\n    }\n    consume(idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    }\n    subrule(idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    }\n    option(idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    }\n    or(idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    }\n    many(idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    }\n    atLeastOne(idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    }\n    CONSUME(tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    }\n    CONSUME1(tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    }\n    CONSUME2(tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    }\n    CONSUME3(tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    }\n    CONSUME4(tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    }\n    CONSUME5(tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    }\n    CONSUME6(tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    }\n    CONSUME7(tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    }\n    CONSUME8(tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    }\n    CONSUME9(tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    }\n    SUBRULE(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    }\n    SUBRULE1(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    }\n    SUBRULE2(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    }\n    SUBRULE3(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    }\n    SUBRULE4(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    }\n    SUBRULE5(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    }\n    SUBRULE6(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    }\n    SUBRULE7(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    }\n    SUBRULE8(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    }\n    SUBRULE9(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    }\n    OPTION(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    }\n    OPTION1(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    }\n    OPTION2(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    }\n    OPTION3(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    }\n    OPTION4(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    }\n    OPTION5(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    }\n    OPTION6(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    }\n    OPTION7(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    }\n    OPTION8(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    }\n    OPTION9(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    }\n    OR(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    }\n    OR1(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    }\n    OR2(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    }\n    OR3(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    }\n    OR4(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    }\n    OR5(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    }\n    OR6(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    }\n    OR7(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    }\n    OR8(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    }\n    OR9(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    }\n    MANY(actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    }\n    MANY1(actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    }\n    MANY2(actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    }\n    MANY3(actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    }\n    MANY4(actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    }\n    MANY5(actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    }\n    MANY6(actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    }\n    MANY7(actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    }\n    MANY8(actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    }\n    MANY9(actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    }\n    MANY_SEP(options) {\n        this.manySepFirstInternal(0, options);\n    }\n    MANY_SEP1(options) {\n        this.manySepFirstInternal(1, options);\n    }\n    MANY_SEP2(options) {\n        this.manySepFirstInternal(2, options);\n    }\n    MANY_SEP3(options) {\n        this.manySepFirstInternal(3, options);\n    }\n    MANY_SEP4(options) {\n        this.manySepFirstInternal(4, options);\n    }\n    MANY_SEP5(options) {\n        this.manySepFirstInternal(5, options);\n    }\n    MANY_SEP6(options) {\n        this.manySepFirstInternal(6, options);\n    }\n    MANY_SEP7(options) {\n        this.manySepFirstInternal(7, options);\n    }\n    MANY_SEP8(options) {\n        this.manySepFirstInternal(8, options);\n    }\n    MANY_SEP9(options) {\n        this.manySepFirstInternal(9, options);\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    }\n    AT_LEAST_ONE_SEP(options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    }\n    AT_LEAST_ONE_SEP1(options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    }\n    AT_LEAST_ONE_SEP2(options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    }\n    AT_LEAST_ONE_SEP3(options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    }\n    AT_LEAST_ONE_SEP4(options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    }\n    AT_LEAST_ONE_SEP5(options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    }\n    AT_LEAST_ONE_SEP6(options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    }\n    AT_LEAST_ONE_SEP7(options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    }\n    AT_LEAST_ONE_SEP8(options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    }\n    AT_LEAST_ONE_SEP9(options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n        if (includes(this.definedRulesNames, name)) {\n            const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className,\n            });\n            const error = {\n                message: errMsg,\n                type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name,\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        const ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n        const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n        this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n        const ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    BACKTRACK(grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            const orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if (isRecognitionException(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    }\n    // GAST export APIs\n    getGAstProductions() {\n        return this.gastProductionsCache;\n    }\n    getSerializedGastProductions() {\n        return serializeGrammar(values(this.gastProductionsCache));\n    }\n}\n//# sourceMappingURL=recognizer_api.js.map","import { EarlyExitException, isRecognitionException, NoViableAltException, } from \"../../exceptions_public.js\";\nimport { clone, has } from \"lodash-es\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, } from \"../../grammar/lookahead.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n    initErrorHandler(config) {\n        this._errors = [];\n        this.errorMessageProvider = has(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    }\n    SAVE_ERROR(error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    }\n    get errors() {\n        return clone(this._errors);\n    }\n    set errors(newErrors) {\n        this._errors = newErrors;\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        const insideProdPaths = lookAheadPathsPerAlternative[0];\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName,\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const previousToken = this.LA(0);\n        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName(),\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    }\n}\n//# sourceMappingURL=error_handler.js.map","import { NextAfterTokenWalker, nextPossibleTokensAfter, } from \"../../grammar/interpreter.js\";\nimport { first, isUndefined } from \"lodash-es\";\nexport class ContentAssist {\n    initContentAssist() { }\n    computeContentAssist(startRuleName, precedingInput) {\n        const startRuleGast = this.gastProductionsCache[startRuleName];\n        if (isUndefined(startRuleGast)) {\n            throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n        }\n        return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n        const topRuleName = first(grammarPath.ruleStack);\n        const gastProductions = this.getGAstProductions();\n        const topProduction = gastProductions[topRuleName];\n        const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    }\n}\n//# sourceMappingURL=context_assist.js.map","import { has } from \"lodash-es\";\nimport { timer } from \"@chevrotain/utils\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n    initPerformanceTracer(config) {\n        if (has(config, \"traceInitPerf\")) {\n            const userTraceInitPerf = config.traceInitPerf;\n            const traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf; // assumes end user provides the correct config value/type\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(`${indent}--> <${phaseDesc}>`);\n            }\n            const { time, value } = timer(phaseImpl);\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            const traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    }\n}\n//# sourceMappingURL=perf_tracer.js.map","import { GAstVisitor, NonTerminal } from \"@chevrotain/gast\";\nimport { assign, flatten, groupBy, map, some, values } from \"lodash-es\";\nexport function buildModel(productions) {\n    const generator = new CstNodeDefinitionGenerator();\n    const allRules = values(productions);\n    return map(allRules, (rule) => generator.visitRule(rule));\n}\nclass CstNodeDefinitionGenerator extends GAstVisitor {\n    visitRule(node) {\n        const rawElements = this.visitEach(node.definition);\n        const grouped = groupBy(rawElements, (el) => el.propertyName);\n        const properties = map(grouped, (group, propertyName) => {\n            const allNullable = !some(group, (el) => !el.canBeNull);\n            // In an alternation with a label a property name can have\n            // multiple types.\n            let propertyType = group[0].type;\n            if (group.length > 1) {\n                propertyType = map(group, (g) => g.type);\n            }\n            return {\n                name: propertyName,\n                type: propertyType,\n                optional: allNullable,\n            };\n        });\n        return {\n            name: node.name,\n            properties: properties,\n        };\n    }\n    visitAlternative(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitOption(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitRepetition(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitRepetitionMandatory(node) {\n        return this.visitEach(node.definition);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        return this.visitEach(node.definition).concat({\n            propertyName: node.separator.name,\n            canBeNull: true,\n            type: getType(node.separator),\n        });\n    }\n    visitRepetitionWithSeparator(node) {\n        return this.visitEachAndOverrideWith(node.definition, {\n            canBeNull: true,\n        }).concat({\n            propertyName: node.separator.name,\n            canBeNull: true,\n            type: getType(node.separator),\n        });\n    }\n    visitAlternation(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitTerminal(node) {\n        return [\n            {\n                propertyName: node.label || node.terminalType.name,\n                canBeNull: false,\n                type: getType(node),\n            },\n        ];\n    }\n    visitNonTerminal(node) {\n        return [\n            {\n                propertyName: node.label || node.nonTerminalName,\n                canBeNull: false,\n                type: getType(node),\n            },\n        ];\n    }\n    visitEachAndOverrideWith(definition, override) {\n        return map(this.visitEach(definition), (definition) => assign({}, definition, override));\n    }\n    visitEach(definition) {\n        return flatten(map(definition, (definition) => this.visit(definition)));\n    }\n}\nfunction getType(production) {\n    if (production instanceof NonTerminal) {\n        return {\n            kind: \"rule\",\n            name: production.referencedRule.name,\n        };\n    }\n    return { kind: \"token\" };\n}\n//# sourceMappingURL=model.js.map","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\nexport default unicodeToArray;\n","import asciiToArray from './_asciiToArray.js';\nimport hasUnicode from './_hasUnicode.js';\nimport unicodeToArray from './_unicodeToArray.js';\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\nexport default stringToArray;\n","/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\nexport default asciiToArray;\n","import createCaseFirst from './_createCaseFirst.js';\n\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */\nvar upperFirst = createCaseFirst('toUpperCase');\n\nexport default upperFirst;\n","import castSlice from './_castSlice.js';\nimport hasUnicode from './_hasUnicode.js';\nimport stringToArray from './_stringToArray.js';\nimport toString from './toString.js';\n\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString(string);\n\n    var strSymbols = hasUnicode(string)\n      ? stringToArray(string)\n      : undefined;\n\n    var chr = strSymbols\n      ? strSymbols[0]\n      : string.charAt(0);\n\n    var trailing = strSymbols\n      ? castSlice(strSymbols, 1).join('')\n      : string.slice(1);\n\n    return chr[methodName]() + trailing;\n  };\n}\n\nexport default createCaseFirst;\n","import baseSlice from './_baseSlice.js';\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\nexport default castSlice;\n","import { flatten, isArray, map, reduce, uniq, upperFirst } from \"lodash-es\";\nexport function genDts(model, options) {\n    let contentParts = [];\n    contentParts = contentParts.concat(`import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";`);\n    contentParts = contentParts.concat(flatten(map(model, (node) => genCstNodeTypes(node))));\n    if (options.includeVisitorInterface) {\n        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));\n    }\n    return contentParts.join(\"\\n\\n\") + \"\\n\";\n}\nfunction genCstNodeTypes(node) {\n    const nodeCstInterface = genNodeInterface(node);\n    const nodeChildrenInterface = genNodeChildrenType(node);\n    return [nodeCstInterface, nodeChildrenInterface];\n}\nfunction genNodeInterface(node) {\n    const nodeInterfaceName = getNodeInterfaceName(node.name);\n    const childrenTypeName = getNodeChildrenTypeName(node.name);\n    return `export interface ${nodeInterfaceName} extends CstNode {\n  name: \"${node.name}\";\n  children: ${childrenTypeName};\n}`;\n}\nfunction genNodeChildrenType(node) {\n    const typeName = getNodeChildrenTypeName(node.name);\n    return `export type ${typeName} = {\n  ${map(node.properties, (property) => genChildProperty(property)).join(\"\\n  \")}\n};`;\n}\nfunction genChildProperty(prop) {\n    const typeName = buildTypeString(prop.type);\n    return `${prop.name}${prop.optional ? \"?\" : \"\"}: ${typeName}[];`;\n}\nfunction genVisitor(name, nodes) {\n    return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ${map(nodes, (node) => genVisitorFunction(node)).join(\"\\n  \")}\n}`;\n}\nfunction genVisitorFunction(node) {\n    const childrenTypeName = getNodeChildrenTypeName(node.name);\n    return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`;\n}\nfunction buildTypeString(type) {\n    if (isArray(type)) {\n        const typeNames = uniq(map(type, (t) => getTypeString(t)));\n        const typeString = reduce(typeNames, (sum, t) => sum + \" | \" + t);\n        return \"(\" + typeString + \")\";\n    }\n    else {\n        return getTypeString(type);\n    }\n}\nfunction getTypeString(type) {\n    if (type.kind === \"token\") {\n        return \"IToken\";\n    }\n    return getNodeInterfaceName(type.name);\n}\nfunction getNodeInterfaceName(ruleName) {\n    return upperFirst(ruleName) + \"CstNode\";\n}\nfunction getNodeChildrenTypeName(ruleName) {\n    return upperFirst(ruleName) + \"CstChildren\";\n}\n//# sourceMappingURL=generate.js.map","import { buildModel } from \"./model.js\";\nimport { genDts } from \"./generate.js\";\nconst defaultOptions = {\n    includeVisitorInterface: true,\n    visitorInterfaceName: \"ICstNodeVisitor\",\n};\nexport function generateCstDts(productions, options) {\n    const effectiveOptions = Object.assign(Object.assign({}, defaultOptions), options);\n    const model = buildModel(productions);\n    return genDts(model, effectiveOptions);\n}\n//# sourceMappingURL=api.js.map","import { VERSION } from \"../version.js\";\nexport function createSyntaxDiagramsCode(grammar, { resourceBase = `https://unpkg.com/chevrotain@${VERSION}/diagrams/`, css = `https://unpkg.com/chevrotain@${VERSION}/diagrams/diagrams.css`, } = {}) {\n    const header = `\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n`;\n    const cssHtml = `\n<link rel='stylesheet' href='${css}'>\n`;\n    const scripts = `\n<script src='${resourceBase}vendor/railroad-diagrams.js'></script>\n<script src='${resourceBase}src/diagrams_builder.js'></script>\n<script src='${resourceBase}src/diagrams_behavior.js'></script>\n<script src='${resourceBase}src/main.js'></script>\n`;\n    const diagramsDiv = `\n<div id=\"diagrams\" align=\"center\"></div>    \n`;\n    const serializedGrammar = `\n<script>\n    window.serializedGrammar = ${JSON.stringify(grammar, null, \"  \")};\n</script>\n`;\n    const initLogic = `\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n`;\n    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);\n}\n//# sourceMappingURL=render_public.js.map","/* istanbul ignore file - tricky to import some things from this module during testing */\n// semantic version\nexport { VERSION } from \"./version.js\";\nexport { CstParser, EmbeddedActionsParser, ParserDefinitionErrorType, EMPTY_ALT, } from \"./parse/parser/parser.js\";\nexport { Lexer, LexerDefinitionErrorType } from \"./scan/lexer_public.js\";\n// Tokens utilities\nexport { createToken, createTokenInstance, EOF, tokenLabel, tokenMatcher, tokenName, } from \"./scan/tokens_public.js\";\n// Lookahead\nexport { getLookaheadPaths } from \"./parse/grammar/lookahead.js\";\nexport { LLkLookaheadStrategy } from \"./parse/grammar/llk_lookahead.js\";\n// Other Utilities\nexport { defaultParserErrorProvider } from \"./parse/errors_public.js\";\nexport { EarlyExitException, isRecognitionException, MismatchedTokenException, NotAllInputParsedException, NoViableAltException, } from \"./parse/exceptions_public.js\";\nexport { defaultLexerErrorProvider } from \"./scan/lexer_errors_public.js\";\n// grammar reflection API\nexport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\n// GAST Utilities\nexport { serializeGrammar, serializeProduction, GAstVisitor, } from \"@chevrotain/gast\";\nexport { generateCstDts } from \"@chevrotain/cst-dts-gen\";\n/* istanbul ignore next */\nexport function clearCache() {\n    console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n        \"\\n\\t It performs no action other than printing this message.\" +\n        \"\\n\\t Please avoid using it as it will be completely removed in the future\");\n}\nexport { createSyntaxDiagramsCode } from \"./diagrams/render_public.js\";\nexport class Parser {\n    constructor() {\n        throw new Error(\"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n\" +\n            \"See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0\");\n    }\n}\n//# sourceMappingURL=api.js.map","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  GitGraphGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-FPAJGGOC.mjs\";\n\n// src/language/gitGraph/module.ts\nimport {\n  inject,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  EmptyFileSystem\n} from \"langium\";\n\n// src/language/gitGraph/tokenBuilder.ts\nvar GitGraphTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"GitGraphTokenBuilder\");\n  }\n  constructor() {\n    super([\"gitGraph\"]);\n  }\n};\n\n// src/language/gitGraph/module.ts\nvar GitGraphModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new GitGraphTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createGitGraphServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const GitGraph = inject(\n    createDefaultCoreModule({ shared }),\n    GitGraphGeneratedModule,\n    GitGraphModule\n  );\n  shared.ServiceRegistry.register(GitGraph);\n  return { shared, GitGraph };\n}\n__name(createGitGraphServices, \"createGitGraphServices\");\n\nexport {\n  GitGraphModule,\n  createGitGraphServices\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  InfoGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-FPAJGGOC.mjs\";\n\n// src/language/info/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/info/tokenBuilder.ts\nvar InfoTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"InfoTokenBuilder\");\n  }\n  constructor() {\n    super([\"info\", \"showInfo\"]);\n  }\n};\n\n// src/language/info/module.ts\nvar InfoModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new InfoTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createInfoServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Info = inject(\n    createDefaultCoreModule({ shared }),\n    InfoGeneratedModule,\n    InfoModule\n  );\n  shared.ServiceRegistry.register(Info);\n  return { shared, Info };\n}\n__name(createInfoServices, \"createInfoServices\");\n\nexport {\n  InfoModule,\n  createInfoServices\n};\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Emitter = exports.Event = void 0;\nconst ral_1 = require(\"./ral\");\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event || (exports.Event = Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                (0, ral_1.default)().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nexport default baseHas;\n","import baseHas from './_baseHas.js';\nimport hasPath from './_hasPath.js';\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nexport default has;\n","import baseExtremum from './_baseExtremum.js';\nimport baseLt from './_baseLt.js';\nimport identity from './identity.js';\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nexport default min;\n","import arrayMap from './_arrayMap.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseMap from './_baseMap.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nexport default map;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\nimport { TreeStreamImpl } from './stream.js';\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamCst(node) {\n    return new TreeStreamImpl(node, element => {\n        if (isCompositeCstNode(element)) {\n            return element.content;\n        }\n        else {\n            return [];\n        }\n    }, { includeRoot: true });\n}\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nexport function flattenCst(node) {\n    return streamCst(node).filter(isLeafCstNode);\n}\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nexport function isChildNode(child, parent) {\n    while (child.container) {\n        child = child.container;\n        if (child === parent) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function tokenToRange(token) {\n    // Chevrotain uses 1-based indices everywhere\n    // So we subtract 1 from every value to align with the LSP\n    return {\n        start: {\n            character: token.startColumn - 1,\n            line: token.startLine - 1\n        },\n        end: {\n            character: token.endColumn, // endColumn uses the correct index\n            line: token.endLine - 1\n        }\n    };\n}\nexport function toDocumentSegment(node) {\n    if (!node) {\n        return undefined;\n    }\n    const { offset, end, range } = node;\n    return {\n        range,\n        offset,\n        end,\n        length: end - offset\n    };\n}\nexport var RangeComparison;\n(function (RangeComparison) {\n    RangeComparison[RangeComparison[\"Before\"] = 0] = \"Before\";\n    RangeComparison[RangeComparison[\"After\"] = 1] = \"After\";\n    RangeComparison[RangeComparison[\"OverlapFront\"] = 2] = \"OverlapFront\";\n    RangeComparison[RangeComparison[\"OverlapBack\"] = 3] = \"OverlapBack\";\n    RangeComparison[RangeComparison[\"Inside\"] = 4] = \"Inside\";\n    RangeComparison[RangeComparison[\"Outside\"] = 5] = \"Outside\";\n})(RangeComparison || (RangeComparison = {}));\nexport function compareRange(range, to) {\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character <= to.start.character)) {\n        return RangeComparison.Before;\n    }\n    else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character >= to.end.character)) {\n        return RangeComparison.After;\n    }\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\n    if (startInside && endInside) {\n        return RangeComparison.Inside;\n    }\n    else if (startInside) {\n        return RangeComparison.OverlapBack;\n    }\n    else if (endInside) {\n        return RangeComparison.OverlapFront;\n    }\n    else {\n        return RangeComparison.Outside;\n    }\n}\nexport function inRange(range, to) {\n    const comparison = compareRange(range, to);\n    return comparison > RangeComparison.After;\n}\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nexport function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) {\n                offset--;\n            }\n        }\n        return findLeafNodeAtOffset(cstNode, offset);\n    }\n    return undefined;\n}\nexport function findCommentNode(cstNode, commentNames) {\n    if (cstNode) {\n        const previous = getPreviousNode(cstNode, true);\n        if (previous && isCommentNode(previous, commentNames)) {\n            return previous;\n        }\n        if (isRootCstNode(cstNode)) {\n            // Go from the first non-hidden node through all nodes in reverse order\n            // We do this to find the comment node which directly precedes the root node\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\n            for (let i = endIndex - 1; i >= 0; i--) {\n                const child = cstNode.content[i];\n                if (isCommentNode(child, commentNames)) {\n                    return child;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nexport function isCommentNode(cstNode, commentNames) {\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nexport function findLeafNodeAtOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, false);\n        if (searchResult) {\n            return findLeafNodeAtOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nexport function findLeafNodeBeforeOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, true);\n        if (searchResult) {\n            return findLeafNodeBeforeOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\nfunction binarySearch(node, offset, closest) {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode = undefined;\n    while (left <= right) {\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n        if (middleNode.offset <= offset && middleNode.end > offset) {\n            // Found an exact match\n            return middleNode;\n        }\n        if (middleNode.end <= offset) {\n            // Update the closest node (less than offset) and move to the right half\n            closestNode = closest ? middleNode : undefined;\n            left = middle + 1;\n        }\n        else {\n            // Move to the left half\n            right = middle - 1;\n        }\n    }\n    return closestNode;\n}\nexport function getPreviousNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while (index > 0) {\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) {\n                return previous;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nexport function getNextNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while (index < last) {\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) {\n                return next;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nexport function getStartlineNode(node) {\n    if (node.range.start.character === 0) {\n        return node;\n    }\n    const line = node.range.start.line;\n    let last = node;\n    let index;\n    while (node.container) {\n        const parent = node.container;\n        const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = undefined;\n        }\n        else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) {\n            break;\n        }\n        last = node;\n    }\n    return last;\n}\nexport function getInteriorNodes(start, end) {\n    const commonParent = getCommonParent(start, end);\n    if (!commonParent) {\n        return [];\n    }\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\nfunction getCommonParent(a, b) {\n    const aParents = getParentChain(a);\n    const bParents = getParentChain(b);\n    let current;\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) {\n            current = {\n                parent: aParent.parent,\n                a: aParent.index,\n                b: bParent.index\n            };\n        }\n        else {\n            break;\n        }\n    }\n    return current;\n}\nfunction getParentChain(node) {\n    const chain = [];\n    while (node.container) {\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent,\n            index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n//# sourceMappingURL=cst-utils.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\nimport { inRange } from './cst-utils.js';\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nexport function linkContentToContainer(node) {\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    if (isAstNode(item)) {\n                        item.$container = node;\n                        item.$containerProperty = name;\n                        item.$containerIndex = index;\n                    }\n                });\n            }\n            else if (isAstNode(value)) {\n                value.$container = node;\n                value.$containerProperty = name;\n            }\n        }\n    }\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nexport function getContainerOfType(node, typePredicate) {\n    let item = node;\n    while (item) {\n        if (typePredicate(item)) {\n            return item;\n        }\n        item = item.$container;\n    }\n    return undefined;\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nexport function hasContainerOfType(node, predicate) {\n    let item = node;\n    while (item) {\n        if (predicate(item)) {\n            return true;\n        }\n        item = item.$container;\n    }\n    return false;\n}\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nexport function getDocument(node) {\n    const rootNode = findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) {\n        throw new Error('AST node has no document.');\n    }\n    return result;\n}\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nexport function findRootNode(node) {\n    while (node.$container) {\n        node = node.$container;\n    }\n    return node;\n}\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamContents(node, options) {\n    if (!node) {\n        throw new Error('Node must be an AstNode.');\n    }\n    const range = options === null || options === void 0 ? void 0 : options.range;\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if (isAstNode(value)) {\n                    state.keyIndex++;\n                    if (isAstNodeInRange(value, range)) {\n                        return { done: false, value };\n                    }\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\n                            return { done: false, value: element };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nexport function streamAllContents(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options));\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamAst(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {\n        // Return an empty stream if the root node isn't in range\n        return new TreeStreamImpl(root, () => []);\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\n}\nfunction isAstNodeInRange(astNode, range) {\n    var _a;\n    if (!range) {\n        return true;\n    }\n    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n    if (!nodeRange) {\n        return false;\n    }\n    return inRange(nodeRange, range);\n}\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamReferences(node) {\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if (isReference(value)) {\n                    state.keyIndex++;\n                    return { done: false, value: { reference: value, container: node, property } };\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isReference(element)) {\n                            return { done: false, value: { reference: element, container: node, property, index } };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nexport function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {\n    const refs = [];\n    streamAst(lookup).forEach(node => {\n        streamReferences(node).forEach(refInfo => {\n            if (refInfo.reference.ref === targetNode) {\n                refs.push(refInfo.reference);\n            }\n        });\n    });\n    return stream(refs);\n}\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nexport function assignMandatoryProperties(reflection, node) {\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\n    const genericNode = node;\n    for (const property of typeMetaData.properties) {\n        // Only set the value if the property is not already set and if it has a default value\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\n        }\n    }\n}\nfunction copyDefaultValue(propertyType) {\n    if (Array.isArray(propertyType)) {\n        return [...propertyType.map(copyDefaultValue)];\n    }\n    else {\n        return propertyType;\n    }\n}\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nexport function copyAstNode(node, buildReference) {\n    const copy = { $type: node.$type };\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (isAstNode(value)) {\n                copy[name] = copyAstNode(value, buildReference);\n            }\n            else if (isReference(value)) {\n                copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n            }\n            else if (Array.isArray(value)) {\n                const copiedArray = [];\n                for (const element of value) {\n                    if (isAstNode(element)) {\n                        copiedArray.push(copyAstNode(element, buildReference));\n                    }\n                    else if (isReference(element)) {\n                        copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n                    }\n                    else {\n                        copiedArray.push(element);\n                    }\n                }\n                copy[name] = copiedArray;\n            }\n            else {\n                copy[name] = value;\n            }\n        }\n    }\n    linkContentToContainer(copy);\n    return copy;\n}\n//# sourceMappingURL=ast-utils.js.map","import baseRest from './_baseRest.js';\nimport eq from './eq.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport keysIn from './keysIn.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nexport default defaults;\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  MermaidGeneratedSharedModule,\n  PacketGeneratedModule,\n  __name\n} from \"./chunk-FPAJGGOC.mjs\";\n\n// src/language/packet/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/packet/tokenBuilder.ts\nvar PacketTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PacketTokenBuilder\");\n  }\n  constructor() {\n    super([\"packet\"]);\n  }\n};\n\n// src/language/packet/module.ts\nvar PacketModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PacketTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPacketServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Packet = inject(\n    createDefaultCoreModule({ shared }),\n    PacketGeneratedModule,\n    PacketModule\n  );\n  shared.ServiceRegistry.register(Packet);\n  return { shared, Packet };\n}\n__name(createPacketServices, \"createPacketServices\");\n\nexport {\n  PacketModule,\n  createPacketServices\n};\n","import {\n  GitGraphModule,\n  createGitGraphServices\n} from \"./chunks/mermaid-parser.core/chunk-S6J4BHB3.mjs\";\nimport {\n  InfoModule,\n  createInfoServices\n} from \"./chunks/mermaid-parser.core/chunk-LBM3YZW2.mjs\";\nimport {\n  PacketModule,\n  createPacketServices\n} from \"./chunks/mermaid-parser.core/chunk-76Q3JFCE.mjs\";\nimport {\n  PieModule,\n  createPieServices\n} from \"./chunks/mermaid-parser.core/chunk-T53DSG4Q.mjs\";\nimport {\n  ArchitectureModule,\n  createArchitectureServices\n} from \"./chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs\";\nimport {\n  RadarModule,\n  createRadarServices\n} from \"./chunks/mermaid-parser.core/chunk-LHMN2FUI.mjs\";\nimport {\n  TreemapModule,\n  createTreemapServices\n} from \"./chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs\";\nimport {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  Architecture,\n  ArchitectureGeneratedModule,\n  Branch,\n  Commit,\n  CommonTokenBuilder,\n  CommonValueConverter,\n  GitGraph,\n  GitGraphGeneratedModule,\n  Info,\n  InfoGeneratedModule,\n  Merge,\n  MermaidGeneratedSharedModule,\n  Packet,\n  PacketBlock,\n  PacketGeneratedModule,\n  Pie,\n  PieGeneratedModule,\n  PieSection,\n  Radar,\n  RadarGeneratedModule,\n  Statement,\n  Treemap,\n  TreemapGeneratedModule,\n  __name,\n  isArchitecture,\n  isBranch,\n  isCommit,\n  isGitGraph,\n  isInfo,\n  isMerge,\n  isPacket,\n  isPacketBlock,\n  isPie,\n  isPieSection,\n  isTreemap\n} from \"./chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs\";\n\n// src/parse.ts\nvar parsers = {};\nvar initializers = {\n  info: /* @__PURE__ */ __name(async () => {\n    const { createInfoServices: createInfoServices2 } = await import(\"./chunks/mermaid-parser.core/info-NVLQJR56.mjs\");\n    const parser = createInfoServices2().Info.parser.LangiumParser;\n    parsers.info = parser;\n  }, \"info\"),\n  packet: /* @__PURE__ */ __name(async () => {\n    const { createPacketServices: createPacketServices2 } = await import(\"./chunks/mermaid-parser.core/packet-BFZMPI3H.mjs\");\n    const parser = createPacketServices2().Packet.parser.LangiumParser;\n    parsers.packet = parser;\n  }, \"packet\"),\n  pie: /* @__PURE__ */ __name(async () => {\n    const { createPieServices: createPieServices2 } = await import(\"./chunks/mermaid-parser.core/pie-7BOR55EZ.mjs\");\n    const parser = createPieServices2().Pie.parser.LangiumParser;\n    parsers.pie = parser;\n  }, \"pie\"),\n  architecture: /* @__PURE__ */ __name(async () => {\n    const { createArchitectureServices: createArchitectureServices2 } = await import(\"./chunks/mermaid-parser.core/architecture-U656AL7Q.mjs\");\n    const parser = createArchitectureServices2().Architecture.parser.LangiumParser;\n    parsers.architecture = parser;\n  }, \"architecture\"),\n  gitGraph: /* @__PURE__ */ __name(async () => {\n    const { createGitGraphServices: createGitGraphServices2 } = await import(\"./chunks/mermaid-parser.core/gitGraph-F6HP7TQM.mjs\");\n    const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;\n    parsers.gitGraph = parser;\n  }, \"gitGraph\"),\n  radar: /* @__PURE__ */ __name(async () => {\n    const { createRadarServices: createRadarServices2 } = await import(\"./chunks/mermaid-parser.core/radar-NHE76QYJ.mjs\");\n    const parser = createRadarServices2().Radar.parser.LangiumParser;\n    parsers.radar = parser;\n  }, \"radar\"),\n  treemap: /* @__PURE__ */ __name(async () => {\n    const { createTreemapServices: createTreemapServices2 } = await import(\"./chunks/mermaid-parser.core/treemap-KMMF4GRG.mjs\");\n    const parser = createTreemapServices2().Treemap.parser.LangiumParser;\n    parsers.treemap = parser;\n  }, \"treemap\")\n};\nasync function parse(diagramType, text) {\n  const initializer = initializers[diagramType];\n  if (!initializer) {\n    throw new Error(`Unknown diagram type: ${diagramType}`);\n  }\n  if (!parsers[diagramType]) {\n    await initializer();\n  }\n  const parser = parsers[diagramType];\n  const result = parser.parse(text);\n  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {\n    throw new MermaidParseError(result);\n  }\n  return result.value;\n}\n__name(parse, \"parse\");\nvar MermaidParseError = class extends Error {\n  constructor(result) {\n    const lexerErrors = result.lexerErrors.map((err) => err.message).join(\"\\n\");\n    const parserErrors = result.parserErrors.map((err) => err.message).join(\"\\n\");\n    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n    this.result = result;\n  }\n  static {\n    __name(this, \"MermaidParseError\");\n  }\n};\nexport {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  Architecture,\n  ArchitectureGeneratedModule,\n  ArchitectureModule,\n  Branch,\n  Commit,\n  CommonTokenBuilder,\n  CommonValueConverter,\n  GitGraph,\n  GitGraphGeneratedModule,\n  GitGraphModule,\n  Info,\n  InfoGeneratedModule,\n  InfoModule,\n  Merge,\n  MermaidGeneratedSharedModule,\n  MermaidParseError,\n  Packet,\n  PacketBlock,\n  PacketGeneratedModule,\n  PacketModule,\n  Pie,\n  PieGeneratedModule,\n  PieModule,\n  PieSection,\n  Radar,\n  RadarGeneratedModule,\n  RadarModule,\n  Statement,\n  Treemap,\n  TreemapGeneratedModule,\n  TreemapModule,\n  createArchitectureServices,\n  createGitGraphServices,\n  createInfoServices,\n  createPacketServices,\n  createPieServices,\n  createRadarServices,\n  createTreemapServices,\n  isArchitecture,\n  isBranch,\n  isCommit,\n  isGitGraph,\n  isInfo,\n  isMerge,\n  isPacket,\n  isPacketBlock,\n  isPie,\n  isPieSection,\n  isTreemap,\n  parse\n};\n","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { createDefaultCoreModule, createDefaultSharedCoreModule } from '../default-module.js';\nimport { inject } from '../dependency-injection.js';\nimport * as ast from '../languages/generated/ast.js';\nimport { EmptyFileSystem } from '../workspace/file-system-provider.js';\nimport { URI } from './uri-utils.js';\nconst minimalGrammarModule = {\n    Grammar: () => undefined,\n    LanguageMetaData: () => ({\n        caseInsensitive: false,\n        fileExtensions: ['.langium'],\n        languageId: 'langium'\n    })\n};\nconst minimalSharedGrammarModule = {\n    AstReflection: () => new ast.LangiumGrammarAstReflection()\n};\nfunction createMinimalGrammarServices() {\n    const shared = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);\n    const grammar = inject(createDefaultCoreModule({ shared }), minimalGrammarModule);\n    shared.ServiceRegistry.register(grammar);\n    return grammar;\n}\n/**\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\n * most notably the parser builder which interprets the grammar to create a parser.\n */\nexport function loadGrammarFromJson(json) {\n    var _a;\n    const services = createMinimalGrammarServices();\n    const astNode = services.serializer.JsonSerializer.deserialize(json);\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : 'grammar'}.langium`));\n    return astNode;\n}\n//# sourceMappingURL=grammar-loader.js.map","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/language/generated/ast.ts\nimport { AbstractAstReflection } from \"langium\";\nvar Statement = \"Statement\";\nvar Architecture = \"Architecture\";\nfunction isArchitecture(item) {\n  return reflection.isInstance(item, Architecture);\n}\n__name(isArchitecture, \"isArchitecture\");\nvar Axis = \"Axis\";\nvar Branch = \"Branch\";\nfunction isBranch(item) {\n  return reflection.isInstance(item, Branch);\n}\n__name(isBranch, \"isBranch\");\nvar Checkout = \"Checkout\";\nvar CherryPicking = \"CherryPicking\";\nvar ClassDefStatement = \"ClassDefStatement\";\nvar Commit = \"Commit\";\nfunction isCommit(item) {\n  return reflection.isInstance(item, Commit);\n}\n__name(isCommit, \"isCommit\");\nvar Curve = \"Curve\";\nvar Edge = \"Edge\";\nvar Entry = \"Entry\";\nvar GitGraph = \"GitGraph\";\nfunction isGitGraph(item) {\n  return reflection.isInstance(item, GitGraph);\n}\n__name(isGitGraph, \"isGitGraph\");\nvar Group = \"Group\";\nvar Info = \"Info\";\nfunction isInfo(item) {\n  return reflection.isInstance(item, Info);\n}\n__name(isInfo, \"isInfo\");\nvar Item = \"Item\";\nvar Junction = \"Junction\";\nvar Merge = \"Merge\";\nfunction isMerge(item) {\n  return reflection.isInstance(item, Merge);\n}\n__name(isMerge, \"isMerge\");\nvar Option = \"Option\";\nvar Packet = \"Packet\";\nfunction isPacket(item) {\n  return reflection.isInstance(item, Packet);\n}\n__name(isPacket, \"isPacket\");\nvar PacketBlock = \"PacketBlock\";\nfunction isPacketBlock(item) {\n  return reflection.isInstance(item, PacketBlock);\n}\n__name(isPacketBlock, \"isPacketBlock\");\nvar Pie = \"Pie\";\nfunction isPie(item) {\n  return reflection.isInstance(item, Pie);\n}\n__name(isPie, \"isPie\");\nvar PieSection = \"PieSection\";\nfunction isPieSection(item) {\n  return reflection.isInstance(item, PieSection);\n}\n__name(isPieSection, \"isPieSection\");\nvar Radar = \"Radar\";\nvar Service = \"Service\";\nvar Treemap = \"Treemap\";\nfunction isTreemap(item) {\n  return reflection.isInstance(item, Treemap);\n}\n__name(isTreemap, \"isTreemap\");\nvar TreemapRow = \"TreemapRow\";\nvar Direction = \"Direction\";\nvar Leaf = \"Leaf\";\nvar Section = \"Section\";\nvar MermaidAstReflection = class extends AbstractAstReflection {\n  static {\n    __name(this, \"MermaidAstReflection\");\n  }\n  getAllTypes() {\n    return [Architecture, Axis, Branch, Checkout, CherryPicking, ClassDefStatement, Commit, Curve, Direction, Edge, Entry, GitGraph, Group, Info, Item, Junction, Leaf, Merge, Option, Packet, PacketBlock, Pie, PieSection, Radar, Section, Service, Statement, Treemap, TreemapRow];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Branch:\n      case Checkout:\n      case CherryPicking:\n      case Commit:\n      case Merge: {\n        return this.isSubtype(Statement, supertype);\n      }\n      case Direction: {\n        return this.isSubtype(GitGraph, supertype);\n      }\n      case Leaf:\n      case Section: {\n        return this.isSubtype(Item, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      case \"Entry:axis\": {\n        return Axis;\n      }\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case Architecture: {\n        return {\n          name: Architecture,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"edges\", defaultValue: [] },\n            { name: \"groups\", defaultValue: [] },\n            { name: \"junctions\", defaultValue: [] },\n            { name: \"services\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Axis: {\n        return {\n          name: Axis,\n          properties: [\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Branch: {\n        return {\n          name: Branch,\n          properties: [\n            { name: \"name\" },\n            { name: \"order\" }\n          ]\n        };\n      }\n      case Checkout: {\n        return {\n          name: Checkout,\n          properties: [\n            { name: \"branch\" }\n          ]\n        };\n      }\n      case CherryPicking: {\n        return {\n          name: CherryPicking,\n          properties: [\n            { name: \"id\" },\n            { name: \"parent\" },\n            { name: \"tags\", defaultValue: [] }\n          ]\n        };\n      }\n      case ClassDefStatement: {\n        return {\n          name: ClassDefStatement,\n          properties: [\n            { name: \"className\" },\n            { name: \"styleText\" }\n          ]\n        };\n      }\n      case Commit: {\n        return {\n          name: Commit,\n          properties: [\n            { name: \"id\" },\n            { name: \"message\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Curve: {\n        return {\n          name: Curve,\n          properties: [\n            { name: \"entries\", defaultValue: [] },\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Edge: {\n        return {\n          name: Edge,\n          properties: [\n            { name: \"lhsDir\" },\n            { name: \"lhsGroup\", defaultValue: false },\n            { name: \"lhsId\" },\n            { name: \"lhsInto\", defaultValue: false },\n            { name: \"rhsDir\" },\n            { name: \"rhsGroup\", defaultValue: false },\n            { name: \"rhsId\" },\n            { name: \"rhsInto\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Entry: {\n        return {\n          name: Entry,\n          properties: [\n            { name: \"axis\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case GitGraph: {\n        return {\n          name: GitGraph,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Group: {\n        return {\n          name: Group,\n          properties: [\n            { name: \"icon\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Info: {\n        return {\n          name: Info,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Item: {\n        return {\n          name: Item,\n          properties: [\n            { name: \"classSelector\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Junction: {\n        return {\n          name: Junction,\n          properties: [\n            { name: \"id\" },\n            { name: \"in\" }\n          ]\n        };\n      }\n      case Merge: {\n        return {\n          name: Merge,\n          properties: [\n            { name: \"branch\" },\n            { name: \"id\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Option: {\n        return {\n          name: Option,\n          properties: [\n            { name: \"name\" },\n            { name: \"value\", defaultValue: false }\n          ]\n        };\n      }\n      case Packet: {\n        return {\n          name: Packet,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"blocks\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PacketBlock: {\n        return {\n          name: PacketBlock,\n          properties: [\n            { name: \"bits\" },\n            { name: \"end\" },\n            { name: \"label\" },\n            { name: \"start\" }\n          ]\n        };\n      }\n      case Pie: {\n        return {\n          name: Pie,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"sections\", defaultValue: [] },\n            { name: \"showData\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PieSection: {\n        return {\n          name: PieSection,\n          properties: [\n            { name: \"label\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case Radar: {\n        return {\n          name: Radar,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"axes\", defaultValue: [] },\n            { name: \"curves\", defaultValue: [] },\n            { name: \"options\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Service: {\n        return {\n          name: Service,\n          properties: [\n            { name: \"icon\" },\n            { name: \"iconText\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Treemap: {\n        return {\n          name: Treemap,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" },\n            { name: \"TreemapRows\", defaultValue: [] }\n          ]\n        };\n      }\n      case TreemapRow: {\n        return {\n          name: TreemapRow,\n          properties: [\n            { name: \"indent\" },\n            { name: \"item\" }\n          ]\n        };\n      }\n      case Direction: {\n        return {\n          name: Direction,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"dir\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Leaf: {\n        return {\n          name: Leaf,\n          properties: [\n            { name: \"classSelector\" },\n            { name: \"name\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case Section: {\n        return {\n          name: Section,\n          properties: [\n            { name: \"classSelector\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n};\nvar reflection = new MermaidAstReflection();\n\n// src/language/generated/grammar.ts\nimport { loadGrammarFromJson } from \"langium\";\nvar loadedInfoGrammar;\nvar InfoGrammar = /* @__PURE__ */ __name(() => loadedInfoGrammar ?? (loadedInfoGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Info\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Info\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"info\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"showInfo\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"FLOAT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+\\\\\\\\.[0-9]+(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"}},{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"([^\\\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*\\\\\"|'([^'\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]([-\\\\\\\\w]*\\\\\\\\w)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[],\"types\":[],\"usedGrammars\":[]}`)), \"InfoGrammar\");\nvar loadedPacketGrammar;\nvar PacketGrammar = /* @__PURE__ */ __name(() => loadedPacketGrammar ?? (loadedPacketGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Packet\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Packet\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"packet\"},{\"$type\":\"Keyword\",\"value\":\"packet-beta\"}]},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PacketBlock\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"start\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"end\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}],\"cardinality\":\"?\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"bits\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]}]},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"FLOAT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+\\\\\\\\.[0-9]+(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"}},{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"([^\\\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*\\\\\"|'([^'\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]([-\\\\\\\\w]*\\\\\\\\w)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[],\"types\":[],\"usedGrammars\":[]}`)), \"PacketGrammar\");\nvar loadedPieGrammar;\nvar PieGrammar = /* @__PURE__ */ __name(() => loadedPieGrammar ?? (loadedPieGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Pie\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Pie\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"pie\"},{\"$type\":\"Assignment\",\"feature\":\"showData\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showData\"},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PieSection\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"FLOAT_PIE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/-?[0-9]+\\\\\\\\.[0-9]+(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT_PIE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/-?(0|[1-9][0-9]*)(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER_PIE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"}},{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"FLOAT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+\\\\\\\\.[0-9]+(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"}},{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"([^\\\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*\\\\\"|'([^'\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]([-\\\\\\\\w]*\\\\\\\\w)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[],\"types\":[],\"usedGrammars\":[]}`)), \"PieGrammar\");\nvar loadedArchitectureGrammar;\nvar ArchitectureGrammar = /* @__PURE__ */ __name(() => loadedArchitectureGrammar ?? (loadedArchitectureGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Architecture\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Architecture\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@23\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"architecture-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@23\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"groups\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"services\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"junctions\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"edges\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"LeftPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"lhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"RightPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Arrow\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"lhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"--\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@29\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"-\"}]}]},{\"$type\":\"Assignment\",\"feature\":\"rhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Group\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"group\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@28\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@29\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Service\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"service\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"iconText\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@28\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@29\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Junction\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"junction\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Edge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"lhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"lhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"rhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"rhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_DIRECTION\",\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"L\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"R\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"T\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"B\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_GROUP\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\{group\\\\\\\\}/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_INTO\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/<|>/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@23\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"FLOAT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+\\\\\\\\.[0-9]+(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"}},{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"([^\\\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*\\\\\"|'([^'\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]([-\\\\\\\\w]*\\\\\\\\w)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\([\\\\\\\\w-:]+\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\[[\\\\\\\\w ]+\\\\\\\\]/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[],\"types\":[],\"usedGrammars\":[]}`)), \"ArchitectureGrammar\");\nvar loadedGitGraphGrammar;\nvar GitGraphGrammar = /* @__PURE__ */ __name(() => loadedGitGraphGrammar ?? (loadedGitGraphGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"GitGraph\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"GitGraph\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Keyword\",\"value\":\":\"}]},{\"$type\":\"Keyword\",\"value\":\"gitGraph:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"statements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Direction\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"dir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"LR\"},{\"$type\":\"Keyword\",\"value\":\"TB\"},{\"$type\":\"Keyword\",\"value\":\"BT\"}]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Commit\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"commit\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"msg:\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"message\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Branch\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"branch\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@24\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"order:\"},{\"$type\":\"Assignment\",\"feature\":\"order\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Merge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"merge\"},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@24\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Checkout\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"checkout\"},{\"$type\":\"Keyword\",\"value\":\"switch\"}]},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@24\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CherryPicking\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"cherry-pick\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"parent:\"},{\"$type\":\"Assignment\",\"feature\":\"parent\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"FLOAT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+\\\\\\\\.[0-9]+(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"}},{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"([^\\\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*\\\\\"|'([^'\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]([-\\\\\\\\w]*\\\\\\\\w)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"name\":\"REFERENCE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\w([-\\\\\\\\./\\\\\\\\w]*[-\\\\\\\\w])?/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[],\"types\":[],\"usedGrammars\":[]}`)), \"GitGraphGrammar\");\nvar loadedRadarGrammar;\nvar RadarGrammar = /* @__PURE__ */ __name(() => loadedRadarGrammar ?? (loadedRadarGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Radar\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Radar\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\"radar-beta:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"axis\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"curve\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Label\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"[\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"]\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Axis\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Curve\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"{\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\"}\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Entries\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"DetailedEntry\",\"returnType\":{\"$ref\":\"#/interfaces@0\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"axis\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@2\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Keyword\",\"value\":\":\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"NumberEntry\",\"returnType\":{\"$ref\":\"#/interfaces@0\"},\"definition\":{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Option\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showLegend\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"ticks\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"max\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"min\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"graticule\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"GRATICULE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"circle\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"polygon\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"FLOAT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+\\\\\\\\.[0-9]+(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*(?!\\\\\\\\.)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"}},{\"$type\":\"TerminalRuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"([^\\\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*\\\\\"|'([^'\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]([-\\\\\\\\w]*\\\\\\\\w)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Entry\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"axis\",\"isOptional\":true,\"type\":{\"$type\":\"ReferenceType\",\"referenceType\":{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@2\"}}}},{\"$type\":\"TypeAttribute\",\"name\":\"value\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"number\"},\"isOptional\":false}],\"superTypes\":[]}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"types\":[],\"usedGrammars\":[]}`)), \"RadarGrammar\");\nvar loadedTreemapGrammar;\nvar TreemapGrammar = /* @__PURE__ */ __name(() => loadedTreemapGrammar ?? (loadedTreemapGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Treemap\",\"rules\":[{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Treemap\",\"returnType\":{\"$ref\":\"#/interfaces@4\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"TreemapRows\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"TREEMAP_KEYWORD\",\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"treemap-beta\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"treemap\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"CLASS_DEF\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/classDef\\\\\\\\s+([a-zA-Z_][a-zA-Z0-9_]+)(?:\\\\\\\\s+([^;\\\\\\\\r\\\\\\\\n]*))?(?:;)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STYLE_SEPARATOR\",\"definition\":{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\":::\"}},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"SEPARATOR\",\"definition\":{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\":\"}},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"COMMA\",\"definition\":{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\",\"}},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WS\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[ \\\\\\\\t]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"ML_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\%\\\\\\\\%[^\\\\\\\\n]*/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"NL\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"name\":\"TreemapRow\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"indent\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"item\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ClassDef\",\"dataType\":\"string\",\"definition\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Item\",\"returnType\":{\"$ref\":\"#/interfaces@0\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Section\",\"returnType\":{\"$ref\":\"#/interfaces@1\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@23\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"classSelector\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Leaf\",\"returnType\":{\"$ref\":\"#/interfaces@2\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@23\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[],\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"classSelector\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INDENTATION\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[ \\\\\\\\t]{1,}/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID2\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[a-zA-Z_][a-zA-Z0-9_]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER2\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9_\\\\\\\\.\\\\\\\\,]+/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"MyNumber\",\"dataType\":\"number\",\"definition\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING2\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Item\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"name\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"},\"isOptional\":false},{\"$type\":\"TypeAttribute\",\"name\":\"classSelector\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]},{\"$type\":\"Interface\",\"name\":\"Section\",\"superTypes\":[{\"$ref\":\"#/interfaces@0\"}],\"attributes\":[]},{\"$type\":\"Interface\",\"name\":\"Leaf\",\"superTypes\":[{\"$ref\":\"#/interfaces@0\"}],\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"value\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"number\"},\"isOptional\":false}]},{\"$type\":\"Interface\",\"name\":\"ClassDefStatement\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"className\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"},\"isOptional\":false},{\"$type\":\"TypeAttribute\",\"name\":\"styleText\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"},\"isOptional\":false}],\"superTypes\":[]},{\"$type\":\"Interface\",\"name\":\"Treemap\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"TreemapRows\",\"type\":{\"$type\":\"ArrayType\",\"elementType\":{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@14\"}}},\"isOptional\":false},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[],\"$comment\":\"/**\\\\n * Treemap grammar for Langium\\\\n * Converted from mindmap grammar\\\\n *\\\\n * The ML_COMMENT and NL hidden terminals handle whitespace, comments, and newlines\\\\n * before the treemap keyword, allowing for empty lines and comments before the\\\\n * treemap declaration.\\\\n */\"}`)), \"TreemapGrammar\");\n\n// src/language/generated/module.ts\nvar InfoLanguageMetaData = {\n  languageId: \"info\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PacketLanguageMetaData = {\n  languageId: \"packet\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PieLanguageMetaData = {\n  languageId: \"pie\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar ArchitectureLanguageMetaData = {\n  languageId: \"architecture\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar GitGraphLanguageMetaData = {\n  languageId: \"gitGraph\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar RadarLanguageMetaData = {\n  languageId: \"radar\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar TreemapLanguageMetaData = {\n  languageId: \"treemap\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar MermaidGeneratedSharedModule = {\n  AstReflection: /* @__PURE__ */ __name(() => new MermaidAstReflection(), \"AstReflection\")\n};\nvar InfoGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => InfoGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => InfoLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PacketGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PacketGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PacketLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PieGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PieGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PieLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar ArchitectureGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => ArchitectureGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => ArchitectureLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar GitGraphGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => GitGraphGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => GitGraphLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar RadarGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => RadarGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => RadarLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar TreemapGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => TreemapGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => TreemapLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\n\n// src/language/common/valueConverter.ts\nimport { DefaultValueConverter } from \"langium\";\n\n// src/language/common/matcher.ts\nvar accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\nvar accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\nvar titleRegex = /title([\\t ][^\\n\\r]*|)/;\n\n// src/language/common/valueConverter.ts\nvar rulesRegexes = {\n  ACC_DESCR: accessibilityDescrRegex,\n  ACC_TITLE: accessibilityTitleRegex,\n  TITLE: titleRegex\n};\nvar AbstractMermaidValueConverter = class extends DefaultValueConverter {\n  static {\n    __name(this, \"AbstractMermaidValueConverter\");\n  }\n  runConverter(rule, input, cstNode) {\n    let value = this.runCommonConverter(rule, input, cstNode);\n    if (value === void 0) {\n      value = this.runCustomConverter(rule, input, cstNode);\n    }\n    if (value === void 0) {\n      return super.runConverter(rule, input, cstNode);\n    }\n    return value;\n  }\n  runCommonConverter(rule, input, _cstNode) {\n    const regex = rulesRegexes[rule.name];\n    if (regex === void 0) {\n      return void 0;\n    }\n    const match = regex.exec(input);\n    if (match === null) {\n      return void 0;\n    }\n    if (match[1] !== void 0) {\n      return match[1].trim().replace(/[\\t ]{2,}/gm, \" \");\n    }\n    if (match[2] !== void 0) {\n      return match[2].replace(/^\\s*/gm, \"\").replace(/\\s+$/gm, \"\").replace(/[\\t ]{2,}/gm, \" \").replace(/[\\n\\r]{2,}/gm, \"\\n\");\n    }\n    return void 0;\n  }\n};\nvar CommonValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"CommonValueConverter\");\n  }\n  runCustomConverter(_rule, _input, _cstNode) {\n    return void 0;\n  }\n};\n\n// src/language/common/tokenBuilder.ts\nimport { DefaultTokenBuilder } from \"langium\";\nvar AbstractMermaidTokenBuilder = class extends DefaultTokenBuilder {\n  static {\n    __name(this, \"AbstractMermaidTokenBuilder\");\n  }\n  constructor(keywords) {\n    super();\n    this.keywords = new Set(keywords);\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);\n    tokenTypes.forEach((tokenType) => {\n      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) {\n        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + \"(?:(?=%%)|(?!\\\\S))\");\n      }\n    });\n    return tokenTypes;\n  }\n};\nvar CommonTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"CommonTokenBuilder\");\n  }\n};\n\nexport {\n  __name,\n  Statement,\n  Architecture,\n  isArchitecture,\n  Branch,\n  isBranch,\n  Commit,\n  isCommit,\n  GitGraph,\n  isGitGraph,\n  Info,\n  isInfo,\n  Merge,\n  isMerge,\n  Packet,\n  isPacket,\n  PacketBlock,\n  isPacketBlock,\n  Pie,\n  isPie,\n  PieSection,\n  isPieSection,\n  Radar,\n  Treemap,\n  isTreemap,\n  MermaidGeneratedSharedModule,\n  InfoGeneratedModule,\n  PacketGeneratedModule,\n  PieGeneratedModule,\n  ArchitectureGeneratedModule,\n  GitGraphGeneratedModule,\n  RadarGeneratedModule,\n  TreemapGeneratedModule,\n  AbstractMermaidValueConverter,\n  CommonValueConverter,\n  AbstractMermaidTokenBuilder,\n  CommonTokenBuilder\n};\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nexport default baseLt;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { handle.dispose(); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\n","import isSymbol from './isSymbol.js';\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nexport default baseExtremum;\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  ArchitectureGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-FPAJGGOC.mjs\";\n\n// src/language/architecture/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/architecture/tokenBuilder.ts\nvar ArchitectureTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"ArchitectureTokenBuilder\");\n  }\n  constructor() {\n    super([\"architecture\"]);\n  }\n};\n\n// src/language/architecture/valueConverter.ts\nvar ArchitectureValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"ArchitectureValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name === \"ARCH_ICON\") {\n      return input.replace(/[()]/g, \"\").trim();\n    } else if (rule.name === \"ARCH_TEXT_ICON\") {\n      return input.replace(/[\"()]/g, \"\");\n    } else if (rule.name === \"ARCH_TITLE\") {\n      return input.replace(/[[\\]]/g, \"\").trim();\n    }\n    return void 0;\n  }\n};\n\n// src/language/architecture/module.ts\nvar ArchitectureModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new ArchitectureTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new ArchitectureValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createArchitectureServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Architecture = inject(\n    createDefaultCoreModule({ shared }),\n    ArchitectureGeneratedModule,\n    ArchitectureModule\n  );\n  shared.ServiceRegistry.register(Architecture);\n  return { shared, Architecture };\n}\n__name(createArchitectureServices, \"createArchitectureServices\");\n\nexport {\n  ArchitectureModule,\n  createArchitectureServices\n};\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport var Module;\n(function (Module) {\n    Module.merge = (m1, m2) => _merge(_merge({}, m1), m2);\n})(Module || (Module = {}));\n/**\n * Given a set of modules, the inject function returns a lazily evaluated injector\n * that injects dependencies into the requested service when it is requested the\n * first time. Subsequent requests will return the same service.\n *\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\n * by injecting a provider `() => T` instead of a `T`.\n *\n * Please note that the arguments may be objects or arrays. However, the result will\n * be an object. Using it with for..of will have no effect.\n *\n * @param module1 first Module\n * @param module2 (optional) second Module\n * @param module3 (optional) third Module\n * @param module4 (optional) fourth Module\n * @param module5 (optional) fifth Module\n * @param module6 (optional) sixth Module\n * @param module7 (optional) seventh Module\n * @param module8 (optional) eighth Module\n * @param module9 (optional) ninth Module\n * @returns a new object of type I\n */\nexport function inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});\n    return _inject(module);\n}\nconst isProxy = Symbol('isProxy');\n/**\n * Eagerly load all services in the given dependency injection container. This is sometimes\n * necessary because services can register event listeners in their constructors.\n */\nexport function eagerLoad(item) {\n    if (item && item[isProxy]) {\n        for (const value of Object.values(item)) {\n            eagerLoad(value);\n        }\n    }\n    return item;\n}\n/**\n * Helper function that returns an injector by creating a proxy.\n * Invariant: injector is of type I. If injector is undefined, then T = I.\n */\nfunction _inject(module, injector) {\n    const proxy = new Proxy({}, {\n        deleteProperty: () => false,\n        set: () => {\n            throw new Error('Cannot set property on injected service container');\n        },\n        get: (obj, prop) => {\n            if (prop === isProxy) {\n                return true;\n            }\n            else {\n                return _resolve(obj, prop, module, injector || proxy);\n            }\n        },\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in\n        has: (_, prop) => prop in module, // used by ..in..\n        ownKeys: () => [...Object.getOwnPropertyNames(module)] // used by for..in\n    });\n    return proxy;\n}\n/**\n * Internally used to tag a requested dependency, directly before calling the factory.\n * This allows us to find cycles during instance creation.\n */\nconst __requested__ = Symbol();\n/**\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\n * the module description. The result of service factories is cached. Groups are\n * recursively proxied.\n *\n * @param obj an object holding all group proxies and services\n * @param prop the key of a value within obj\n * @param module an object containing groups and service factories\n * @param injector the first level proxy that provides access to all values\n * @returns the requested value `obj[prop]`\n * @throws Error if a dependency cycle is detected\n */\nfunction _resolve(obj, prop, module, injector) {\n    if (prop in obj) {\n        if (obj[prop] instanceof Error) {\n            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', { cause: obj[prop] });\n        }\n        if (obj[prop] === __requested__) {\n            throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');\n        }\n        return obj[prop];\n    }\n    else if (prop in module) {\n        const value = module[prop];\n        obj[prop] = __requested__;\n        try {\n            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);\n        }\n        catch (error) {\n            obj[prop] = error instanceof Error ? error : undefined;\n            throw error;\n        }\n        return obj[prop];\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Performs a deep-merge of two modules by writing source entries into the target module.\n *\n * @param target the module which is written\n * @param source the module which is read\n * @returns the target module\n */\nfunction _merge(target, source) {\n    if (source) {\n        for (const [key, value2] of Object.entries(source)) {\n            if (value2 !== undefined) {\n                const value1 = target[key];\n                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {\n                    target[key] = _merge(value1, value2);\n                }\n                else {\n                    target[key] = value2;\n                }\n            }\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=dependency-injection.js.map","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport map from \"lodash-es/map.js\";\nimport filter from \"lodash-es/filter.js\";\nimport { Alternation, NonTerminal, Option, RepetitionMandatory, Repetition, Terminal, RepetitionWithSeparator, RepetitionMandatoryWithSeparator } from \"chevrotain\";\nexport function buildATNKey(rule, type, occurrence) {\n    return `${rule.name}_${type}_${occurrence}`;\n}\nexport const ATN_INVALID_TYPE = 0;\nexport const ATN_BASIC = 1;\nexport const ATN_RULE_START = 2;\nexport const ATN_PLUS_BLOCK_START = 4;\nexport const ATN_STAR_BLOCK_START = 5;\n// Currently unused as the ATN is not used for lexing\nexport const ATN_TOKEN_START = 6;\nexport const ATN_RULE_STOP = 7;\nexport const ATN_BLOCK_END = 8;\nexport const ATN_STAR_LOOP_BACK = 9;\nexport const ATN_STAR_LOOP_ENTRY = 10;\nexport const ATN_PLUS_LOOP_BACK = 11;\nexport const ATN_LOOP_END = 12;\nexport class AbstractTransition {\n    constructor(target) {\n        this.target = target;\n    }\n    isEpsilon() {\n        return false;\n    }\n}\nexport class AtomTransition extends AbstractTransition {\n    constructor(target, tokenType) {\n        super(target);\n        this.tokenType = tokenType;\n    }\n}\nexport class EpsilonTransition extends AbstractTransition {\n    constructor(target) {\n        super(target);\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nexport class RuleTransition extends AbstractTransition {\n    constructor(ruleStart, rule, followState) {\n        super(ruleStart);\n        this.rule = rule;\n        this.followState = followState;\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nexport function createATN(rules) {\n    const atn = {\n        decisionMap: {},\n        decisionStates: [],\n        ruleToStartState: new Map(),\n        ruleToStopState: new Map(),\n        states: []\n    };\n    createRuleStartAndStopATNStates(atn, rules);\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const ruleBlock = block(atn, rule, rule);\n        if (ruleBlock === undefined) {\n            continue;\n        }\n        buildRuleHandle(atn, rule, ruleBlock);\n    }\n    return atn;\n}\nfunction createRuleStartAndStopATNStates(atn, rules) {\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const start = newState(atn, rule, undefined, {\n            type: ATN_RULE_START\n        });\n        const stop = newState(atn, rule, undefined, {\n            type: ATN_RULE_STOP\n        });\n        start.stop = stop;\n        atn.ruleToStartState.set(rule, start);\n        atn.ruleToStopState.set(rule, stop);\n    }\n}\nfunction atom(atn, rule, production) {\n    if (production instanceof Terminal) {\n        return tokenRef(atn, rule, production.terminalType, production);\n    }\n    else if (production instanceof NonTerminal) {\n        return ruleRef(atn, rule, production);\n    }\n    else if (production instanceof Alternation) {\n        return alternation(atn, rule, production);\n    }\n    else if (production instanceof Option) {\n        return option(atn, rule, production);\n    }\n    else if (production instanceof Repetition) {\n        return repetition(atn, rule, production);\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return repetitionSep(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return repetitionMandatory(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return repetitionMandatorySep(atn, rule, production);\n    }\n    else {\n        return block(atn, rule, production);\n    }\n}\nfunction repetition(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    return star(atn, rule, repetition, handle);\n}\nfunction repetitionSep(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return star(atn, rule, repetition, handle, sep);\n}\nfunction repetitionMandatory(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    return plus(atn, rule, repetition, handle);\n}\nfunction repetitionMandatorySep(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return plus(atn, rule, repetition, handle, sep);\n}\nfunction alternation(atn, rule, alternation) {\n    const start = newState(atn, rule, alternation, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const alts = map(alternation.definition, (e) => atom(atn, rule, e));\n    const handle = makeAlts(atn, rule, start, alternation, ...alts);\n    return handle;\n}\nfunction option(atn, rule, option) {\n    const start = newState(atn, rule, option, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));\n    return optional(atn, rule, option, handle);\n}\nfunction block(atn, rule, block) {\n    const handles = filter(map(block.definition, (e) => atom(atn, rule, e)), (e) => e !== undefined);\n    if (handles.length === 1) {\n        return handles[0];\n    }\n    else if (handles.length === 0) {\n        return undefined;\n    }\n    else {\n        return makeBlock(atn, handles);\n    }\n}\nfunction plus(atn, rule, plus, handle, sep) {\n    const blkStart = handle.left;\n    const blkEnd = handle.right;\n    const loop = newState(atn, rule, plus, {\n        type: ATN_PLUS_LOOP_BACK\n    });\n    defineDecisionState(atn, loop);\n    const end = newState(atn, rule, plus, {\n        type: ATN_LOOP_END\n    });\n    blkStart.loopback = loop;\n    end.loopback = loop;\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;\n    epsilon(blkEnd, loop); // block can see loop back\n    // Depending on whether we have a separator we put the exit transition at index 1 or 0\n    // This influences the chosen option in the lookahead DFA\n    if (sep === undefined) {\n        epsilon(loop, blkStart); // loop back to start\n        epsilon(loop, end); // exit\n    }\n    else {\n        epsilon(loop, end); // exit\n        // loop back to start with separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, blkStart);\n    }\n    return {\n        left: blkStart,\n        right: end\n    };\n}\nfunction star(atn, rule, star, handle, sep) {\n    const start = handle.left;\n    const end = handle.right;\n    const entry = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_ENTRY\n    });\n    defineDecisionState(atn, entry);\n    const loopEnd = newState(atn, rule, star, {\n        type: ATN_LOOP_END\n    });\n    const loop = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_BACK\n    });\n    entry.loopback = loop;\n    loopEnd.loopback = loop;\n    epsilon(entry, start); // loop enter edge (alt 2)\n    epsilon(entry, loopEnd); // bypass loop edge (alt 1)\n    epsilon(end, loop); // block end hits loop back\n    if (sep !== undefined) {\n        epsilon(loop, loopEnd); // end loop\n        // loop back to start of handle using separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, start);\n    }\n    else {\n        epsilon(loop, entry); // loop back to entry/exit decision\n    }\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;\n    return {\n        left: entry,\n        right: loopEnd\n    };\n}\nfunction optional(atn, rule, optional, handle) {\n    const start = handle.left;\n    const end = handle.right;\n    epsilon(start, end);\n    atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;\n    return handle;\n}\nfunction defineDecisionState(atn, state) {\n    atn.decisionStates.push(state);\n    state.decision = atn.decisionStates.length - 1;\n    return state.decision;\n}\nfunction makeAlts(atn, rule, start, production, ...alts) {\n    const end = newState(atn, rule, production, {\n        type: ATN_BLOCK_END,\n        start\n    });\n    start.end = end;\n    for (const alt of alts) {\n        if (alt !== undefined) {\n            // hook alts up to decision block\n            epsilon(start, alt.left);\n            epsilon(alt.right, end);\n        }\n        else {\n            epsilon(start, end);\n        }\n    }\n    const handle = {\n        left: start,\n        right: end\n    };\n    atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;\n    return handle;\n}\nfunction getProdType(production) {\n    if (production instanceof Alternation) {\n        return 'Alternation';\n    }\n    else if (production instanceof Option) {\n        return 'Option';\n    }\n    else if (production instanceof Repetition) {\n        return 'Repetition';\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return 'RepetitionWithSeparator';\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return 'RepetitionMandatory';\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return 'RepetitionMandatoryWithSeparator';\n    }\n    else {\n        throw new Error('Invalid production type encountered');\n    }\n}\nfunction makeBlock(atn, alts) {\n    const altsLength = alts.length;\n    for (let i = 0; i < altsLength - 1; i++) {\n        const handle = alts[i];\n        let transition;\n        if (handle.left.transitions.length === 1) {\n            transition = handle.left.transitions[0];\n        }\n        const isRuleTransition = transition instanceof RuleTransition;\n        const ruleTransition = transition;\n        const next = alts[i + 1].left;\n        if (handle.left.type === ATN_BASIC &&\n            handle.right.type === ATN_BASIC &&\n            transition !== undefined &&\n            ((isRuleTransition && ruleTransition.followState === handle.right) ||\n                transition.target === handle.right)) {\n            // we can avoid epsilon edge to next element\n            if (isRuleTransition) {\n                ruleTransition.followState = next;\n            }\n            else {\n                transition.target = next;\n            }\n            removeState(atn, handle.right); // we skipped over this state\n        }\n        else {\n            // need epsilon if previous block's right end node is complex\n            epsilon(handle.right, next);\n        }\n    }\n    const first = alts[0];\n    const last = alts[altsLength - 1];\n    return {\n        left: first.left,\n        right: last.right\n    };\n}\nfunction tokenRef(atn, rule, tokenType, production) {\n    const left = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    addTransition(left, new AtomTransition(right, tokenType));\n    return {\n        left,\n        right\n    };\n}\nfunction ruleRef(atn, currentRule, nonTerminal) {\n    const rule = nonTerminal.referencedRule;\n    const start = atn.ruleToStartState.get(rule);\n    const left = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const call = new RuleTransition(start, rule, right);\n    addTransition(left, call);\n    return {\n        left,\n        right\n    };\n}\nfunction buildRuleHandle(atn, rule, block) {\n    const start = atn.ruleToStartState.get(rule);\n    epsilon(start, block.left);\n    const stop = atn.ruleToStopState.get(rule);\n    epsilon(block.right, stop);\n    const handle = {\n        left: start,\n        right: stop\n    };\n    return handle;\n}\nfunction epsilon(a, b) {\n    const transition = new EpsilonTransition(b);\n    addTransition(a, transition);\n}\nfunction newState(atn, rule, production, partial) {\n    const t = Object.assign({ atn,\n        production, epsilonOnlyTransitions: false, rule, transitions: [], nextTokenWithinRule: [], stateNumber: atn.states.length }, partial);\n    atn.states.push(t);\n    return t;\n}\nfunction addTransition(state, transition) {\n    // A single ATN state can only contain epsilon transitions or non-epsilon transitions\n    // Because they are never mixed, only setting the property for the first transition is fine\n    if (state.transitions.length === 0) {\n        state.epsilonOnlyTransitions = transition.isEpsilon();\n    }\n    state.transitions.push(transition);\n}\nfunction removeState(atn, state) {\n    atn.states.splice(atn.states.indexOf(state), 1);\n}\n//# sourceMappingURL=atn.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport map from \"lodash-es/map.js\";\nexport const DFA_ERROR = {};\nexport class ATNConfigSet {\n    constructor() {\n        this.map = {};\n        this.configs = [];\n    }\n    get size() {\n        return this.configs.length;\n    }\n    finalize() {\n        // Empties the map to free up memory\n        this.map = {};\n    }\n    add(config) {\n        const key = getATNConfigKey(config);\n        // Only add configs which don't exist in our map already\n        // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption\n        if (!(key in this.map)) {\n            this.map[key] = this.configs.length;\n            this.configs.push(config);\n        }\n    }\n    get elements() {\n        return this.configs;\n    }\n    get alts() {\n        return map(this.configs, (e) => e.alt);\n    }\n    get key() {\n        let value = \"\";\n        for (const k in this.map) {\n            value += k + \":\";\n        }\n        return value;\n    }\n}\nexport function getATNConfigKey(config, alt = true) {\n    return `${alt ? `a${config.alt}` : \"\"}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join(\"_\")}`;\n}\n//# sourceMappingURL=dfa.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { tokenMatcher, tokenLabel, NonTerminal, Alternation, Option, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Repetition, Terminal, LLkLookaheadStrategy, getLookaheadPaths } from \"chevrotain\";\nimport { ATN_RULE_STOP, AtomTransition, buildATNKey, createATN, EpsilonTransition, RuleTransition } from \"./atn.js\";\nimport { ATNConfigSet, DFA_ERROR, getATNConfigKey } from \"./dfa.js\";\nimport min from \"lodash-es/min.js\";\nimport flatMap from \"lodash-es/flatMap.js\";\nimport uniqBy from \"lodash-es/uniqBy.js\";\nimport map from \"lodash-es/map.js\";\nimport flatten from \"lodash-es/flatten.js\";\nimport forEach from \"lodash-es/forEach.js\";\nimport isEmpty from \"lodash-es/isEmpty.js\";\nimport reduce from \"lodash-es/reduce.js\";\nfunction createDFACache(startState, decision) {\n    const map = {};\n    return (predicateSet) => {\n        const key = predicateSet.toString();\n        let existing = map[key];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            existing = {\n                atnStartState: startState,\n                decision,\n                states: {}\n            };\n            map[key] = existing;\n            return existing;\n        }\n    };\n}\nclass PredicateSet {\n    constructor() {\n        this.predicates = [];\n    }\n    is(index) {\n        return index >= this.predicates.length || this.predicates[index];\n    }\n    set(index, value) {\n        this.predicates[index] = value;\n    }\n    toString() {\n        let value = \"\";\n        const size = this.predicates.length;\n        for (let i = 0; i < size; i++) {\n            value += this.predicates[i] === true ? \"1\" : \"0\";\n        }\n        return value;\n    }\n}\nconst EMPTY_PREDICATES = new PredicateSet();\nexport class LLStarLookaheadStrategy extends LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        super();\n        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : ((message) => console.log(message));\n    }\n    initialize(options) {\n        this.atn = createATN(options.rules);\n        this.dfas = initATNSimulator(this.atn);\n    }\n    validateAmbiguousAlternationAlternatives() {\n        return [];\n    }\n    validateEmptyOrAlternatives() {\n        return [];\n    }\n    buildLookaheadForAlternation(options) {\n        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, 'Alternation', prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const partialAlts = map(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType: \"Alternation\",\n            rule: rule\n        }), (currAlt) => map(currAlt, (path) => path[0]));\n        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n            const choiceToAlt = reduce(partialAlts, (result, currAlt, idx) => {\n                forEach(currAlt, (currTokType) => {\n                    if (currTokType) {\n                        result[currTokType.tokenTypeIdx] = idx;\n                        forEach(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = idx;\n                        });\n                    }\n                });\n                return result;\n            }, {});\n            if (hasPredicates) {\n                return function (orAlts) {\n                    var _a;\n                    const nextToken = this.LA(1);\n                    const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n                    if (orAlts !== undefined && prediction !== undefined) {\n                        const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;\n                        if (gate !== undefined && gate.call(this) === false) {\n                            return undefined;\n                        }\n                    }\n                    return prediction;\n                };\n            }\n            else {\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx];\n                };\n            }\n        }\n        else if (hasPredicates) {\n            return function (orAlts) {\n                const predicates = new PredicateSet();\n                const length = orAlts === undefined ? 0 : orAlts.length;\n                for (let i = 0; i < length; i++) {\n                    const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n                    predicates.set(i, gate === undefined || gate.call(this));\n                }\n                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n        else {\n            return function () {\n                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n    }\n    buildLookaheadForOptional(options) {\n        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, prodType, prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const alts = map(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType,\n            rule\n        }), (e) => {\n            return map(e, (g) => g[0]);\n        });\n        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n            const alt = alts[0];\n            const singleTokensTypes = flatten(alt);\n            if (singleTokensTypes.length === 1 &&\n                isEmpty(singleTokensTypes[0].categoryMatches)) {\n                const expectedTokenType = singleTokensTypes[0];\n                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n                return function () {\n                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n                };\n            }\n            else {\n                const choiceToAlt = reduce(singleTokensTypes, (result, currTokType) => {\n                    if (currTokType !== undefined) {\n                        result[currTokType.tokenTypeIdx] = true;\n                        forEach(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = true;\n                        });\n                    }\n                    return result;\n                }, {});\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx] === true;\n                };\n            }\n        }\n        return function () {\n            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n            return typeof result === \"object\" ? false : result === 0;\n        };\n    }\n}\nfunction isLL1Sequence(sequences, allowEmpty = true) {\n    const fullSet = new Set();\n    for (const alt of sequences) {\n        const altSet = new Set();\n        for (const tokType of alt) {\n            if (tokType === undefined) {\n                if (allowEmpty) {\n                    // Epsilon production encountered\n                    break;\n                }\n                else {\n                    return false;\n                }\n            }\n            const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);\n            for (const index of indices) {\n                if (fullSet.has(index)) {\n                    if (!altSet.has(index)) {\n                        return false;\n                    }\n                }\n                else {\n                    fullSet.add(index);\n                    altSet.add(index);\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction initATNSimulator(atn) {\n    const decisionLength = atn.decisionStates.length;\n    const decisionToDFA = Array(decisionLength);\n    for (let i = 0; i < decisionLength; i++) {\n        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);\n    }\n    return decisionToDFA;\n}\nfunction adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n    const dfa = dfaCaches[decision](predicateSet);\n    let start = dfa.start;\n    if (start === undefined) {\n        const closure = computeStartState(dfa.atnStartState);\n        start = addDFAState(dfa, newDFAState(closure));\n        dfa.start = start;\n    }\n    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);\n    return alt;\n}\nfunction performLookahead(dfa, s0, predicateSet, logging) {\n    let previousD = s0;\n    let i = 1;\n    const path = [];\n    let t = this.LA(i++);\n    while (true) {\n        let d = getExistingTargetState(previousD, t);\n        if (d === undefined) {\n            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);\n        }\n        if (d === DFA_ERROR) {\n            return buildAdaptivePredictError(path, previousD, t);\n        }\n        if (d.isAcceptState === true) {\n            return d.prediction;\n        }\n        previousD = d;\n        path.push(t);\n        t = this.LA(i++);\n    }\n}\nfunction computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n    const reach = computeReachSet(previousD.configs, token, predicateSet);\n    if (reach.size === 0) {\n        addDFAEdge(dfa, previousD, token, DFA_ERROR);\n        return DFA_ERROR;\n    }\n    let newState = newDFAState(reach);\n    const predictedAlt = getUniqueAlt(reach, predicateSet);\n    if (predictedAlt !== undefined) {\n        newState.isAcceptState = true;\n        newState.prediction = predictedAlt;\n        newState.configs.uniqueAlt = predictedAlt;\n    }\n    else if (hasConflictTerminatingPrediction(reach)) {\n        const prediction = min(reach.alts);\n        newState.isAcceptState = true;\n        newState.prediction = prediction;\n        newState.configs.uniqueAlt = prediction;\n        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);\n    }\n    newState = addDFAEdge(dfa, previousD, token, newState);\n    return newState;\n}\nfunction reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n    const prefixPath = [];\n    for (let i = 1; i <= lookahead; i++) {\n        prefixPath.push(this.LA(i).tokenType);\n    }\n    const atnState = dfa.atnStartState;\n    const topLevelRule = atnState.rule;\n    const production = atnState.production;\n    const message = buildAmbiguityError({\n        topLevelRule,\n        ambiguityIndices,\n        production,\n        prefixPath\n    });\n    logging(message);\n}\nfunction buildAmbiguityError(options) {\n    const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n    const occurrence = options.production.idx === 0 ? \"\" : options.production.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\", \")}> in <${getProductionDslName(options.production)}${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n    currMessage =\n        currMessage +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n            `For Further details.`;\n    return currMessage;\n}\nfunction getProductionDslName(prod) {\n    if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction buildAdaptivePredictError(path, previous, current) {\n    const nextTransitions = flatMap(previous.configs.elements, (e) => e.state.transitions);\n    const nextTokenTypes = uniqBy(nextTransitions\n        .filter((e) => e instanceof AtomTransition)\n        .map((e) => e.tokenType), (e) => e.tokenTypeIdx);\n    return {\n        actualToken: current,\n        possibleTokenTypes: nextTokenTypes,\n        tokenPath: path\n    };\n}\nfunction getExistingTargetState(state, token) {\n    return state.edges[token.tokenTypeIdx];\n}\nfunction computeReachSet(configs, token, predicateSet) {\n    const intermediate = new ATNConfigSet();\n    const skippedStopStates = [];\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === false) {\n            continue;\n        }\n        if (c.state.type === ATN_RULE_STOP) {\n            skippedStopStates.push(c);\n            continue;\n        }\n        const transitionLength = c.state.transitions.length;\n        for (let i = 0; i < transitionLength; i++) {\n            const transition = c.state.transitions[i];\n            const target = getReachableTarget(transition, token);\n            if (target !== undefined) {\n                intermediate.add({\n                    state: target,\n                    alt: c.alt,\n                    stack: c.stack\n                });\n            }\n        }\n    }\n    let reach;\n    if (skippedStopStates.length === 0 && intermediate.size === 1) {\n        reach = intermediate;\n    }\n    if (reach === undefined) {\n        reach = new ATNConfigSet();\n        for (const c of intermediate.elements) {\n            closure(c, reach);\n        }\n    }\n    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\n        for (const c of skippedStopStates) {\n            reach.add(c);\n        }\n    }\n    return reach;\n}\nfunction getReachableTarget(transition, token) {\n    if (transition instanceof AtomTransition &&\n        tokenMatcher(token, transition.tokenType)) {\n        return transition.target;\n    }\n    return undefined;\n}\nfunction getUniqueAlt(configs, predicateSet) {\n    let alt;\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === true) {\n            if (alt === undefined) {\n                alt = c.alt;\n            }\n            else if (alt !== c.alt) {\n                return undefined;\n            }\n        }\n    }\n    return alt;\n}\nfunction newDFAState(closure) {\n    return {\n        configs: closure,\n        edges: {},\n        isAcceptState: false,\n        prediction: -1\n    };\n}\nfunction addDFAEdge(dfa, from, token, to) {\n    to = addDFAState(dfa, to);\n    from.edges[token.tokenTypeIdx] = to;\n    return to;\n}\nfunction addDFAState(dfa, state) {\n    if (state === DFA_ERROR) {\n        return state;\n    }\n    // Repetitions have the same config set\n    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA\n    const mapKey = state.configs.key;\n    const existing = dfa.states[mapKey];\n    if (existing !== undefined) {\n        return existing;\n    }\n    state.configs.finalize();\n    dfa.states[mapKey] = state;\n    return state;\n}\nfunction computeStartState(atnState) {\n    const configs = new ATNConfigSet();\n    const numberOfTransitions = atnState.transitions.length;\n    for (let i = 0; i < numberOfTransitions; i++) {\n        const target = atnState.transitions[i].target;\n        const config = {\n            state: target,\n            alt: i,\n            stack: []\n        };\n        closure(config, configs);\n    }\n    return configs;\n}\nfunction closure(config, configs) {\n    const p = config.state;\n    if (p.type === ATN_RULE_STOP) {\n        if (config.stack.length > 0) {\n            const atnStack = [...config.stack];\n            const followState = atnStack.pop();\n            const followConfig = {\n                state: followState,\n                alt: config.alt,\n                stack: atnStack\n            };\n            closure(followConfig, configs);\n        }\n        else {\n            // Dipping into outer context, simply add the config\n            // This will stop computation once every config is at the rule stop state\n            configs.add(config);\n        }\n        return;\n    }\n    if (!p.epsilonOnlyTransitions) {\n        configs.add(config);\n    }\n    const transitionLength = p.transitions.length;\n    for (let i = 0; i < transitionLength; i++) {\n        const transition = p.transitions[i];\n        const c = getEpsilonTarget(config, transition);\n        if (c !== undefined) {\n            closure(c, configs);\n        }\n    }\n}\nfunction getEpsilonTarget(config, transition) {\n    if (transition instanceof EpsilonTransition) {\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack: config.stack\n        };\n    }\n    else if (transition instanceof RuleTransition) {\n        const stack = [...config.stack, transition.followState];\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack\n        };\n    }\n    return undefined;\n}\nfunction hasConfigInRuleStopState(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type === ATN_RULE_STOP) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction allConfigsInRuleStopStates(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type !== ATN_RULE_STOP) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction hasConflictTerminatingPrediction(configs) {\n    if (allConfigsInRuleStopStates(configs)) {\n        return true;\n    }\n    const altSets = getConflictingAltSets(configs.elements);\n    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);\n    return heuristic;\n}\nfunction getConflictingAltSets(configs) {\n    const configToAlts = new Map();\n    for (const c of configs) {\n        const key = getATNConfigKey(c, false);\n        let alts = configToAlts.get(key);\n        if (alts === undefined) {\n            alts = {};\n            configToAlts.set(key, alts);\n        }\n        alts[c.alt] = true;\n    }\n    return configToAlts;\n}\nfunction hasConflictingAltSet(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length > 1) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hasStateAssociatedWithOneAlt(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length === 1) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=all-star-lookahead.js.map","import baseIteratee from './_baseIteratee.js';\nimport baseUniq from './_baseUniq.js';\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nexport default uniqBy;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Position } from 'vscode-languageserver-types';\nimport { tokenToRange } from '../utils/cst-utils.js';\nexport class CstNodeBuilder {\n    constructor() {\n        this.nodeStack = [];\n    }\n    get current() {\n        var _a;\n        return (_a = this.nodeStack[this.nodeStack.length - 1]) !== null && _a !== void 0 ? _a : this.rootNode;\n    }\n    buildRootNode(input) {\n        this.rootNode = new RootCstNodeImpl(input);\n        this.rootNode.root = this.rootNode;\n        this.nodeStack = [this.rootNode];\n        return this.rootNode;\n    }\n    buildCompositeNode(feature) {\n        const compositeNode = new CompositeCstNodeImpl();\n        compositeNode.grammarSource = feature;\n        compositeNode.root = this.rootNode;\n        this.current.content.push(compositeNode);\n        this.nodeStack.push(compositeNode);\n        return compositeNode;\n    }\n    buildLeafNode(token, feature) {\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);\n        leafNode.grammarSource = feature;\n        leafNode.root = this.rootNode;\n        this.current.content.push(leafNode);\n        return leafNode;\n    }\n    removeNode(node) {\n        const parent = node.container;\n        if (parent) {\n            const index = parent.content.indexOf(node);\n            if (index >= 0) {\n                parent.content.splice(index, 1);\n            }\n        }\n    }\n    addHiddenNodes(tokens) {\n        const nodes = [];\n        for (const token of tokens) {\n            const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n            leafNode.root = this.rootNode;\n            nodes.push(leafNode);\n        }\n        let current = this.current;\n        let added = false;\n        // If we are within a composite node, we add the hidden nodes to the content\n        if (current.content.length > 0) {\n            current.content.push(...nodes);\n            return;\n        }\n        // Otherwise we are at a newly created node\n        // Instead of adding the hidden nodes here, we search for the first parent node with content\n        while (current.container) {\n            const index = current.container.content.indexOf(current);\n            if (index > 0) {\n                // Add the hidden nodes before the current node\n                current.container.content.splice(index, 0, ...nodes);\n                added = true;\n                break;\n            }\n            current = current.container;\n        }\n        // If we arrive at the root node, we add the hidden nodes at the beginning\n        // This is the case if the hidden nodes are the first nodes in the tree\n        if (!added) {\n            this.rootNode.content.unshift(...nodes);\n        }\n    }\n    construct(item) {\n        const current = this.current;\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\n        // Only if the $type is a string, we actually assign the element\n        if (typeof item.$type === 'string') {\n            this.current.astNode = item;\n        }\n        item.$cstNode = current;\n        const node = this.nodeStack.pop();\n        // Empty composite nodes are not valid\n        // Simply remove the node from the tree\n        if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n            this.removeNode(node);\n        }\n    }\n}\nexport class AbstractCstNode {\n    /** @deprecated use `container` instead. */\n    get parent() {\n        return this.container;\n    }\n    /** @deprecated use `grammarSource` instead. */\n    get feature() {\n        return this.grammarSource;\n    }\n    get hidden() {\n        return false;\n    }\n    get astNode() {\n        var _a, _b;\n        const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n        if (!node) {\n            throw new Error('This node has no associated AST element');\n        }\n        return node;\n    }\n    set astNode(value) {\n        this._astNode = value;\n    }\n    /** @deprecated use `astNode` instead. */\n    get element() {\n        return this.astNode;\n    }\n    get text() {\n        return this.root.fullText.substring(this.offset, this.end);\n    }\n}\nexport class LeafCstNodeImpl extends AbstractCstNode {\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return this._length;\n    }\n    get end() {\n        return this._offset + this._length;\n    }\n    get hidden() {\n        return this._hidden;\n    }\n    get tokenType() {\n        return this._tokenType;\n    }\n    get range() {\n        return this._range;\n    }\n    constructor(offset, length, range, tokenType, hidden = false) {\n        super();\n        this._hidden = hidden;\n        this._offset = offset;\n        this._tokenType = tokenType;\n        this._length = length;\n        this._range = range;\n    }\n}\nexport class CompositeCstNodeImpl extends AbstractCstNode {\n    constructor() {\n        super(...arguments);\n        this.content = new CstNodeContainer(this);\n    }\n    /** @deprecated use `content` instead. */\n    get children() {\n        return this.content;\n    }\n    get offset() {\n        var _a, _b;\n        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n    }\n    get length() {\n        return this.end - this.offset;\n    }\n    get end() {\n        var _a, _b;\n        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n    }\n    get range() {\n        const firstNode = this.firstNonHiddenNode;\n        const lastNode = this.lastNonHiddenNode;\n        if (firstNode && lastNode) {\n            if (this._rangeCache === undefined) {\n                const { range: firstRange } = firstNode;\n                const { range: lastRange } = lastNode;\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n            }\n            return this._rangeCache;\n        }\n        else {\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\n        }\n    }\n    get firstNonHiddenNode() {\n        for (const child of this.content) {\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[0];\n    }\n    get lastNonHiddenNode() {\n        for (let i = this.content.length - 1; i >= 0; i--) {\n            const child = this.content[i];\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[this.content.length - 1];\n    }\n}\nclass CstNodeContainer extends Array {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\n    }\n    push(...items) {\n        this.addParents(items);\n        return super.push(...items);\n    }\n    unshift(...items) {\n        this.addParents(items);\n        return super.unshift(...items);\n    }\n    splice(start, count, ...items) {\n        this.addParents(items);\n        return super.splice(start, count, ...items);\n    }\n    addParents(items) {\n        for (const item of items) {\n            item.container = this.parent;\n        }\n    }\n}\nexport class RootCstNodeImpl extends CompositeCstNodeImpl {\n    get text() {\n        return this._text.substring(this.offset, this.end);\n    }\n    get fullText() {\n        return this._text;\n    }\n    constructor(input) {\n        super();\n        this._text = '';\n        this._text = input !== null && input !== void 0 ? input : '';\n    }\n}\n//# sourceMappingURL=cst-node-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { defaultParserErrorProvider, EmbeddedActionsParser, LLkLookaheadStrategy } from 'chevrotain';\nimport { LLStarLookaheadStrategy } from 'chevrotain-allstar';\nimport { isAssignment, isCrossReference, isKeyword } from '../languages/generated/ast.js';\nimport { getExplicitRuleType, isDataTypeRule } from '../utils/grammar-utils.js';\nimport { assignMandatoryProperties, getContainerOfType, linkContentToContainer } from '../utils/ast-utils.js';\nimport { CstNodeBuilder } from './cst-node-builder.js';\nexport const DatatypeSymbol = Symbol('Datatype');\nfunction isDataTypeNode(node) {\n    return node.$type === DatatypeSymbol;\n}\nconst ruleSuffix = '\\u200B';\nconst withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\nexport class AbstractLangiumParser {\n    constructor(services) {\n        this._unorderedGroups = new Map();\n        this.allRules = new Map();\n        this.lexer = services.parser.Lexer;\n        const tokens = this.lexer.definition;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { skipValidations: production, errorMessageProvider: services.parser.ParserErrorMessageProvider }));\n    }\n    alternatives(idx, choices) {\n        this.wrapper.wrapOr(idx, choices);\n    }\n    optional(idx, callback) {\n        this.wrapper.wrapOption(idx, callback);\n    }\n    many(idx, callback) {\n        this.wrapper.wrapMany(idx, callback);\n    }\n    atLeastOne(idx, callback) {\n        this.wrapper.wrapAtLeastOne(idx, callback);\n    }\n    getRule(name) {\n        return this.allRules.get(name);\n    }\n    isRecording() {\n        return this.wrapper.IS_RECORDING;\n    }\n    get unorderedGroups() {\n        return this._unorderedGroups;\n    }\n    getRuleStack() {\n        return this.wrapper.RULE_STACK;\n    }\n    finalize() {\n        this.wrapper.wrapSelfAnalysis();\n    }\n}\nexport class LangiumParser extends AbstractLangiumParser {\n    get current() {\n        return this.stack[this.stack.length - 1];\n    }\n    constructor(services) {\n        super(services);\n        this.nodeBuilder = new CstNodeBuilder();\n        this.stack = [];\n        this.assignmentMap = new Map();\n        this.linker = services.references.Linker;\n        this.converter = services.parser.ValueConverter;\n        this.astReflection = services.shared.AstReflection;\n    }\n    rule(rule, impl) {\n        const type = this.computeRuleType(rule);\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    computeRuleType(rule) {\n        if (rule.fragment) {\n            return undefined;\n        }\n        else if (isDataTypeRule(rule)) {\n            return DatatypeSymbol;\n        }\n        else {\n            const explicit = getExplicitRuleType(rule);\n            return explicit !== null && explicit !== void 0 ? explicit : rule.name;\n        }\n    }\n    parse(input, options = {}) {\n        this.nodeBuilder.buildRootNode(input);\n        const lexerResult = this.lexerResult = this.lexer.tokenize(input);\n        this.wrapper.input = lexerResult.tokens;\n        const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;\n        if (!ruleMethod) {\n            throw new Error(options.rule ? `No rule found with name '${options.rule}'` : 'No main rule available.');\n        }\n        const result = ruleMethod.call(this.wrapper, {});\n        this.nodeBuilder.addHiddenNodes(lexerResult.hidden);\n        this.unorderedGroups.clear();\n        this.lexerResult = undefined;\n        return {\n            value: result,\n            lexerErrors: lexerResult.errors,\n            lexerReport: lexerResult.report,\n            parserErrors: this.wrapper.errors\n        };\n    }\n    startImplementation($type, implementation) {\n        return (args) => {\n            // Only create a new AST node in case the calling rule is not a fragment rule\n            const createNode = !this.isRecording() && $type !== undefined;\n            if (createNode) {\n                const node = { $type };\n                this.stack.push(node);\n                if ($type === DatatypeSymbol) {\n                    node.value = '';\n                }\n            }\n            let result;\n            try {\n                result = implementation(args);\n            }\n            catch (err) {\n                result = undefined;\n            }\n            if (result === undefined && createNode) {\n                result = this.construct();\n            }\n            return result;\n        };\n    }\n    extractHiddenTokens(token) {\n        const hiddenTokens = this.lexerResult.hidden;\n        if (!hiddenTokens.length) {\n            return [];\n        }\n        const offset = token.startOffset;\n        for (let i = 0; i < hiddenTokens.length; i++) {\n            const token = hiddenTokens[i];\n            if (token.startOffset > offset) {\n                return hiddenTokens.splice(0, i);\n            }\n        }\n        return hiddenTokens.splice(0, hiddenTokens.length);\n    }\n    consume(idx, tokenType, feature) {\n        const token = this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording() && this.isValidToken(token)) {\n            const hiddenTokens = this.extractHiddenTokens(token);\n            this.nodeBuilder.addHiddenNodes(hiddenTokens);\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n            const { assignment, isCrossRef } = this.getAssignment(feature);\n            const current = this.current;\n            if (assignment) {\n                const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n            }\n            else if (isDataTypeNode(current)) {\n                let text = token.image;\n                if (!isKeyword(feature)) {\n                    text = this.converter.convert(text, leafNode).toString();\n                }\n                current.value += text;\n            }\n        }\n    }\n    /**\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n     *\n     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n     */\n    isValidToken(token) {\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        let cstNode;\n        if (!this.isRecording() && !fragment) {\n            // We only want to create a new CST node if the subrule actually creates a new AST node.\n            // In other cases like calls of fragment rules the current CST/AST is populated further.\n            // Note that skipping this initialization and leaving cstNode unassigned also skips the subrule assignment later on.\n            // This is intended, as fragment rules only enrich the current AST node\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\n        }\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\n        }\n    }\n    performSubruleAssignment(result, feature, cstNode) {\n        const { assignment, isCrossRef } = this.getAssignment(feature);\n        if (assignment) {\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n        }\n        else if (!assignment) {\n            // If we call a subrule without an assignment we either:\n            // 1. append the result of the subrule (data type rule)\n            // 2. override the current object with the newly parsed object\n            // If the current element is an AST node and the result of the subrule\n            // is a data type rule, we can safely discard the results.\n            const current = this.current;\n            if (isDataTypeNode(current)) {\n                current.value += result.toString();\n            }\n            else if (typeof result === 'object' && result) {\n                const object = this.assignWithoutOverride(result, current);\n                const newItem = object;\n                this.stack.pop();\n                this.stack.push(newItem);\n            }\n        }\n    }\n    action($type, action) {\n        if (!this.isRecording()) {\n            let last = this.current;\n            if (action.feature && action.operator) {\n                last = this.construct();\n                this.nodeBuilder.removeNode(last.$cstNode);\n                const node = this.nodeBuilder.buildCompositeNode(action);\n                node.content.push(last.$cstNode);\n                const newItem = { $type };\n                this.stack.push(newItem);\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\n            }\n            else {\n                last.$type = $type;\n            }\n        }\n    }\n    construct() {\n        if (this.isRecording()) {\n            return undefined;\n        }\n        const obj = this.current;\n        linkContentToContainer(obj);\n        this.nodeBuilder.construct(obj);\n        this.stack.pop();\n        if (isDataTypeNode(obj)) {\n            return this.converter.convert(obj.value, obj.$cstNode);\n        }\n        else {\n            assignMandatoryProperties(this.astReflection, obj);\n        }\n        return obj;\n    }\n    getAssignment(feature) {\n        if (!this.assignmentMap.has(feature)) {\n            const assignment = getContainerOfType(feature, isAssignment);\n            this.assignmentMap.set(feature, {\n                assignment: assignment,\n                isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\n            });\n        }\n        return this.assignmentMap.get(feature);\n    }\n    assign(operator, feature, value, cstNode, isCrossRef) {\n        const obj = this.current;\n        let item;\n        if (isCrossRef && typeof value === 'string') {\n            item = this.linker.buildReference(obj, feature, cstNode, value);\n        }\n        else {\n            item = value;\n        }\n        switch (operator) {\n            case '=': {\n                obj[feature] = item;\n                break;\n            }\n            case '?=': {\n                obj[feature] = true;\n                break;\n            }\n            case '+=': {\n                if (!Array.isArray(obj[feature])) {\n                    obj[feature] = [];\n                }\n                obj[feature].push(item);\n            }\n        }\n    }\n    assignWithoutOverride(target, source) {\n        for (const [name, existingValue] of Object.entries(source)) {\n            const newValue = target[name];\n            if (newValue === undefined) {\n                target[name] = existingValue;\n            }\n            else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n                existingValue.push(...newValue);\n                target[name] = existingValue;\n            }\n        }\n        // The target was parsed from a unassigned subrule\n        // After the subrule construction, it received a cst node\n        // This CST node will later be overriden by the cst node builder\n        // To prevent references to stale AST nodes in the CST,\n        // we need to remove the reference here\n        const targetCstNode = target.$cstNode;\n        if (targetCstNode) {\n            targetCstNode.astNode = undefined;\n            target.$cstNode = undefined;\n        }\n        return target;\n    }\n    get definitionErrors() {\n        return this.wrapper.definitionErrors;\n    }\n}\nexport class AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage(options) {\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options);\n    }\n    buildNotAllInputParsedMessage(options) {\n        return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n    }\n    buildNoViableAltMessage(options) {\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\n    }\n    buildEarlyExitMessage(options) {\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n}\nexport class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage({ expected, actual }) {\n        const expectedMsg = expected.LABEL\n            ? '`' + expected.LABEL + '`'\n            : expected.name.endsWith(':KW')\n                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`\n                : `token of type '${expected.name}'`;\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n    }\n    buildNotAllInputParsedMessage({ firstRedundant }) {\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n    }\n}\nexport class LangiumCompletionParser extends AbstractLangiumParser {\n    constructor() {\n        super(...arguments);\n        this.tokens = [];\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    action() {\n        // NOOP\n    }\n    construct() {\n        // NOOP\n        return undefined;\n    }\n    parse(input) {\n        this.resetState();\n        const tokens = this.lexer.tokenize(input, { mode: 'partial' });\n        this.tokens = tokens.tokens;\n        this.wrapper.input = [...this.tokens];\n        this.mainRule.call(this.wrapper, {});\n        this.unorderedGroups.clear();\n        return {\n            tokens: this.tokens,\n            elementStack: [...this.lastElementStack],\n            tokenIndex: this.nextTokenIndex\n        };\n    }\n    rule(rule, impl) {\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    resetState() {\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    startImplementation(implementation) {\n        return (args) => {\n            const size = this.keepStackSize();\n            try {\n                implementation(args);\n            }\n            finally {\n                this.resetStackSize(size);\n            }\n        };\n    }\n    removeUnexpectedElements() {\n        this.elementStack.splice(this.stackSize);\n    }\n    keepStackSize() {\n        const size = this.elementStack.length;\n        this.stackSize = size;\n        return size;\n    }\n    resetStackSize(size) {\n        this.removeUnexpectedElements();\n        this.stackSize = size;\n    }\n    consume(idx, tokenType, feature) {\n        this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording()) {\n            this.lastElementStack = [...this.elementStack, feature];\n            this.nextTokenIndex = this.currIdx + 1;\n        }\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        this.before(feature);\n        this.wrapper.wrapSubrule(idx, rule, args);\n        this.after(feature);\n    }\n    before(element) {\n        if (!this.isRecording()) {\n            this.elementStack.push(element);\n        }\n    }\n    after(element) {\n        if (!this.isRecording()) {\n            const index = this.elementStack.lastIndexOf(element);\n            if (index >= 0) {\n                this.elementStack.splice(index);\n            }\n        }\n    }\n    get currIdx() {\n        return this.wrapper.currIdx;\n    }\n}\nconst defaultConfig = {\n    recoveryEnabled: true,\n    nodeLocationTracking: 'full',\n    skipValidations: true,\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\n/**\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\n * This way, we can build the `LangiumParser` as a composition.\n */\nclass ChevrotainWrapper extends EmbeddedActionsParser {\n    constructor(tokens, config) {\n        const useDefaultLookahead = config && 'maxLookahead' in config;\n        super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead\n                ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\n                : new LLStarLookaheadStrategy({\n                    // If validations are skipped, don't log the lookahead warnings\n                    logging: config.skipValidations ? () => { } : undefined\n                }) }), config));\n    }\n    get IS_RECORDING() {\n        return this.RECORDING_PHASE;\n    }\n    DEFINE_RULE(name, impl) {\n        return this.RULE(name, impl);\n    }\n    wrapSelfAnalysis() {\n        this.performSelfAnalysis();\n    }\n    wrapConsume(idx, tokenType) {\n        return this.consume(idx, tokenType);\n    }\n    wrapSubrule(idx, rule, args) {\n        return this.subrule(idx, rule, {\n            ARGS: [args]\n        });\n    }\n    wrapOr(idx, choices) {\n        this.or(idx, choices);\n    }\n    wrapOption(idx, callback) {\n        this.option(idx, callback);\n    }\n    wrapMany(idx, callback) {\n        this.many(idx, callback);\n    }\n    wrapAtLeastOne(idx, callback) {\n        this.atLeastOne(idx, callback);\n    }\n}\n//# sourceMappingURL=langium-parser.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_ALT, EOF } from 'chevrotain';\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\nimport { stream } from '../utils/stream.js';\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\nexport function createParser(grammar, parser, tokens) {\n    const parserContext = {\n        parser,\n        tokens,\n        ruleNames: new Map()\n    };\n    buildRules(parserContext, grammar);\n    return parser;\n}\nfunction buildRules(parserContext, grammar) {\n    const reachable = getAllReachableRules(grammar, false);\n    const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\n    for (const rule of parserRules) {\n        const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });\n        parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\n    }\n}\nfunction buildElement(ctx, element, ignoreGuard = false) {\n    let method;\n    if (isKeyword(element)) {\n        method = buildKeyword(ctx, element);\n    }\n    else if (isAction(element)) {\n        method = buildAction(ctx, element);\n    }\n    else if (isAssignment(element)) {\n        method = buildElement(ctx, element.terminal);\n    }\n    else if (isCrossReference(element)) {\n        method = buildCrossReference(ctx, element);\n    }\n    else if (isRuleCall(element)) {\n        method = buildRuleCall(ctx, element);\n    }\n    else if (isAlternatives(element)) {\n        method = buildAlternatives(ctx, element);\n    }\n    else if (isUnorderedGroup(element)) {\n        method = buildUnorderedGroup(ctx, element);\n    }\n    else if (isGroup(element)) {\n        method = buildGroup(ctx, element);\n    }\n    else if (isEndOfFile(element)) {\n        const idx = ctx.consume++;\n        method = () => ctx.parser.consume(idx, EOF, element);\n    }\n    else {\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n    }\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n    const actionType = getTypeName(action);\n    return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n    const rule = ruleCall.rule.ref;\n    if (isParserRule(rule)) {\n        const idx = ctx.subrule++;\n        const fragment = rule.fragment;\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\n    }\n    else if (isTerminalRule(rule)) {\n        const idx = ctx.consume++;\n        const method = getToken(ctx, rule.name);\n        return () => ctx.parser.consume(idx, method, ruleCall);\n    }\n    else if (!rule) {\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\n    }\n    else {\n        assertUnreachable(rule);\n    }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\n    return (args) => {\n        const ruleArgs = {};\n        for (let i = 0; i < predicates.length; i++) {\n            const ruleTarget = rule.parameters[i];\n            const predicate = predicates[i];\n            ruleArgs[ruleTarget.name] = predicate(args);\n        }\n        return ruleArgs;\n    };\n}\nfunction buildPredicate(condition) {\n    if (isDisjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) || right(args));\n    }\n    else if (isConjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) && right(args));\n    }\n    else if (isNegation(condition)) {\n        const value = buildPredicate(condition.value);\n        return (args) => !value(args);\n    }\n    else if (isParameterReference(condition)) {\n        const name = condition.parameter.ref.name;\n        return (args) => args !== undefined && args[name] === true;\n    }\n    else if (isBooleanLiteral(condition)) {\n        const value = Boolean(condition.true);\n        return () => value;\n    }\n    assertUnreachable(condition);\n}\nfunction buildAlternatives(ctx, alternatives) {\n    if (alternatives.elements.length === 1) {\n        return buildElement(ctx, alternatives.elements[0]);\n    }\n    else {\n        const methods = [];\n        for (const element of alternatives.elements) {\n            const predicatedMethod = {\n                // Since we handle the guard condition in the alternative already\n                // We can ignore the group guard condition inside\n                ALT: buildElement(ctx, element, true)\n            };\n            const guard = getGuardCondition(element);\n            if (guard) {\n                predicatedMethod.GATE = buildPredicate(guard);\n            }\n            methods.push(predicatedMethod);\n        }\n        const idx = ctx.or++;\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\n            const alt = {\n                ALT: () => method.ALT(args)\n            };\n            const gate = method.GATE;\n            if (gate) {\n                alt.GATE = () => gate(args);\n            }\n            return alt;\n        }));\n    }\n}\nfunction buildUnorderedGroup(ctx, group) {\n    if (group.elements.length === 1) {\n        return buildElement(ctx, group.elements[0]);\n    }\n    const methods = [];\n    for (const element of group.elements) {\n        const predicatedMethod = {\n            // Since we handle the guard condition in the alternative already\n            // We can ignore the group guard condition inside\n            ALT: buildElement(ctx, element, true)\n        };\n        const guard = getGuardCondition(element);\n        if (guard) {\n            predicatedMethod.GATE = buildPredicate(guard);\n        }\n        methods.push(predicatedMethod);\n    }\n    const orIdx = ctx.or++;\n    const idFunc = (groupIdx, lParser) => {\n        const stackId = lParser.getRuleStack().join('-');\n        return `uGroup_${groupIdx}_${stackId}`;\n    };\n    const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n        const alt = { ALT: () => true };\n        const parser = ctx.parser;\n        alt.ALT = () => {\n            method.ALT(args);\n            if (!parser.isRecording()) {\n                const key = idFunc(orIdx, parser);\n                if (!parser.unorderedGroups.get(key)) {\n                    // init after clear state\n                    parser.unorderedGroups.set(key, []);\n                }\n                const groupState = parser.unorderedGroups.get(key);\n                if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {\n                    // Not accessed yet\n                    groupState[idx] = true;\n                }\n            }\n        };\n        const gate = method.GATE;\n        if (gate) {\n            alt.GATE = () => gate(args);\n        }\n        else {\n            alt.GATE = () => {\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n                const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n                return allow;\n            };\n        }\n        return alt;\n    }));\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\n    return (args) => {\n        wrapped(args);\n        if (!ctx.parser.isRecording()) {\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n        }\n    };\n}\nfunction buildGroup(ctx, group) {\n    const methods = group.elements.map(e => buildElement(ctx, e));\n    return (args) => methods.forEach(method => method(args));\n}\nfunction getGuardCondition(element) {\n    if (isGroup(element)) {\n        return element.guardCondition;\n    }\n    return undefined;\n}\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n    if (!terminal) {\n        if (!crossRef.type.ref) {\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\n        }\n        const assignment = findNameAssignment(crossRef.type.ref);\n        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n        if (!assignTerminal) {\n            throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\n        }\n        return buildCrossReference(ctx, crossRef, assignTerminal);\n    }\n    else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n        // The terminal is a data type rule here. Everything else will result in a validation error.\n        const rule = terminal.rule.ref;\n        const idx = ctx.subrule++;\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\n    }\n    else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n        const idx = ctx.consume++;\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\n    }\n    else if (isKeyword(terminal)) {\n        const idx = ctx.consume++;\n        const keyword = getToken(ctx, terminal.value);\n        return () => ctx.parser.consume(idx, keyword, crossRef);\n    }\n    else {\n        throw new Error('Could not build cross reference parser');\n    }\n}\nfunction buildKeyword(ctx, keyword) {\n    const idx = ctx.consume++;\n    const token = ctx.tokens[keyword.value];\n    if (!token) {\n        throw new Error('Could not find token for keyword: ' + keyword.value);\n    }\n    return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n    const gate = guard && buildPredicate(guard);\n    if (!cardinality) {\n        if (gate) {\n            const idx = ctx.or++;\n            return (args) => ctx.parser.alternatives(idx, [\n                {\n                    ALT: () => method(args),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return method;\n        }\n    }\n    if (cardinality === '*') {\n        const idx = ctx.many++;\n        return (args) => ctx.parser.many(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else if (cardinality === '+') {\n        const idx = ctx.many++;\n        if (gate) {\n            const orIdx = ctx.or++;\n            // In the case of a guard condition for the `+` group\n            // We combine it with an empty alternative\n            // If the condition returns true, it needs to parse at least a single iteration\n            // If its false, it is not allowed to parse anything\n            return (args) => ctx.parser.alternatives(orIdx, [\n                {\n                    ALT: () => ctx.parser.atLeastOne(idx, {\n                        DEF: () => method(args)\n                    }),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return (args) => ctx.parser.atLeastOne(idx, {\n                DEF: () => method(args),\n            });\n        }\n    }\n    else if (cardinality === '?') {\n        const idx = ctx.optional++;\n        return (args) => ctx.parser.optional(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else {\n        assertUnreachable(cardinality);\n    }\n}\nfunction getRule(ctx, element) {\n    const name = getRuleName(ctx, element);\n    const rule = ctx.parser.getRule(name);\n    if (!rule)\n        throw new Error(`Rule \"${name}\" not found.\"`);\n    return rule;\n}\nfunction getRuleName(ctx, element) {\n    if (isParserRule(element)) {\n        return element.name;\n    }\n    else if (ctx.ruleNames.has(element)) {\n        return ctx.ruleNames.get(element);\n    }\n    else {\n        let item = element;\n        let parent = item.$container;\n        let ruleName = element.$type;\n        while (!isParserRule(parent)) {\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n                const index = parent.elements.indexOf(item);\n                ruleName = index.toString() + ':' + ruleName;\n            }\n            item = parent;\n            parent = parent.$container;\n        }\n        const rule = parent;\n        ruleName = rule.name + ':' + ruleName;\n        ctx.ruleNames.set(element, ruleName);\n        return ruleName;\n    }\n}\nfunction getToken(ctx, name) {\n    const token = ctx.tokens[name];\n    if (!token)\n        throw new Error(`Token \"${name}\" not found.\"`);\n    return token;\n}\n//# sourceMappingURL=parser-builder-base.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\n/**\n * Delays the execution of the current code to the next tick of the event loop.\n * Don't call this method directly in a tight loop to prevent too many promises from being created.\n */\nexport function delayNextTick() {\n    return new Promise(resolve => {\n        // In case we are running in a non-node environment, `setImmediate` isn't available.\n        // Using `setTimeout` of the browser API accomplishes the same result.\n        if (typeof setImmediate === 'undefined') {\n            setTimeout(resolve, 0);\n        }\n        else {\n            setImmediate(resolve);\n        }\n    });\n}\nlet lastTick = 0;\nlet globalInterruptionPeriod = 10;\n/**\n * Reset the global interruption period and create a cancellation token source.\n */\nexport function startCancelableOperation() {\n    lastTick = performance.now();\n    return new CancellationTokenSource();\n}\n/**\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\n * The default value is 10ms.\n */\nexport function setInterruptionPeriod(period) {\n    globalInterruptionPeriod = period;\n}\n/**\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\n * this symbol as rejection reason.\n */\nexport const OperationCancelled = Symbol('OperationCancelled');\n/**\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\n * has been cancelled.\n */\nexport function isOperationCancelled(err) {\n    return err === OperationCancelled;\n}\n/**\n * This function does two things:\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\n *\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\n * the promise) to avoid that event being exposed as an error.\n */\nexport async function interruptAndCheck(token) {\n    if (token === CancellationToken.None) {\n        // Early exit in case cancellation was disabled by the caller\n        return;\n    }\n    const current = performance.now();\n    if (current - lastTick >= globalInterruptionPeriod) {\n        lastTick = current;\n        await delayNextTick();\n        // prevent calling delayNextTick every iteration of loop\n        // where delayNextTick takes up the majority or all of the\n        // globalInterruptionPeriod itself\n        lastTick = performance.now();\n    }\n    if (token.isCancellationRequested) {\n        throw OperationCancelled;\n    }\n}\n/**\n * Simple implementation of the deferred pattern.\n * An object that exposes a promise and functions to resolve and reject it.\n */\nexport class Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = (arg) => {\n                resolve(arg);\n                return this;\n            };\n            this.reject = (err) => {\n                reject(err);\n                return this;\n            };\n        });\n    }\n}\n//# sourceMappingURL=promise-utils.js.map","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (const change of changes) {\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                const range = getWellformedRange(change.range);\n                // update content\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        const lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        const line = low - 1;\n        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        const lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        const lineOffset = lineOffsets[position.line];\n        if (position.character <= 0) {\n            return lineOffset;\n        }\n        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        const offset = Math.min(lineOffset + position.character, nextLineOffset);\n        return this.ensureBeforeEOL(offset, lineOffset);\n    }\n    ensureBeforeEOL(offset, lineOffset) {\n        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n            offset--;\n        }\n        return offset;\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    static isFull(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n}\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        const text = document.getText();\n        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n            const diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits) {\n            const startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    const p = (data.length / 2) | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        const ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        const ch = text.charCodeAt(i);\n        if (isEOL(ch)) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction isEOL(char) {\n    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;\n}\nfunction getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    const range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range };\n    }\n    return textEdit;\n}\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\n *  the overhead is very small, just a few kilobytes.\n * Everything else of that package (at the time contributing) is also defined\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\n */\nexport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { TextDocument } from './documents.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { URI } from '../utils/uri-utils.js';\n/**\n * A document is subject to several phases that are run in predefined order. Any state value implies that\n * smaller state values are finished as well.\n */\nexport var DocumentState;\n(function (DocumentState) {\n    /**\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\n     * document instance is no longer valid.\n     */\n    DocumentState[DocumentState[\"Changed\"] = 0] = \"Changed\";\n    /**\n     * An AST has been created from the text content. The document structure can be traversed,\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\n     * at this stage as a preprocessing step.\n     */\n    DocumentState[DocumentState[\"Parsed\"] = 1] = \"Parsed\";\n    /**\n     * The `IndexManager` service has processed AST nodes of this document. This means the\n     * exported symbols are available in the global scope and can be resolved from other documents.\n     */\n    DocumentState[DocumentState[\"IndexedContent\"] = 2] = \"IndexedContent\";\n    /**\n     * The `ScopeComputation` service has processed this document. This means the local symbols\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\n     * Once a document has reached this state, you may follow every reference - it will lazily\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\n     * the target is not in scope.\n     */\n    DocumentState[DocumentState[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n    /**\n     * The `Linker` service has processed this document. All outgoing references have been\n     * resolved or marked as erroneous.\n     */\n    DocumentState[DocumentState[\"Linked\"] = 4] = \"Linked\";\n    /**\n     * The `IndexManager` service has processed AST node references of this document. This is\n     * necessary to determine which documents are affected by a change in one of the workspace\n     * documents.\n     */\n    DocumentState[DocumentState[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n    /**\n     * The `DocumentValidator` service has processed this document. The language server listens\n     * to the results of this phase and sends diagnostics to the client.\n     */\n    DocumentState[DocumentState[\"Validated\"] = 6] = \"Validated\";\n})(DocumentState || (DocumentState = {}));\nexport class DefaultLangiumDocumentFactory {\n    constructor(services) {\n        this.serviceRegistry = services.ServiceRegistry;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n    }\n    async fromUri(uri, cancellationToken = CancellationToken.None) {\n        const content = await this.fileSystemProvider.readFile(uri);\n        return this.createAsync(uri, content, cancellationToken);\n    }\n    fromTextDocument(textDocument, uri, token) {\n        uri = uri !== null && uri !== void 0 ? uri : URI.parse(textDocument.uri);\n        if (CancellationToken.is(token)) {\n            return this.createAsync(uri, textDocument, token);\n        }\n        else {\n            return this.create(uri, textDocument, token);\n        }\n    }\n    fromString(text, uri, token) {\n        if (CancellationToken.is(token)) {\n            return this.createAsync(uri, text, token);\n        }\n        else {\n            return this.create(uri, text, token);\n        }\n    }\n    fromModel(model, uri) {\n        return this.create(uri, { $model: model });\n    }\n    create(uri, content, options) {\n        if (typeof content === 'string') {\n            const parseResult = this.parse(uri, content, options);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else if ('$model' in content) {\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n            return this.createLangiumDocument(parseResult, uri);\n        }\n        else {\n            const parseResult = this.parse(uri, content.getText(), options);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    async createAsync(uri, content, cancelToken) {\n        if (typeof content === 'string') {\n            const parseResult = await this.parseAsync(uri, content, cancelToken);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else {\n            const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    /**\n     * Create a LangiumDocument from a given parse result.\n     *\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\n     * should not be necessary because the main purpose of the TextDocument is to convert between\n     * text ranges and offsets, which is done solely in LSP request handling.\n     *\n     * With the introduction of {@link update} below this method is supposed to be mainly called\n     * during workspace initialization and on addition/recognition of new files, while changes in\n     * existing documents are processed via {@link update}.\n     */\n    createLangiumDocument(parseResult, uri, textDocument, text) {\n        let document;\n        if (textDocument) {\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                textDocument\n            };\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                get textDocument() {\n                    return textDocumentGetter();\n                }\n            };\n        }\n        parseResult.value.$document = document;\n        return document;\n    }\n    async update(document, cancellationToken) {\n        var _a, _b;\n        // The CST full text property contains the original text that was used to create the AST.\n        const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n        const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n        if (textDocument) {\n            Object.defineProperty(document, 'textDocument', {\n                value: textDocument\n            });\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n            Object.defineProperty(document, 'textDocument', {\n                get: textDocumentGetter\n            });\n        }\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\n        // Therefore, we only parse if the text has actually changed.\n        if (oldText !== text) {\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n            document.parseResult.value.$document = document;\n        }\n        document.state = DocumentState.Parsed;\n        return document;\n    }\n    parse(uri, text, options) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.LangiumParser.parse(text, options);\n    }\n    parseAsync(uri, text, cancellationToken) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.AsyncParser.parse(text, cancellationToken);\n    }\n    createTextDocumentGetter(uri, text) {\n        const serviceRegistry = this.serviceRegistry;\n        let textDoc = undefined;\n        return () => {\n            return textDoc !== null && textDoc !== void 0 ? textDoc : (textDoc = TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : ''));\n        };\n    }\n}\nexport class DefaultLangiumDocuments {\n    constructor(services) {\n        this.documentMap = new Map();\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get all() {\n        return stream(this.documentMap.values());\n    }\n    addDocument(document) {\n        const uriString = document.uri.toString();\n        if (this.documentMap.has(uriString)) {\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\n        }\n        this.documentMap.set(uriString, document);\n    }\n    getDocument(uri) {\n        const uriString = uri.toString();\n        return this.documentMap.get(uriString);\n    }\n    async getOrCreateDocument(uri, cancellationToken) {\n        let document = this.getDocument(uri);\n        if (document) {\n            return document;\n        }\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n        this.addDocument(document);\n        return document;\n    }\n    createDocument(uri, text, cancellationToken) {\n        if (cancellationToken) {\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\n                this.addDocument(document);\n                return document;\n            });\n        }\n        else {\n            const document = this.langiumDocumentFactory.fromString(text, uri);\n            this.addDocument(document);\n            return document;\n        }\n    }\n    hasDocument(uri) {\n        return this.documentMap.has(uri.toString());\n    }\n    invalidateDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            const linker = this.serviceRegistry.getServices(uri).references.Linker;\n            linker.unlink(langiumDoc);\n            langiumDoc.state = DocumentState.Changed;\n            langiumDoc.precomputedScopes = undefined;\n            langiumDoc.diagnostics = undefined;\n        }\n        return langiumDoc;\n    }\n    deleteDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            this.documentMap.delete(uriString);\n        }\n        return langiumDoc;\n    }\n}\n//# sourceMappingURL=documents.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\nimport { findRootNode, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { DocumentState } from '../workspace/documents.js';\nconst ref_resolving = Symbol('ref_resolving');\nexport class DefaultLinker {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n        this.scopeProvider = services.references.ScopeProvider;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n    }\n    async link(document, cancelToken = CancellationToken.None) {\n        for (const node of streamAst(document.parseResult.value)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\n        }\n    }\n    doLink(refInfo, document) {\n        var _a;\n        const ref = refInfo.reference;\n        // The reference may already have been resolved lazily by accessing its `ref` property.\n        if (ref._ref === undefined) {\n            ref._ref = ref_resolving;\n            try {\n                const description = this.getCandidate(refInfo);\n                if (isLinkingError(description)) {\n                    ref._ref = description;\n                }\n                else {\n                    ref._nodeDescription = description;\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\n                        // The target document is already loaded\n                        const linkedNode = this.loadAstNode(description);\n                        ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n                    }\n                    else {\n                        // Try to load the target AST node later using the already provided description\n                        ref._ref = undefined;\n                    }\n                }\n            }\n            catch (err) {\n                console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);\n                const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n                ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}` });\n            }\n            // Add the reference to the document's array of references\n            // Only add if the reference has been not been resolved earlier\n            // Otherwise we end up with duplicates\n            // See also implementation of `buildReference`\n            document.references.push(ref);\n        }\n    }\n    unlink(document) {\n        for (const ref of document.references) {\n            delete ref._ref;\n            delete ref._nodeDescription;\n        }\n        document.references = [];\n    }\n    getCandidate(refInfo) {\n        const scope = this.scopeProvider.getScope(refInfo);\n        const description = scope.getElement(refInfo.reference.$refText);\n        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n    }\n    buildReference(node, property, refNode, refText) {\n        // See behavior description in doc of Linker, update that on changes in here.\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const linker = this;\n        const reference = {\n            $refNode: refNode,\n            $refText: refText,\n            get ref() {\n                var _a;\n                if (isAstNode(this._ref)) {\n                    // Most frequent case: the target is already resolved.\n                    return this._ref;\n                }\n                else if (isAstNodeDescription(this._nodeDescription)) {\n                    // A candidate has been found before, but it is not loaded yet.\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\n                    this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n                }\n                else if (this._ref === undefined) {\n                    // The reference has not been linked yet, so do that now.\n                    this._ref = ref_resolving;\n                    const document = findRootNode(node).$document;\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\n                    if (refData.error && document && document.state < DocumentState.ComputedScopes) {\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\n                        return this._ref = undefined;\n                    }\n                    this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n                    this._nodeDescription = refData.descr;\n                    document === null || document === void 0 ? void 0 : document.references.push(this);\n                }\n                else if (this._ref === ref_resolving) {\n                    throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);\n                }\n                return isAstNode(this._ref) ? this._ref : undefined;\n            },\n            get $nodeDescription() {\n                return this._nodeDescription;\n            },\n            get error() {\n                return isLinkingError(this._ref) ? this._ref : undefined;\n            }\n        };\n        return reference;\n    }\n    getLinkedNode(refInfo) {\n        var _a;\n        try {\n            const description = this.getCandidate(refInfo);\n            if (isLinkingError(description)) {\n                return { error: description };\n            }\n            const linkedNode = this.loadAstNode(description);\n            if (linkedNode) {\n                return { node: linkedNode, descr: description };\n            }\n            else {\n                return {\n                    descr: description,\n                    error: this.createLinkingError(refInfo, description)\n                };\n            }\n        }\n        catch (err) {\n            console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);\n            const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n            return {\n                error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}` })\n            };\n        }\n    }\n    loadAstNode(nodeDescription) {\n        if (nodeDescription.node) {\n            return nodeDescription.node;\n        }\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n        if (!doc) {\n            return undefined;\n        }\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n    }\n    createLinkingError(refInfo, targetDescription) {\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\n        // in the language implementation.\n        const document = findRootNode(refInfo.container).$document;\n        if (document && document.state < DocumentState.ComputedScopes) {\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n        }\n        const referenceType = this.reflection.getReferenceType(refInfo);\n        return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });\n    }\n}\n//# sourceMappingURL=linker.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { findNodeForProperty } from '../utils/grammar-utils.js';\nexport function isNamed(node) {\n    return typeof node.name === 'string';\n}\nexport class DefaultNameProvider {\n    getName(node) {\n        if (isNamed(node)) {\n            return node.name;\n        }\n        return undefined;\n    }\n    getNameNode(node) {\n        return findNodeForProperty(node.$cstNode, 'name');\n    }\n}\n//# sourceMappingURL=name-provider.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { URI, Utils } from 'vscode-uri';\nexport { URI };\nexport var UriUtils;\n(function (UriUtils) {\n    UriUtils.basename = Utils.basename;\n    UriUtils.dirname = Utils.dirname;\n    UriUtils.extname = Utils.extname;\n    UriUtils.joinPath = Utils.joinPath;\n    UriUtils.resolvePath = Utils.resolvePath;\n    function equals(a, b) {\n        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n    }\n    UriUtils.equals = equals;\n    function relative(from, to) {\n        const fromPath = typeof from === 'string' ? from : from.path;\n        const toPath = typeof to === 'string' ? to : to.path;\n        const fromParts = fromPath.split('/').filter(e => e.length > 0);\n        const toParts = toPath.split('/').filter(e => e.length > 0);\n        let i = 0;\n        for (; i < fromParts.length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n                break;\n            }\n        }\n        const backPart = '../'.repeat(fromParts.length - i);\n        const toPart = toParts.slice(i).join('/');\n        return backPart + toPart;\n    }\n    UriUtils.relative = relative;\n    function normalize(uri) {\n        return URI.parse(uri.toString()).toString();\n    }\n    UriUtils.normalize = normalize;\n})(UriUtils || (UriUtils = {}));\n//# sourceMappingURL=uri-utils.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { assertUnreachable } from '../index.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\n/**\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\n */\nexport function diagnosticData(code) {\n    return { code };\n}\nexport var ValidationCategory;\n(function (ValidationCategory) {\n    ValidationCategory.all = ['fast', 'slow', 'built-in'];\n})(ValidationCategory || (ValidationCategory = {}));\n/**\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\n */\nexport class ValidationRegistry {\n    constructor(services) {\n        this.entries = new MultiMap();\n        this.entriesBefore = [];\n        this.entriesAfter = [];\n        this.reflection = services.shared.AstReflection;\n    }\n    /**\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n     * or an array of validation checks.\n     *\n     * @param checksRecord Set of validation checks to register.\n     * @param category Optional category for the validation checks (defaults to `'fast'`).\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    register(checksRecord, thisObj = this, category = 'fast') {\n        if (category === 'built-in') {\n            throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n        }\n        for (const [type, ch] of Object.entries(checksRecord)) {\n            const callbacks = ch;\n            if (Array.isArray(callbacks)) {\n                for (const check of callbacks) {\n                    const entry = {\n                        check: this.wrapValidationException(check, thisObj),\n                        category\n                    };\n                    this.addEntry(type, entry);\n                }\n            }\n            else if (typeof callbacks === 'function') {\n                const entry = {\n                    check: this.wrapValidationException(callbacks, thisObj),\n                    category\n                };\n                this.addEntry(type, entry);\n            }\n            else {\n                assertUnreachable(callbacks);\n            }\n        }\n    }\n    wrapValidationException(check, thisObj) {\n        return async (node, accept, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);\n        };\n    }\n    async handleException(functionality, messageContext, accept, node) {\n        try {\n            await functionality();\n        }\n        catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error(`${messageContext}:`, err);\n            if (err instanceof Error && err.stack) {\n                console.error(err.stack);\n            }\n            const messageDetails = err instanceof Error ? err.message : String(err);\n            accept('error', `${messageContext}: ${messageDetails}`, { node });\n        }\n    }\n    addEntry(type, entry) {\n        if (type === 'AstNode') {\n            this.entries.add('AstNode', entry);\n            return;\n        }\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\n            this.entries.add(subtype, entry);\n        }\n    }\n    getChecks(type, categories) {\n        let checks = stream(this.entries.get(type))\n            .concat(this.entries.get('AstNode'));\n        if (categories) {\n            checks = checks.filter(entry => categories.includes(entry.category));\n        }\n        return checks.map(entry => entry.check);\n    }\n    /**\n     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.\n     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map for mapping names to nodes could be established.\n     * During the usual checks on the nodes, they are put into this map with their name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerBeforeDocument(checkBefore, thisObj = this) {\n        this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));\n    }\n    /**\n     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.\n     * This helps to finally evaluate information which are collected during the checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map with all the collected nodes and their names is checked\n     * and validation hints are created for all nodes with the same name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerAfterDocument(checkAfter, thisObj = this) {\n        this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));\n    }\n    wrapPreparationException(check, messageContext, thisObj) {\n        return async (rootNode, accept, categories, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);\n        };\n    }\n    get checksBefore() {\n        return this.entriesBefore;\n    }\n    get checksAfter() {\n        return this.entriesAfter;\n    }\n}\n//# sourceMappingURL=validation-registry.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { findNodeForKeyword, findNodeForProperty } from '../utils/grammar-utils.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { tokenToRange } from '../utils/cst-utils.js';\nimport { interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\nimport { diagnosticData } from './validation-registry.js';\nexport class DefaultDocumentValidator {\n    constructor(services) {\n        this.validationRegistry = services.validation.ValidationRegistry;\n        this.metadata = services.LanguageMetaData;\n    }\n    async validateDocument(document, options = {}, cancelToken = CancellationToken.None) {\n        const parseResult = document.parseResult;\n        const diagnostics = [];\n        await interruptAndCheck(cancelToken);\n        if (!options.categories || options.categories.includes('built-in')) {\n            this.processLexingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterLexingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError; })) {\n                return diagnostics;\n            }\n            this.processParsingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterParsingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError; })) {\n                return diagnostics;\n            }\n            this.processLinkingErrors(document, diagnostics, options);\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError; })) {\n                return diagnostics;\n            }\n        }\n        // Process custom validations\n        try {\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n        }\n        catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error('An error occurred during validation:', err);\n        }\n        await interruptAndCheck(cancelToken);\n        return diagnostics;\n    }\n    processLexingErrors(parseResult, diagnostics, _options) {\n        var _a, _b, _c;\n        const lexerDiagnostics = [...parseResult.lexerErrors, ...(_b = (_a = parseResult.lexerReport) === null || _a === void 0 ? void 0 : _a.diagnostics) !== null && _b !== void 0 ? _b : []];\n        for (const lexerDiagnostic of lexerDiagnostics) {\n            const severity = (_c = lexerDiagnostic.severity) !== null && _c !== void 0 ? _c : 'error';\n            const diagnostic = {\n                severity: toDiagnosticSeverity(severity),\n                range: {\n                    start: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column - 1\n                    },\n                    end: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column + lexerDiagnostic.length - 1\n                    }\n                },\n                message: lexerDiagnostic.message,\n                data: toDiagnosticData(severity),\n                source: this.getSource()\n            };\n            diagnostics.push(diagnostic);\n        }\n    }\n    processParsingErrors(parseResult, diagnostics, _options) {\n        for (const parserError of parseResult.parserErrors) {\n            let range = undefined;\n            // We can run into the chevrotain error recovery here\n            // The token contained in the parser error might be automatically inserted\n            // In this case every position value will be `NaN`\n            if (isNaN(parserError.token.startOffset)) {\n                // Some special parser error types contain a `previousToken`\n                // We can simply append our diagnostic to that token\n                if ('previousToken' in parserError) {\n                    const token = parserError.previousToken;\n                    if (!isNaN(token.startOffset)) {\n                        const position = { line: token.endLine - 1, character: token.endColumn };\n                        range = { start: position, end: position };\n                    }\n                    else {\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\n                        // Point to document start\n                        const position = { line: 0, character: 0 };\n                        range = { start: position, end: position };\n                    }\n                }\n            }\n            else {\n                range = tokenToRange(parserError.token);\n            }\n            if (range) {\n                const diagnostic = {\n                    severity: toDiagnosticSeverity('error'),\n                    range,\n                    message: parserError.message,\n                    data: diagnosticData(DocumentValidator.ParsingError),\n                    source: this.getSource()\n                };\n                diagnostics.push(diagnostic);\n            }\n        }\n    }\n    processLinkingErrors(document, diagnostics, _options) {\n        for (const reference of document.references) {\n            const linkingError = reference.error;\n            if (linkingError) {\n                const info = {\n                    node: linkingError.container,\n                    property: linkingError.property,\n                    index: linkingError.index,\n                    data: {\n                        code: DocumentValidator.LinkingError,\n                        containerType: linkingError.container.$type,\n                        property: linkingError.property,\n                        refText: linkingError.reference.$refText\n                    }\n                };\n                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));\n            }\n        }\n    }\n    async validateAst(rootNode, options, cancelToken = CancellationToken.None) {\n        const validationItems = [];\n        const acceptor = (severity, message, info) => {\n            validationItems.push(this.toDiagnostic(severity, message, info));\n        };\n        await this.validateAstBefore(rootNode, options, acceptor, cancelToken);\n        await this.validateAstNodes(rootNode, options, acceptor, cancelToken);\n        await this.validateAstAfter(rootNode, options, acceptor, cancelToken);\n        return validationItems;\n    }\n    async validateAstBefore(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        var _a;\n        const checksBefore = this.validationRegistry.checksBefore;\n        for (const checkBefore of checksBefore) {\n            await interruptAndCheck(cancelToken);\n            await checkBefore(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    async validateAstNodes(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        await Promise.all(streamAst(rootNode).map(async (node) => {\n            await interruptAndCheck(cancelToken);\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n            for (const check of checks) {\n                await check(node, acceptor, cancelToken);\n            }\n        }));\n    }\n    async validateAstAfter(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        var _a;\n        const checksAfter = this.validationRegistry.checksAfter;\n        for (const checkAfter of checksAfter) {\n            await interruptAndCheck(cancelToken);\n            await checkAfter(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    toDiagnostic(severity, message, info) {\n        return {\n            message,\n            range: getDiagnosticRange(info),\n            severity: toDiagnosticSeverity(severity),\n            code: info.code,\n            codeDescription: info.codeDescription,\n            tags: info.tags,\n            relatedInformation: info.relatedInformation,\n            data: info.data,\n            source: this.getSource()\n        };\n    }\n    getSource() {\n        return this.metadata.languageId;\n    }\n}\nexport function getDiagnosticRange(info) {\n    if (info.range) {\n        return info.range;\n    }\n    let cstNode;\n    if (typeof info.property === 'string') {\n        cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\n    }\n    else if (typeof info.keyword === 'string') {\n        cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n    }\n    cstNode !== null && cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);\n    if (!cstNode) {\n        return {\n            start: { line: 0, character: 0 },\n            end: { line: 0, character: 0 }\n        };\n    }\n    return cstNode.range;\n}\n/**\n * Transforms the diagnostic severity from the {@link LexingDiagnosticSeverity} format to LSP's `DiagnosticSeverity` format.\n *\n * @param severity The lexing diagnostic severity\n * @returns Diagnostic severity according to `vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity`\n */\nexport function toDiagnosticSeverity(severity) {\n    switch (severity) {\n        case 'error':\n            return 1;\n        case 'warning':\n            return 2;\n        case 'info':\n            return 3;\n        case 'hint':\n            return 4;\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nexport function toDiagnosticData(severity) {\n    switch (severity) {\n        case 'error':\n            return diagnosticData(DocumentValidator.LexingError);\n        case 'warning':\n            return diagnosticData(DocumentValidator.LexingWarning);\n        case 'info':\n            return diagnosticData(DocumentValidator.LexingInfo);\n        case 'hint':\n            return diagnosticData(DocumentValidator.LexingHint);\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nexport var DocumentValidator;\n(function (DocumentValidator) {\n    DocumentValidator.LexingError = 'lexing-error';\n    DocumentValidator.LexingWarning = 'lexing-warning';\n    DocumentValidator.LexingInfo = 'lexing-info';\n    DocumentValidator.LexingHint = 'lexing-hint';\n    DocumentValidator.ParsingError = 'parsing-error';\n    DocumentValidator.LinkingError = 'linking-error';\n})(DocumentValidator || (DocumentValidator = {}));\n//# sourceMappingURL=document-validator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { findAssignment } from '../utils/grammar-utils.js';\nimport { isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isChildNode, toDocumentSegment } from '../utils/cst-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultReferences {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.index = services.shared.workspace.IndexManager;\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    findDeclaration(sourceCstNode) {\n        if (sourceCstNode) {\n            const assignment = findAssignment(sourceCstNode);\n            const nodeElem = sourceCstNode.astNode;\n            if (assignment && nodeElem) {\n                const reference = nodeElem[assignment.feature];\n                if (isReference(reference)) {\n                    return reference.ref;\n                }\n                else if (Array.isArray(reference)) {\n                    for (const ref of reference) {\n                        if (isReference(ref) && ref.$refNode\n                            && ref.$refNode.offset <= sourceCstNode.offset\n                            && ref.$refNode.end >= sourceCstNode.end) {\n                            return ref.ref;\n                        }\n                    }\n                }\n            }\n            if (nodeElem) {\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\n                if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\n                    return nodeElem;\n                }\n            }\n        }\n        return undefined;\n    }\n    findDeclarationNode(sourceCstNode) {\n        const astNode = this.findDeclaration(sourceCstNode);\n        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n            const targetNode = this.nameProvider.getNameNode(astNode);\n            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n        }\n        return undefined;\n    }\n    findReferences(targetNode, options) {\n        const refs = [];\n        if (options.includeDeclaration) {\n            const ref = this.getReferenceToSelf(targetNode);\n            if (ref) {\n                refs.push(ref);\n            }\n        }\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n        if (options.documentUri) {\n            indexReferences = indexReferences.filter(ref => UriUtils.equals(ref.sourceUri, options.documentUri));\n        }\n        refs.push(...indexReferences);\n        return stream(refs);\n    }\n    getReferenceToSelf(targetNode) {\n        const nameNode = this.nameProvider.getNameNode(targetNode);\n        if (nameNode) {\n            const doc = getDocument(targetNode);\n            const path = this.nodeLocator.getAstNodePath(targetNode);\n            return {\n                sourceUri: doc.uri,\n                sourcePath: path,\n                targetUri: doc.uri,\n                targetPath: path,\n                segment: toDocumentSegment(nameNode),\n                local: true\n            };\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=references.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Reduction, stream } from './stream.js';\n/**\n * A multimap is a variation of a Map that has potentially multiple values for every key.\n */\nexport class MultiMap {\n    constructor(elements) {\n        this.map = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.add(key, value);\n            }\n        }\n    }\n    /**\n     * The total number of values in the multimap.\n     */\n    get size() {\n        return Reduction.sum(stream(this.map.values()).map(a => a.length));\n    }\n    /**\n     * Clear all entries in the multimap.\n     */\n    clear() {\n        this.map.clear();\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\n     *  * Without a value, all values associated with the given key are deleted.\n     *\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\n     *     key / value does not exist.\n     */\n    delete(key, value) {\n        if (value === undefined) {\n            return this.map.delete(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                const index = values.indexOf(value);\n                if (index >= 0) {\n                    if (values.length === 1) {\n                        this.map.delete(key);\n                    }\n                    else {\n                        values.splice(index, 1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    /**\n     * Returns an array of all values associated with the given key. If no value exists,\n     * an empty array is returned.\n     *\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n     * value and `delete` to remove a value from the multimap.\n     */\n    get(key) {\n        var _a;\n        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\n     */\n    has(key, value) {\n        if (value === undefined) {\n            return this.map.has(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                return values.indexOf(value) >= 0;\n            }\n            return false;\n        }\n    }\n    /**\n     * Add the given key / value pair to the multimap.\n     */\n    add(key, value) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(value);\n        }\n        else {\n            this.map.set(key, [value]);\n        }\n        return this;\n    }\n    /**\n     * Add the given set of key / value pairs to the multimap.\n     */\n    addAll(key, values) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(...values);\n        }\n        else {\n            this.map.set(key, Array.from(values));\n        }\n        return this;\n    }\n    /**\n     * Invokes the given callback function for every key / value pair in the multimap.\n     */\n    forEach(callbackfn) {\n        this.map.forEach((array, key) => array.forEach(value => callbackfn(value, key, this)));\n    }\n    /**\n     * Returns an iterator of key, value pairs for every entry in the map.\n     */\n    [Symbol.iterator]() {\n        return this.entries().iterator();\n    }\n    /**\n     * Returns a stream of key, value pairs for every entry in the map.\n     */\n    entries() {\n        return stream(this.map.entries())\n            .flatMap(([key, array]) => array.map(value => [key, value]));\n    }\n    /**\n     * Returns a stream of keys in the map.\n     */\n    keys() {\n        return stream(this.map.keys());\n    }\n    /**\n     * Returns a stream of values in the map.\n     */\n    values() {\n        return stream(this.map.values()).flat();\n    }\n    /**\n     * Returns a stream of key, value set pairs for every key in the map.\n     */\n    entriesGroupedByKey() {\n        return stream(this.map.entries());\n    }\n}\nexport class BiMap {\n    get size() {\n        return this.map.size;\n    }\n    constructor(elements) {\n        this.map = new Map();\n        this.inverse = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this.map.clear();\n        this.inverse.clear();\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.inverse.set(value, key);\n        return this;\n    }\n    get(key) {\n        return this.map.get(key);\n    }\n    getKey(value) {\n        return this.inverse.get(value);\n    }\n    delete(key) {\n        const value = this.map.get(key);\n        if (value !== undefined) {\n            this.map.delete(key);\n            this.inverse.delete(value);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=collections.js.map","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { streamAllContents, streamContents } from '../utils/ast-utils.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\n/**\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\n * _global_ scope from the given document. By default those are the document's root AST node and its directly\n * contained child nodes.\n *\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)\n * are _invisible_ by default, but that can be changed by customizing this service.\n */\nexport class DefaultScopeComputation {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    }\n    async computeExports(document, cancelToken = CancellationToken.None) {\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\n    }\n    /**\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n     * The list of children to be considered is determined by the function parameter {@link children}.\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n     *\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n     * @param document The document containing the AST node to be exported.\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCancelled` if a user action occurs during execution.\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n     */\n    async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = CancellationToken.None) {\n        const exports = [];\n        this.exportNode(parentNode, exports, document);\n        for (const node of children(parentNode)) {\n            await interruptAndCheck(cancelToken);\n            this.exportNode(node, exports, document);\n        }\n        return exports;\n    }\n    /**\n     * Add a single node to the list of exports if it has a name. Override this method to change how\n     * symbols are exported, e.g. by modifying their exported name.\n     */\n    exportNode(node, exports, document) {\n        const name = this.nameProvider.getName(node);\n        if (name) {\n            exports.push(this.descriptions.createDescription(node, name, document));\n        }\n    }\n    async computeLocalScopes(document, cancelToken = CancellationToken.None) {\n        const rootNode = document.parseResult.value;\n        const scopes = new MultiMap();\n        // Here we navigate the full AST - local scopes shall be available in the whole document\n        for (const node of streamAllContents(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            this.processNode(node, document, scopes);\n        }\n        return scopes;\n    }\n    /**\n     * Process a single node during scopes computation. The default implementation makes the node visible\n     * in the subtree of its container (if the node has a name). Override this method to change this,\n     * e.g. by increasing the visibility to a higher level in the AST.\n     */\n    processNode(node, document, scopes) {\n        const container = node.$container;\n        if (container) {\n            const name = this.nameProvider.getName(node);\n            if (name) {\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\n            }\n        }\n    }\n}\n//# sourceMappingURL=scope-computation.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_STREAM, stream } from '../utils/stream.js';\n/**\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\n * the next level of elements, which are queried when a target element is not found in the stream provided\n * to this scope.\n */\nexport class StreamScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = elements;\n        this.outerScope = outerScope;\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n    }\n    getAllElements() {\n        if (this.outerScope) {\n            return this.elements.concat(this.outerScope.getAllElements());\n        }\n        else {\n            return this.elements;\n        }\n    }\n    getElement(name) {\n        const local = this.caseInsensitive\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\n            : this.elements.find(e => e.name === name);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n}\nexport class MapScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = new Map();\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n        for (const element of elements) {\n            const name = this.caseInsensitive\n                ? element.name.toLowerCase()\n                : element.name;\n            this.elements.set(name, element);\n        }\n        this.outerScope = outerScope;\n    }\n    getElement(name) {\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\n        const local = this.elements.get(localName);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n    getAllElements() {\n        let elementStream = stream(this.elements.values());\n        if (this.outerScope) {\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\n        }\n        return elementStream;\n    }\n}\nexport const EMPTY_SCOPE = {\n    getElement() {\n        return undefined;\n    },\n    getAllElements() {\n        return EMPTY_STREAM;\n    }\n};\n//# sourceMappingURL=scope.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class DisposableCache {\n    constructor() {\n        this.toDispose = [];\n        this.isDisposed = false;\n    }\n    onDispose(disposable) {\n        this.toDispose.push(disposable);\n    }\n    dispose() {\n        this.throwIfDisposed();\n        this.clear();\n        this.isDisposed = true;\n        this.toDispose.forEach(disposable => disposable.dispose());\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error('This cache has already been disposed');\n        }\n    }\n}\nexport class SimpleCache extends DisposableCache {\n    constructor() {\n        super(...arguments);\n        this.cache = new Map();\n    }\n    has(key) {\n        this.throwIfDisposed();\n        return this.cache.has(key);\n    }\n    set(key, value) {\n        this.throwIfDisposed();\n        this.cache.set(key, value);\n    }\n    get(key, provider) {\n        this.throwIfDisposed();\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            this.cache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(key) {\n        this.throwIfDisposed();\n        return this.cache.delete(key);\n    }\n    clear() {\n        this.throwIfDisposed();\n        this.cache.clear();\n    }\n}\nexport class ContextCache extends DisposableCache {\n    constructor(converter) {\n        super();\n        this.cache = new Map();\n        this.converter = converter !== null && converter !== void 0 ? converter : (value => value);\n    }\n    has(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).has(key);\n    }\n    set(contextKey, key, value) {\n        this.throwIfDisposed();\n        this.cacheForContext(contextKey).set(key, value);\n    }\n    get(contextKey, key, provider) {\n        this.throwIfDisposed();\n        const contextCache = this.cacheForContext(contextKey);\n        if (contextCache.has(key)) {\n            return contextCache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            contextCache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).delete(key);\n    }\n    clear(contextKey) {\n        this.throwIfDisposed();\n        if (contextKey) {\n            const mapKey = this.converter(contextKey);\n            this.cache.delete(mapKey);\n        }\n        else {\n            this.cache.clear();\n        }\n    }\n    cacheForContext(contextKey) {\n        const mapKey = this.converter(contextKey);\n        let documentCache = this.cache.get(mapKey);\n        if (!documentCache) {\n            documentCache = new Map();\n            this.cache.set(mapKey, documentCache);\n        }\n        return documentCache;\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to a document.\n * If this document is changed or deleted, all associated key/value pairs are deleted.\n */\nexport class DocumentCache extends ContextCache {\n    /**\n     * Creates a new document cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     *\n     * Providing a state here will use `DocumentBuilder#onDocumentPhase` instead,\n     * which triggers on all documents that have been affected by this change, assuming that the\n     * state is `DocumentState.Linked` or a later state.\n     */\n    constructor(sharedServices, state) {\n        super(uri => uri.toString());\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onDocumentPhase(state, document => {\n                this.clear(document.uri.toString());\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                for (const uri of deleted) { // react only on deleted documents\n                    this.clear(uri);\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\n                const allUris = changed.concat(deleted); // react on both changed and deleted documents\n                for (const uri of allUris) {\n                    this.clear(uri);\n                }\n            }));\n        }\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to the whole workspace.\n * If any document in the workspace is added, changed or deleted, the whole cache is evicted.\n */\nexport class WorkspaceCache extends SimpleCache {\n    /**\n     * Creates a new workspace cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     */\n    constructor(sharedServices, state) {\n        super();\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () => {\n                this.clear();\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                if (deleted.length > 0) { // react only on deleted documents\n                    this.clear();\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n                this.clear();\n            }));\n        }\n    }\n}\n//# sourceMappingURL=caching.js.map","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { MapScope, StreamScope } from './scope.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { WorkspaceCache } from '../utils/caching.js';\nexport class DefaultScopeProvider {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.globalScopeCache = new WorkspaceCache(services.shared);\n    }\n    getScope(context) {\n        const scopes = [];\n        const referenceType = this.reflection.getReferenceType(context);\n        const precomputed = getDocument(context.container).precomputedScopes;\n        if (precomputed) {\n            let currentNode = context.container;\n            do {\n                const allDescriptions = precomputed.get(currentNode);\n                if (allDescriptions.length > 0) {\n                    scopes.push(stream(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));\n                }\n                currentNode = currentNode.$container;\n            } while (currentNode);\n        }\n        let result = this.getGlobalScope(referenceType, context);\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            result = this.createScope(scopes[i], result);\n        }\n        return result;\n    }\n    /**\n     * Create a scope for the given collection of AST node descriptions.\n     */\n    createScope(elements, outerScope, options) {\n        return new StreamScope(stream(elements), outerScope, options);\n    }\n    /**\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n     */\n    createScopeForNodes(elements, outerScope, options) {\n        const s = stream(elements).map(e => {\n            const name = this.nameProvider.getName(e);\n            if (name) {\n                return this.descriptions.createDescription(e, name);\n            }\n            return undefined;\n        }).nonNullable();\n        return new StreamScope(s, outerScope, options);\n    }\n    /**\n     * Create a global scope filtered for the given reference type.\n     */\n    getGlobalScope(referenceType, _context) {\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n    }\n}\n//# sourceMappingURL=scope-provider.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { URI } from 'vscode-uri';\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { findNodesForProperty } from '../utils/grammar-utils.js';\nexport function isAstNodeWithComment(node) {\n    return typeof node.$comment === 'string';\n}\nfunction isIntermediateReference(obj) {\n    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);\n}\nexport class DefaultJsonSerializer {\n    constructor(services) {\n        /** The set of AstNode properties to be ignored by the serializer. */\n        this.ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    serialize(node, options) {\n        const serializeOptions = options !== null && options !== void 0 ? options : {};\n        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n        const defaultReplacer = (key, value) => this.replacer(key, value, serializeOptions);\n        const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n        try {\n            this.currentDocument = getDocument(node);\n            return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n        }\n        finally {\n            this.currentDocument = undefined;\n        }\n    }\n    deserialize(content, options) {\n        const deserializeOptions = options !== null && options !== void 0 ? options : {};\n        const root = JSON.parse(content);\n        this.linkNode(root, root, deserializeOptions);\n        return root;\n    }\n    replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {\n        var _a, _b, _c, _d;\n        if (this.ignoreProperties.has(key)) {\n            return undefined;\n        }\n        else if (isReference(value)) {\n            const refValue = value.ref;\n            const $refText = refText ? value.$refText : undefined;\n            if (refValue) {\n                const targetDocument = getDocument(refValue);\n                let targetUri = '';\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\n                    if (uriConverter) {\n                        targetUri = uriConverter(targetDocument.uri, value);\n                    }\n                    else {\n                        targetUri = targetDocument.uri.toString();\n                    }\n                }\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n                return {\n                    $ref: `${targetUri}#${targetPath}`,\n                    $refText\n                };\n            }\n            else {\n                return {\n                    $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : 'Could not resolve reference',\n                    $refText\n                };\n            }\n        }\n        else if (isAstNode(value)) {\n            let astNode = undefined;\n            if (textRegions) {\n                astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n                if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {\n                    // The document URI is added to the root node of the resulting JSON tree\n                    astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();\n                }\n            }\n            if (sourceText && !key) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;\n            }\n            if (comments) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                const comment = this.commentProvider.getComment(value);\n                if (comment) {\n                    astNode.$comment = comment.replace(/\\r/g, '');\n                }\n            }\n            return astNode !== null && astNode !== void 0 ? astNode : value;\n        }\n        else {\n            return value;\n        }\n    }\n    addAstNodeRegionWithAssignmentsTo(node) {\n        const createDocumentSegment = cstNode => ({\n            offset: cstNode.offset,\n            end: cstNode.end,\n            length: cstNode.length,\n            range: cstNode.range,\n        });\n        if (node.$cstNode) {\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n            const assignments = textRegion.assignments = {};\n            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {\n                const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n                if (propertyAssignments.length !== 0) {\n                    assignments[key] = propertyAssignments;\n                }\n            });\n            return node;\n        }\n        return undefined;\n    }\n    linkNode(node, root, options, container, containerProperty, containerIndex) {\n        for (const [propertyName, item] of Object.entries(node)) {\n            if (Array.isArray(item)) {\n                for (let index = 0; index < item.length; index++) {\n                    const element = item[index];\n                    if (isIntermediateReference(element)) {\n                        item[index] = this.reviveReference(node, propertyName, root, element, options);\n                    }\n                    else if (isAstNode(element)) {\n                        this.linkNode(element, root, options, node, propertyName, index);\n                    }\n                }\n            }\n            else if (isIntermediateReference(item)) {\n                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n            }\n            else if (isAstNode(item)) {\n                this.linkNode(item, root, options, node, propertyName);\n            }\n        }\n        const mutable = node;\n        mutable.$container = container;\n        mutable.$containerProperty = containerProperty;\n        mutable.$containerIndex = containerIndex;\n    }\n    reviveReference(container, property, root, reference, options) {\n        let refText = reference.$refText;\n        let error = reference.$error;\n        if (reference.$ref) {\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n            if (isAstNode(ref)) {\n                if (!refText) {\n                    refText = this.nameProvider.getName(ref);\n                }\n                return {\n                    $refText: refText !== null && refText !== void 0 ? refText : '',\n                    ref\n                };\n            }\n            else {\n                error = ref;\n            }\n        }\n        if (error) {\n            const ref = {\n                $refText: refText !== null && refText !== void 0 ? refText : ''\n            };\n            ref.error = {\n                container,\n                property,\n                message: error,\n                reference: ref\n            };\n            return ref;\n        }\n        else {\n            return undefined;\n        }\n    }\n    getRefNode(root, uri, uriConverter) {\n        try {\n            const fragmentIndex = uri.indexOf('#');\n            if (fragmentIndex === 0) {\n                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));\n                if (!node) {\n                    return 'Could not resolve path: ' + uri;\n                }\n                return node;\n            }\n            if (fragmentIndex < 0) {\n                const documentUri = uriConverter ? uriConverter(uri) : URI.parse(uri);\n                const document = this.langiumDocuments.getDocument(documentUri);\n                if (!document) {\n                    return 'Could not find document for URI: ' + uri;\n                }\n                return document.parseResult.value;\n            }\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI.parse(uri.substring(0, fragmentIndex));\n            const document = this.langiumDocuments.getDocument(documentUri);\n            if (!document) {\n                return 'Could not find document for URI: ' + uri;\n            }\n            if (fragmentIndex === uri.length - 1) {\n                return document.parseResult.value;\n            }\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n            if (!node) {\n                return 'Could not resolve URI: ' + uri;\n            }\n            return node;\n        }\n        catch (err) {\n            return String(err);\n        }\n    }\n}\n//# sourceMappingURL=json-serializer.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { UriUtils } from './utils/uri-utils.js';\n/**\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\n */\nexport class DefaultServiceRegistry {\n    /**\n     * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\n     */\n    get map() {\n        return this.fileExtensionMap;\n    }\n    constructor(services) {\n        this.languageIdMap = new Map();\n        this.fileExtensionMap = new Map();\n        this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;\n    }\n    register(language) {\n        const data = language.LanguageMetaData;\n        for (const ext of data.fileExtensions) {\n            if (this.fileExtensionMap.has(ext)) {\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);\n            }\n            this.fileExtensionMap.set(ext, language);\n        }\n        this.languageIdMap.set(data.languageId, language);\n        if (this.languageIdMap.size === 1) {\n            this.singleton = language;\n        }\n        else {\n            this.singleton = undefined;\n        }\n    }\n    getServices(uri) {\n        var _a, _b;\n        if (this.singleton !== undefined) {\n            return this.singleton;\n        }\n        if (this.languageIdMap.size === 0) {\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\n        }\n        const languageId = (_b = (_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(uri)) === null || _b === void 0 ? void 0 : _b.languageId;\n        if (languageId !== undefined) {\n            const services = this.languageIdMap.get(languageId);\n            if (services) {\n                return services;\n            }\n        }\n        const ext = UriUtils.extname(uri);\n        const services = this.fileExtensionMap.get(ext);\n        if (!services) {\n            if (languageId) {\n                throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\n            }\n            else {\n                throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n            }\n        }\n        return services;\n    }\n    hasServices(uri) {\n        try {\n            this.getServices(uri);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    get all() {\n        return Array.from(this.languageIdMap.values());\n    }\n}\n//# sourceMappingURL=service-registry.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isLinkingError } from '../syntax-tree.js';\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { toDocumentSegment } from '../utils/cst-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultAstNodeDescriptionProvider {\n    constructor(services) {\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n    }\n    createDescription(node, name, document) {\n        const doc = document !== null && document !== void 0 ? document : getDocument(node);\n        name !== null && name !== void 0 ? name : (name = this.nameProvider.getName(node));\n        const path = this.astNodeLocator.getAstNodePath(node);\n        if (!name) {\n            throw new Error(`Node at path ${path} has no name.`);\n        }\n        let nameNodeSegment;\n        const nameSegmentGetter = () => { var _a; return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : (nameNodeSegment = toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode)); };\n        return {\n            node,\n            name,\n            get nameSegment() {\n                return nameSegmentGetter();\n            },\n            selectionSegment: toDocumentSegment(node.$cstNode),\n            type: node.$type,\n            documentUri: doc.uri,\n            path\n        };\n    }\n}\nexport class DefaultReferenceDescriptionProvider {\n    constructor(services) {\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    async createDescriptions(document, cancelToken = CancellationToken.None) {\n        const descr = [];\n        const rootNode = document.parseResult.value;\n        for (const astNode of streamAst(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(astNode).filter(refInfo => !isLinkingError(refInfo)).forEach(refInfo => {\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\n                const description = this.createDescription(refInfo);\n                if (description) {\n                    descr.push(description);\n                }\n            });\n        }\n        return descr;\n    }\n    createDescription(refInfo) {\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\n        const refCstNode = refInfo.reference.$refNode;\n        if (!targetNodeDescr || !refCstNode) {\n            return undefined;\n        }\n        const docUri = getDocument(refInfo.container).uri;\n        return {\n            sourceUri: docUri,\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n            targetUri: targetNodeDescr.documentUri,\n            targetPath: targetNodeDescr.path,\n            segment: toDocumentSegment(refCstNode),\n            local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\n        };\n    }\n}\n//# sourceMappingURL=ast-descriptions.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class DefaultAstNodeLocator {\n    constructor() {\n        this.segmentSeparator = '/';\n        this.indexSeparator = '@';\n    }\n    getAstNodePath(node) {\n        if (node.$container) {\n            const containerPath = this.getAstNodePath(node.$container);\n            const newSegment = this.getPathSegment(node);\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\n            return nodePath;\n        }\n        return '';\n    }\n    getPathSegment({ $containerProperty, $containerIndex }) {\n        if (!$containerProperty) {\n            throw new Error(\"Missing '$containerProperty' in AST node.\");\n        }\n        if ($containerIndex !== undefined) {\n            return $containerProperty + this.indexSeparator + $containerIndex;\n        }\n        return $containerProperty;\n    }\n    getAstNode(node, path) {\n        const segments = path.split(this.segmentSeparator);\n        return segments.reduce((previousValue, currentValue) => {\n            if (!previousValue || currentValue.length === 0) {\n                return previousValue;\n            }\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\n            if (propertyIndex > 0) {\n                const property = currentValue.substring(0, propertyIndex);\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n                const array = previousValue[property];\n                return array === null || array === void 0 ? void 0 : array[arrayIndex];\n            }\n            return previousValue[currentValue];\n        }, node);\n    }\n}\n//# sourceMappingURL=ast-node-locator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport var Disposable;\n(function (Disposable) {\n    function create(callback) {\n        return {\n            dispose: async () => await callback()\n        };\n    }\n    Disposable.create = create;\n})(Disposable || (Disposable = {}));\n//# sourceMappingURL=disposable.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Emitter } from '../utils/event.js';\nimport { Deferred } from '../utils/promise-utils.js';\n/**\n * Base configuration provider for building up other configuration providers\n */\nexport class DefaultConfigurationProvider {\n    constructor(services) {\n        this._ready = new Deferred();\n        this.settings = {};\n        this.workspaceConfig = false;\n        this.onConfigurationSectionUpdateEmitter = new Emitter();\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a, _b;\n        this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;\n    }\n    async initialized(params) {\n        if (this.workspaceConfig) {\n            if (params.register) {\n                // params.register(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const languages = this.serviceRegistry.all;\n                params.register({\n                    // Listen to configuration changes for all languages\n                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\n                });\n            }\n            if (params.fetchConfiguration) {\n                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const configToUpdate = this.serviceRegistry.all.map(lang => ({\n                    // Fetch the configuration changes for all languages\n                    section: this.toSectionName(lang.LanguageMetaData.languageId)\n                }));\n                // get workspace configurations (default scope URI)\n                const configs = await params.fetchConfiguration(configToUpdate);\n                configToUpdate.forEach((conf, idx) => {\n                    this.updateSectionConfiguration(conf.section, configs[idx]);\n                });\n            }\n        }\n        this._ready.resolve();\n    }\n    /**\n     *  Updates the cached configurations using the `change` notification parameters.\n     *\n     * @param change The parameters of a change configuration notification.\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n     */\n    updateConfiguration(change) {\n        if (!change.settings) {\n            return;\n        }\n        Object.keys(change.settings).forEach(section => {\n            const configuration = change.settings[section];\n            this.updateSectionConfiguration(section, configuration);\n            this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });\n        });\n    }\n    updateSectionConfiguration(section, configuration) {\n        this.settings[section] = configuration;\n    }\n    /**\n    * Returns a configuration value stored for the given language.\n    *\n    * @param language The language id\n    * @param configuration Configuration name\n    */\n    async getConfiguration(language, configuration) {\n        await this.ready;\n        const sectionName = this.toSectionName(language);\n        if (this.settings[sectionName]) {\n            return this.settings[sectionName][configuration];\n        }\n    }\n    toSectionName(languageId) {\n        return `${languageId}`;\n    }\n    get onConfigurationSectionUpdate() {\n        return this.onConfigurationSectionUpdateEmitter.event;\n    }\n}\n//# sourceMappingURL=configuration.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Disposable } from '../utils/disposable.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { OperationCancelled, interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { ValidationCategory } from '../validation/validation-registry.js';\nimport { DocumentState } from './documents.js';\nexport class DefaultDocumentBuilder {\n    constructor(services) {\n        this.updateBuildOptions = {\n            // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n            validation: {\n                categories: ['built-in', 'fast']\n            }\n        };\n        this.updateListeners = [];\n        this.buildPhaseListeners = new MultiMap();\n        this.documentPhaseListeners = new MultiMap();\n        this.buildState = new Map();\n        this.documentBuildWaiters = new Map();\n        this.currentState = DocumentState.Changed;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.indexManager = services.workspace.IndexManager;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    async build(documents, options = {}, cancelToken = CancellationToken.None) {\n        var _a, _b;\n        for (const document of documents) {\n            const key = document.uri.toString();\n            if (document.state === DocumentState.Validated) {\n                if (typeof options.validation === 'boolean' && options.validation) {\n                    // Force re-running all validation checks\n                    document.state = DocumentState.IndexedReferences;\n                    document.diagnostics = undefined;\n                    this.buildState.delete(key);\n                }\n                else if (typeof options.validation === 'object') {\n                    const buildState = this.buildState.get(key);\n                    const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;\n                    if (previousCategories) {\n                        // Validation with explicit options was requested for a document that has already been partly validated.\n                        // In this case, we need to merge the previous validation categories with the new ones.\n                        const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\n                        if (categories.length > 0) {\n                            this.buildState.set(key, {\n                                completed: false,\n                                options: {\n                                    validation: Object.assign(Object.assign({}, options.validation), { categories })\n                                },\n                                result: buildState.result\n                            });\n                            document.state = DocumentState.IndexedReferences;\n                        }\n                    }\n                }\n            }\n            else {\n                // Default: forget any previous build options\n                this.buildState.delete(key);\n            }\n        }\n        this.currentState = DocumentState.Changed;\n        await this.emitUpdate(documents.map(e => e.uri), []);\n        await this.buildDocuments(documents, options, cancelToken);\n    }\n    async update(changed, deleted, cancelToken = CancellationToken.None) {\n        this.currentState = DocumentState.Changed;\n        // Remove all metadata of documents that are reported as deleted\n        for (const deletedUri of deleted) {\n            this.langiumDocuments.deleteDocument(deletedUri);\n            this.buildState.delete(deletedUri.toString());\n            this.indexManager.remove(deletedUri);\n        }\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\n        for (const changedUri of changed) {\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n            if (!invalidated) {\n                // We create an unparsed, invalid document.\n                // This will be parsed as soon as we reach the first document builder phase.\n                // This allows to cancel the parsing process later in case we need it.\n                const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);\n                newDocument.state = DocumentState.Changed;\n                this.langiumDocuments.addDocument(newDocument);\n            }\n            this.buildState.delete(changedUri.toString());\n        }\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\n        const allChangedUris = stream(changed).concat(deleted).map(uri => uri.toString()).toSet();\n        this.langiumDocuments.all\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\n            .forEach(doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            linker.unlink(doc);\n            doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\n            doc.diagnostics = undefined;\n        });\n        // Notify listeners of the update\n        await this.emitUpdate(changed, deleted);\n        // Only allow interrupting the execution after all state changes are done\n        await interruptAndCheck(cancelToken);\n        // Collect and sort all documents that we should rebuild\n        const rebuildDocuments = this.sortDocuments(this.langiumDocuments.all\n            .filter(doc => {\n            var _a;\n            // This includes those that were reported as changed and those that we selected for relinking\n            return doc.state < DocumentState.Linked\n                // This includes those for which a previous build has been cancelled\n                || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);\n        })\n            .toArray());\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n    }\n    async emitUpdate(changed, deleted) {\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\n    }\n    /**\n     * Sort the given documents by priority. By default, documents with an open text document are prioritized.\n     * This is useful to ensure that visible documents show their diagnostics before all other documents.\n     *\n     * This improves the responsiveness in large workspaces as users usually don't care about diagnostics\n     * in files that are currently not opened in the editor.\n     */\n    sortDocuments(documents) {\n        let left = 0;\n        let right = documents.length - 1;\n        while (left < right) {\n            while (left < documents.length && this.hasTextDocument(documents[left])) {\n                left++;\n            }\n            while (right >= 0 && !this.hasTextDocument(documents[right])) {\n                right--;\n            }\n            if (left < right) {\n                [documents[left], documents[right]] = [documents[right], documents[left]];\n            }\n        }\n        return documents;\n    }\n    hasTextDocument(doc) {\n        var _a;\n        return Boolean((_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(doc.uri));\n    }\n    /**\n     * Check whether the given document should be relinked after changes were found in the given URIs.\n     */\n    shouldRelink(document, changedUris) {\n        // Relink documents with linking errors -- maybe those references can be resolved now\n        if (document.references.some(ref => ref.error !== undefined)) {\n            return true;\n        }\n        // Check whether the document is affected by any of the changed URIs\n        return this.indexManager.isAffected(document, changedUris);\n    }\n    onUpdate(callback) {\n        this.updateListeners.push(callback);\n        return Disposable.create(() => {\n            const index = this.updateListeners.indexOf(callback);\n            if (index >= 0) {\n                this.updateListeners.splice(index, 1);\n            }\n        });\n    }\n    /**\n     * Build the given documents by stepping through all build phases. If a document's state indicates\n     * that a certain build phase is already done, the phase is skipped for that document.\n     *\n     * @param documents The documents to build.\n     * @param options the {@link BuildOptions} to use.\n     * @param cancelToken A cancellation token that can be used to cancel the build.\n     * @returns A promise that resolves when the build is done.\n     */\n    async buildDocuments(documents, options, cancelToken) {\n        this.prepareBuild(documents, options);\n        // 0. Parse content\n        await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc => this.langiumDocumentFactory.update(doc, cancelToken));\n        // 1. Index content\n        await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc => this.indexManager.updateContent(doc, cancelToken));\n        // 2. Compute scopes\n        await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) => {\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n        });\n        // 3. Linking\n        await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            return linker.link(doc, cancelToken);\n        });\n        // 4. Index references\n        await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc => this.indexManager.updateReferences(doc, cancelToken));\n        // 5. Validation\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\n        await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc => this.validate(doc, cancelToken));\n        // If we've made it to this point without being cancelled, we can mark the build state as completed.\n        for (const doc of documents) {\n            const state = this.buildState.get(doc.uri.toString());\n            if (state) {\n                state.completed = true;\n            }\n        }\n    }\n    /**\n     * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document\n     *\n     * @param documents collection of documents to be built\n     * @param options the {@link BuildOptions} to use\n     */\n    prepareBuild(documents, options) {\n        for (const doc of documents) {\n            const key = doc.uri.toString();\n            const state = this.buildState.get(key);\n            // If the document has no previous build state, we set it. If it has one, but it's already marked\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\n            // and continue where it was cancelled.\n            if (!state || state.completed) {\n                this.buildState.set(key, {\n                    completed: false,\n                    options,\n                    result: state === null || state === void 0 ? void 0 : state.result\n                });\n            }\n        }\n    }\n    /**\n     * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.\n     *\n     * @param documents The array of documents to process.\n     * @param targetState The target {@link DocumentState} to bring the documents to.\n     * @param cancelToken A token that can be used to cancel the operation.\n     * @param callback A function to be called for each document.\n     * @returns A promise that resolves when all documents have been processed or the operation is canceled.\n     * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.\n     */\n    async runCancelable(documents, targetState, cancelToken, callback) {\n        const filtered = documents.filter(doc => doc.state < targetState);\n        for (const document of filtered) {\n            await interruptAndCheck(cancelToken);\n            await callback(document);\n            document.state = targetState;\n            await this.notifyDocumentPhase(document, targetState, cancelToken);\n        }\n        // Do not use `filtered` here, as that will miss documents that have previously reached the current target state\n        // For example, this happens in case the cancellation triggers between the processing of two documents\n        // Or files that were picked up during the workspace initialization\n        const targetStateDocs = documents.filter(doc => doc.state === targetState);\n        await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);\n        this.currentState = targetState;\n    }\n    onBuildPhase(targetState, callback) {\n        this.buildPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.buildPhaseListeners.delete(targetState, callback);\n        });\n    }\n    onDocumentPhase(targetState, callback) {\n        this.documentPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.documentPhaseListeners.delete(targetState, callback);\n        });\n    }\n    waitUntil(state, uriOrToken, cancelToken) {\n        let uri = undefined;\n        if (uriOrToken && 'path' in uriOrToken) {\n            uri = uriOrToken;\n        }\n        else {\n            cancelToken = uriOrToken;\n        }\n        cancelToken !== null && cancelToken !== void 0 ? cancelToken : (cancelToken = CancellationToken.None);\n        if (uri) {\n            const document = this.langiumDocuments.getDocument(uri);\n            if (document && document.state > state) {\n                return Promise.resolve(uri);\n            }\n        }\n        if (this.currentState >= state) {\n            return Promise.resolve(undefined);\n        }\n        else if (cancelToken.isCancellationRequested) {\n            return Promise.reject(OperationCancelled);\n        }\n        return new Promise((resolve, reject) => {\n            const buildDisposable = this.onBuildPhase(state, () => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                if (uri) {\n                    const document = this.langiumDocuments.getDocument(uri);\n                    resolve(document === null || document === void 0 ? void 0 : document.uri);\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n            const cancelDisposable = cancelToken.onCancellationRequested(() => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                reject(OperationCancelled);\n            });\n        });\n    }\n    async notifyDocumentPhase(document, state, cancelToken) {\n        const listeners = this.documentPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            try {\n                await listener(document, cancelToken);\n            }\n            catch (err) {\n                // Ignore cancellation errors\n                // We want to finish the listeners before throwing\n                if (!isOperationCancelled(err)) {\n                    throw err;\n                }\n            }\n        }\n    }\n    async notifyBuildPhase(documents, state, cancelToken) {\n        if (documents.length === 0) {\n            // Don't notify when no document has been processed\n            return;\n        }\n        const listeners = this.buildPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            await interruptAndCheck(cancelToken);\n            await listener(documents, cancelToken);\n        }\n    }\n    /**\n     * Determine whether the given document should be validated during a build. The default\n     * implementation checks the `validation` property of the build options. If it's set to `true`\n     * or a `ValidationOptions` object, the document is included in the validation phase.\n     */\n    shouldValidate(document) {\n        return Boolean(this.getBuildOptions(document).validation);\n    }\n    /**\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\n     * If the document already contains diagnostics, the new ones are added to the list.\n     */\n    async validate(document, cancelToken) {\n        var _a, _b;\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n        const validationSetting = this.getBuildOptions(document).validation;\n        const options = typeof validationSetting === 'object' ? validationSetting : undefined;\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\n        if (document.diagnostics) {\n            document.diagnostics.push(...diagnostics);\n        }\n        else {\n            document.diagnostics = diagnostics;\n        }\n        // Store information about the executed validation in the build state\n        const state = this.buildState.get(document.uri.toString());\n        if (state) {\n            (_a = state.result) !== null && _a !== void 0 ? _a : (state.result = {});\n            const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n            if (state.result.validationChecks) {\n                state.result.validationChecks.push(...newCategories);\n            }\n            else {\n                state.result.validationChecks = [...newCategories];\n            }\n        }\n    }\n    getBuildOptions(document) {\n        var _a, _b;\n        return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};\n    }\n}\n//# sourceMappingURL=document-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { getDocument } from '../utils/ast-utils.js';\nimport { ContextCache } from '../utils/caching.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultIndexManager {\n    constructor(services) {\n        /**\n         * The symbol index stores all `AstNodeDescription` items exported by a document.\n         * The key used in this map is the string representation of the specific document URI.\n         */\n        this.symbolIndex = new Map();\n        /**\n         * This is a cache for the `allElements()` method.\n         * It caches the descriptions from `symbolIndex` grouped by types.\n         */\n        this.symbolByTypeIndex = new ContextCache();\n        /**\n         * This index keeps track of all `ReferenceDescription` items exported by a document.\n         * This is used to compute which elements are affected by a document change\n         * and for finding references to an AST node.\n         */\n        this.referenceIndex = new Map();\n        this.documents = services.workspace.LangiumDocuments;\n        this.serviceRegistry = services.ServiceRegistry;\n        this.astReflection = services.AstReflection;\n    }\n    findAllReferences(targetNode, astNodePath) {\n        const targetDocUri = getDocument(targetNode).uri;\n        const result = [];\n        this.referenceIndex.forEach(docRefs => {\n            docRefs.forEach(refDescr => {\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n                    result.push(refDescr);\n                }\n            });\n        });\n        return stream(result);\n    }\n    allElements(nodeType, uris) {\n        let documentUris = stream(this.symbolIndex.keys());\n        if (uris) {\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\n        }\n        return documentUris\n            .map(uri => this.getFileDescriptions(uri, nodeType))\n            .flat();\n    }\n    getFileDescriptions(uri, nodeType) {\n        var _a;\n        if (!nodeType) {\n            return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n        }\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n            var _a;\n            const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\n        });\n        return descriptions;\n    }\n    remove(uri) {\n        const uriString = uri.toString();\n        this.symbolIndex.delete(uriString);\n        this.symbolByTypeIndex.clear(uriString);\n        this.referenceIndex.delete(uriString);\n    }\n    async updateContent(document, cancelToken = CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n        const uri = document.uri.toString();\n        this.symbolIndex.set(uri, exports);\n        this.symbolByTypeIndex.clear(uri);\n    }\n    async updateReferences(document, cancelToken = CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n        this.referenceIndex.set(document.uri.toString(), indexData);\n    }\n    isAffected(document, changedUris) {\n        const references = this.referenceIndex.get(document.uri.toString());\n        if (!references) {\n            return false;\n        }\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\n    }\n}\n//# sourceMappingURL=index-manager.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Deferred, interruptAndCheck } from '../utils/promise-utils.js';\nimport { URI, UriUtils } from '../utils/uri-utils.js';\nexport class DefaultWorkspaceManager {\n    constructor(services) {\n        this.initialBuildOptions = {};\n        this._ready = new Deferred();\n        this.serviceRegistry = services.ServiceRegistry;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.documentBuilder = services.workspace.DocumentBuilder;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n        this.mutex = services.workspace.WorkspaceLock;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    get workspaceFolders() {\n        return this.folders;\n    }\n    initialize(params) {\n        var _a;\n        this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : undefined;\n    }\n    initialized(_params) {\n        // Initialize the workspace even if there are no workspace folders\n        // We still want to load additional documents (language library or similar) during initialization\n        return this.mutex.write(token => { var _a; return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token); });\n    }\n    async initializeWorkspace(folders, cancelToken = CancellationToken.None) {\n        const documents = await this.performStartup(folders);\n        // Only after creating all documents do we check whether we need to cancel the initialization\n        // The document builder will later pick up on all unprocessed documents\n        await interruptAndCheck(cancelToken);\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n    }\n    /**\n     * Performs the uninterruptable startup sequence of the workspace manager.\n     * This methods loads all documents in the workspace and other documents and returns them.\n     */\n    async performStartup(folders) {\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\n        const documents = [];\n        const collector = (document) => {\n            documents.push(document);\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\n                this.langiumDocuments.addDocument(document);\n            }\n        };\n        // Even though we don't await the initialization of the workspace manager,\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\n        await this.loadAdditionalDocuments(folders, collector);\n        await Promise.all(folders.map(wf => [wf, this.getRootFolder(wf)])\n            .map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));\n        this._ready.resolve();\n        return documents;\n    }\n    /**\n     * Load all additional documents that shall be visible in the context of the given workspace\n     * folders and add them to the collector. This can be used to include built-in libraries of\n     * your language, which can be either loaded from provided files or constructed in memory.\n     */\n    loadAdditionalDocuments(_folders, _collector) {\n        return Promise.resolve();\n    }\n    /**\n     * Determine the root folder of the source documents in the given workspace folder.\n     * The default implementation returns the URI of the workspace folder, but you can override\n     * this to return a subfolder like `src` instead.\n     */\n    getRootFolder(workspaceFolder) {\n        return URI.parse(workspaceFolder.uri);\n    }\n    /**\n     * Traverse the file system folder identified by the given URI and its subfolders. All\n     * contained files that match the file extensions are added to the collector.\n     */\n    async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\n        await Promise.all(content.map(async (entry) => {\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n                if (entry.isDirectory) {\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n                }\n                else if (entry.isFile) {\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n                    collector(document);\n                }\n            }\n        }));\n    }\n    /**\n     * Determine whether the given folder entry shall be included while indexing the workspace.\n     */\n    includeEntry(_workspaceFolder, entry, fileExtensions) {\n        const name = UriUtils.basename(entry.uri);\n        if (name.startsWith('.')) {\n            return false;\n        }\n        if (entry.isDirectory) {\n            return name !== 'node_modules' && name !== 'out';\n        }\n        else if (entry.isFile) {\n            const extname = UriUtils.extname(entry.uri);\n            return fileExtensions.includes(extname);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=workspace-manager.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Lexer as ChevrotainLexer, defaultLexerErrorProvider } from 'chevrotain';\nexport class DefaultLexerErrorMessageProvider {\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);\n    }\n    buildUnableToPopLexerModeMessage(token) {\n        return defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);\n    }\n}\nexport const DEFAULT_TOKENIZE_OPTIONS = { mode: 'full' };\nexport class DefaultLexer {\n    constructor(services) {\n        this.errorMessageProvider = services.parser.LexerErrorMessageProvider;\n        this.tokenBuilder = services.parser.TokenBuilder;\n        const tokens = this.tokenBuilder.buildTokens(services.Grammar, {\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\n        });\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.chevrotainLexer = new ChevrotainLexer(lexerTokens, {\n            positionTracking: 'full',\n            skipValidations: production,\n            errorMessageProvider: this.errorMessageProvider\n        });\n    }\n    get definition() {\n        return this.tokenTypes;\n    }\n    tokenize(text, _options = DEFAULT_TOKENIZE_OPTIONS) {\n        var _a, _b, _c;\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\n        return {\n            tokens: chevrotainResult.tokens,\n            errors: chevrotainResult.errors,\n            hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : [],\n            report: (_c = (_b = this.tokenBuilder).flushLexingReport) === null || _c === void 0 ? void 0 : _c.call(_b, text)\n        };\n    }\n    toTokenTypeDictionary(buildTokens) {\n        if (isTokenTypeDictionary(buildTokens))\n            return buildTokens;\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n        const res = {};\n        tokens.forEach(token => res[token.name] = token);\n        return res;\n    }\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenType array\n */\nexport function isTokenTypeArray(tokenVocabulary) {\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);\n}\n/**\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\n */\nexport function isIMultiModeLexerDefinition(tokenVocabulary) {\n    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\n */\nexport function isTokenTypeDictionary(tokenVocabulary) {\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\n//# sourceMappingURL=lexer.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Position, Range } from 'vscode-languageserver-types';\nimport { NEWLINE_REGEXP, escapeRegExp } from '../utils/regexp-utils.js';\nimport { URI } from '../utils/uri-utils.js';\nexport function parseJSDoc(node, start, options) {\n    let opts;\n    let position;\n    if (typeof node === 'string') {\n        position = start;\n        opts = options;\n    }\n    else {\n        position = node.range.start;\n        opts = start;\n    }\n    if (!position) {\n        position = Position.create(0, 0);\n    }\n    const lines = getLines(node);\n    const normalizedOptions = normalizeOptions(opts);\n    const tokens = tokenize({\n        lines,\n        position,\n        options: normalizedOptions\n    });\n    return parseJSDocComment({\n        index: 0,\n        tokens,\n        position\n    });\n}\nexport function isJSDoc(node, options) {\n    const normalizedOptions = normalizeOptions(options);\n    const lines = getLines(node);\n    if (lines.length === 0) {\n        return false;\n    }\n    const first = lines[0];\n    const last = lines[lines.length - 1];\n    const firstRegex = normalizedOptions.start;\n    const lastRegex = normalizedOptions.end;\n    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));\n}\nfunction getLines(node) {\n    let content = '';\n    if (typeof node === 'string') {\n        content = node;\n    }\n    else {\n        content = node.text;\n    }\n    const lines = content.split(NEWLINE_REGEXP);\n    return lines;\n}\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction tokenize(context) {\n    var _a, _b, _c;\n    const tokens = [];\n    let currentLine = context.position.line;\n    let currentCharacter = context.position.character;\n    for (let i = 0; i < context.lines.length; i++) {\n        const first = i === 0;\n        const last = i === context.lines.length - 1;\n        let line = context.lines[i];\n        let index = 0;\n        if (first && context.options.start) {\n            const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        else {\n            const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        if (last) {\n            const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);\n            if (match) {\n                line = line.substring(0, match.index);\n            }\n        }\n        line = line.substring(0, lastCharacter(line));\n        const whitespaceEnd = skipWhitespace(line, index);\n        if (whitespaceEnd >= line.length) {\n            // Only create a break token when we already have previous tokens\n            if (tokens.length > 0) {\n                const position = Position.create(currentLine, currentCharacter);\n                tokens.push({\n                    type: 'break',\n                    content: '',\n                    range: Range.create(position, position)\n                });\n            }\n        }\n        else {\n            tagRegex.lastIndex = index;\n            const tagMatch = tagRegex.exec(line);\n            if (tagMatch) {\n                const fullMatch = tagMatch[0];\n                const value = tagMatch[1];\n                const start = Position.create(currentLine, currentCharacter + index);\n                const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\n                tokens.push({\n                    type: 'tag',\n                    content: value,\n                    range: Range.create(start, end)\n                });\n                index += fullMatch.length;\n                index = skipWhitespace(line, index);\n            }\n            if (index < line.length) {\n                const rest = line.substring(index);\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n            }\n        }\n        currentLine++;\n        currentCharacter = 0;\n    }\n    // Remove last break token if there is one\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {\n        return tokens.slice(0, -1);\n    }\n    return tokens;\n}\nfunction buildInlineTokens(tags, line, lineIndex, characterIndex) {\n    const tokens = [];\n    if (tags.length === 0) {\n        const start = Position.create(lineIndex, characterIndex);\n        const end = Position.create(lineIndex, characterIndex + line.length);\n        tokens.push({\n            type: 'text',\n            content: line,\n            range: Range.create(start, end)\n        });\n    }\n    else {\n        let lastIndex = 0;\n        for (const match of tags) {\n            const matchIndex = match.index;\n            const startContent = line.substring(lastIndex, matchIndex);\n            if (startContent.length > 0) {\n                tokens.push({\n                    type: 'text',\n                    content: line.substring(lastIndex, matchIndex),\n                    range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))\n                });\n            }\n            let offset = startContent.length + 1;\n            const tagName = match[1];\n            tokens.push({\n                type: 'inline-tag',\n                content: tagName,\n                range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n            });\n            offset += tagName.length;\n            if (match.length === 4) {\n                offset += match[2].length;\n                const value = match[3];\n                tokens.push({\n                    type: 'text',\n                    content: value,\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n                });\n            }\n            else {\n                tokens.push({\n                    type: 'text',\n                    content: '',\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))\n                });\n            }\n            lastIndex = matchIndex + match[0].length;\n        }\n        const endContent = line.substring(lastIndex);\n        if (endContent.length > 0) {\n            tokens.push({\n                type: 'text',\n                content: endContent,\n                range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n            });\n        }\n    }\n    return tokens;\n}\nconst nonWhitespaceRegex = /\\S/;\nconst whitespaceEndRegex = /\\s*$/;\nfunction skipWhitespace(line, index) {\n    const match = line.substring(index).match(nonWhitespaceRegex);\n    if (match) {\n        return index + match.index;\n    }\n    else {\n        return line.length;\n    }\n}\nfunction lastCharacter(line) {\n    const match = line.match(whitespaceEndRegex);\n    if (match && typeof match.index === 'number') {\n        return match.index;\n    }\n    return undefined;\n}\n// Parsing\nfunction parseJSDocComment(context) {\n    var _a, _b, _c, _d;\n    const startPosition = Position.create(context.position.line, context.position.character);\n    if (context.tokens.length === 0) {\n        return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\n    }\n    const elements = [];\n    while (context.index < context.tokens.length) {\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\n        if (element) {\n            elements.push(element);\n        }\n    }\n    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;\n    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;\n    return new JSDocCommentImpl(elements, Range.create(start, end));\n}\nfunction parseJSDocElement(context, last) {\n    const next = context.tokens[context.index];\n    if (next.type === 'tag') {\n        return parseJSDocTag(context, false);\n    }\n    else if (next.type === 'text' || next.type === 'inline-tag') {\n        return parseJSDocText(context);\n    }\n    else {\n        appendEmptyLine(next, last);\n        context.index++;\n        return undefined;\n    }\n}\nfunction appendEmptyLine(token, element) {\n    if (element) {\n        const line = new JSDocLineImpl('', token.range);\n        if ('inlines' in element) {\n            element.inlines.push(line);\n        }\n        else {\n            element.content.inlines.push(line);\n        }\n    }\n}\nfunction parseJSDocText(context) {\n    let token = context.tokens[context.index];\n    const firstToken = token;\n    let lastToken = token;\n    const lines = [];\n    while (token && token.type !== 'break' && token.type !== 'tag') {\n        lines.push(parseJSDocInline(context));\n        lastToken = token;\n        token = context.tokens[context.index];\n    }\n    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\n}\nfunction parseJSDocInline(context) {\n    const token = context.tokens[context.index];\n    if (token.type === 'inline-tag') {\n        return parseJSDocTag(context, true);\n    }\n    else {\n        return parseJSDocLine(context);\n    }\n}\nfunction parseJSDocTag(context, inline) {\n    const tagToken = context.tokens[context.index++];\n    const name = tagToken.content.substring(1);\n    const nextToken = context.tokens[context.index];\n    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'text') {\n        if (inline) {\n            const docLine = parseJSDocLine(context);\n            return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));\n        }\n        else {\n            const textDoc = parseJSDocText(context);\n            return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));\n        }\n    }\n    else {\n        const range = tagToken.range;\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n    }\n}\nfunction parseJSDocLine(context) {\n    const token = context.tokens[context.index++];\n    return new JSDocLineImpl(token.content, token.range);\n}\nfunction normalizeOptions(options) {\n    if (!options) {\n        return normalizeOptions({\n            start: '/**',\n            end: '*/',\n            line: '*'\n        });\n    }\n    const { start, end, line } = options;\n    return {\n        start: normalizeOption(start, true),\n        end: normalizeOption(end, false),\n        line: normalizeOption(line, true)\n    };\n}\nfunction normalizeOption(option, start) {\n    if (typeof option === 'string' || typeof option === 'object') {\n        const escaped = typeof option === 'string' ? escapeRegExp(option) : option.source;\n        if (start) {\n            return new RegExp(`^\\\\s*${escaped}`);\n        }\n        else {\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n        }\n    }\n    else {\n        return option;\n    }\n}\nclass JSDocCommentImpl {\n    constructor(elements, range) {\n        this.elements = elements;\n        this.range = range;\n    }\n    getTag(name) {\n        return this.getAllTags().find(e => e.name === name);\n    }\n    getTags(name) {\n        return this.getAllTags().filter(e => e.name === name);\n    }\n    getAllTags() {\n        return this.elements.filter((e) => 'name' in e);\n    }\n    toString() {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toString();\n            }\n            else {\n                const text = element.toString();\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n    toMarkdown(options) {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toMarkdown(options);\n            }\n            else {\n                const text = element.toMarkdown(options);\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n}\nclass JSDocTagImpl {\n    constructor(name, content, inline, range) {\n        this.name = name;\n        this.content = content;\n        this.inline = inline;\n        this.range = range;\n    }\n    toString() {\n        let text = `@${this.name}`;\n        const content = this.content.toString();\n        if (this.content.inlines.length === 1) {\n            text = `${text} ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n    toMarkdown(options) {\n        var _a, _b;\n        return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);\n    }\n    toMarkdownDefault(options) {\n        const content = this.content.toMarkdown(options);\n        if (this.inline) {\n            const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n            if (typeof rendered === 'string') {\n                return rendered;\n            }\n        }\n        let marker = '';\n        if ((options === null || options === void 0 ? void 0 : options.tag) === 'italic' || (options === null || options === void 0 ? void 0 : options.tag) === undefined) {\n            marker = '*';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold') {\n            marker = '**';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold-italic') {\n            marker = '***';\n        }\n        let text = `${marker}@${this.name}${marker}`;\n        if (this.content.inlines.length === 1) {\n            text = `${text}  ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n}\nfunction renderInlineTag(tag, content, options) {\n    var _a, _b;\n    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {\n        const index = content.indexOf(' ');\n        let display = content;\n        if (index > 0) {\n            const displayStart = skipWhitespace(content, index);\n            display = content.substring(displayStart);\n            content = content.substring(0, index);\n        }\n        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {\n            // Surround the display value in a markdown inline code block\n            display = `\\`${display}\\``;\n        }\n        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);\n        return renderedLink;\n    }\n    return undefined;\n}\nfunction renderLinkDefault(content, display) {\n    try {\n        URI.parse(content, true);\n        return `[${display}](${content})`;\n    }\n    catch (_a) {\n        return content;\n    }\n}\nclass JSDocTextImpl {\n    constructor(lines, range) {\n        this.inlines = lines;\n        this.range = range;\n    }\n    toString() {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toString();\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n    toMarkdown(options) {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toMarkdown(options);\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n}\nclass JSDocLineImpl {\n    constructor(text, range) {\n        this.text = text;\n        this.range = range;\n    }\n    toString() {\n        return this.text;\n    }\n    toMarkdown() {\n        return this.text;\n    }\n}\nfunction fillNewlines(text) {\n    if (text.endsWith('\\n')) {\n        return '\\n';\n    }\n    else {\n        return '\\n\\n';\n    }\n}\n//# sourceMappingURL=jsdoc.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isJSDoc, parseJSDoc } from './jsdoc.js';\nexport class JSDocDocumentationProvider {\n    constructor(services) {\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    getDocumentation(node) {\n        const comment = this.commentProvider.getComment(node);\n        if (comment && isJSDoc(comment)) {\n            const parsedJSDoc = parseJSDoc(comment);\n            return parsedJSDoc.toMarkdown({\n                renderLink: (link, display) => {\n                    return this.documentationLinkRenderer(node, link, display);\n                },\n                renderTag: (tag) => {\n                    return this.documentationTagRenderer(node, tag);\n                }\n            });\n        }\n        return undefined;\n    }\n    documentationLinkRenderer(node, name, display) {\n        var _a;\n        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);\n        if (description && description.nameSegment) {\n            const line = description.nameSegment.range.start.line + 1;\n            const character = description.nameSegment.range.start.character + 1;\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n            return `[${display}](${uri.toString()})`;\n        }\n        else {\n            return undefined;\n        }\n    }\n    documentationTagRenderer(_node, _tag) {\n        // Fall back to the default tag rendering\n        return undefined;\n    }\n    findNameInPrecomputedScopes(node, name) {\n        const document = getDocument(node);\n        const precomputed = document.precomputedScopes;\n        if (!precomputed) {\n            return undefined;\n        }\n        let currentNode = node;\n        do {\n            const allDescriptions = precomputed.get(currentNode);\n            const description = allDescriptions.find(e => e.name === name);\n            if (description) {\n                return description;\n            }\n            currentNode = currentNode.$container;\n        } while (currentNode);\n        return undefined;\n    }\n    findNameInGlobalScope(node, name) {\n        const description = this.indexManager.allElements().find(e => e.name === name);\n        return description;\n    }\n}\n//# sourceMappingURL=documentation-provider.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isAstNodeWithComment } from '../serializer/json-serializer.js';\nimport { findCommentNode } from '../utils/cst-utils.js';\nexport class DefaultCommentProvider {\n    constructor(services) {\n        this.grammarConfig = () => services.parser.GrammarConfig;\n    }\n    getComment(node) {\n        var _a;\n        if (isAstNodeWithComment(node)) {\n            return node.$comment;\n        }\n        return (_a = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;\n    }\n}\n//# sourceMappingURL=comment-provider.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Deferred, OperationCancelled } from '../utils/promise-utils.js';\nimport { Emitter } from '../utils/event.js';\n/**\n * Default implementation of the async parser which simply wraps the sync parser in a promise.\n *\n * @remarks\n * A real implementation would create worker threads or web workers to offload the parsing work.\n */\nexport class DefaultAsyncParser {\n    constructor(services) {\n        this.syncParser = services.parser.LangiumParser;\n    }\n    parse(text, _cancelToken) {\n        return Promise.resolve(this.syncParser.parse(text));\n    }\n}\nexport class AbstractThreadedAsyncParser {\n    constructor(services) {\n        /**\n         * The thread count determines how many threads are used to parse files in parallel.\n         * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.\n         */\n        this.threadCount = 8;\n        /**\n         * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.\n         * The default value is 200(ms).\n         */\n        this.terminationDelay = 200;\n        this.workerPool = [];\n        this.queue = [];\n        this.hydrator = services.serializer.Hydrator;\n    }\n    initializeWorkers() {\n        while (this.workerPool.length < this.threadCount) {\n            const worker = this.createWorker();\n            worker.onReady(() => {\n                if (this.queue.length > 0) {\n                    const deferred = this.queue.shift();\n                    if (deferred) {\n                        worker.lock();\n                        deferred.resolve(worker);\n                    }\n                }\n            });\n            this.workerPool.push(worker);\n        }\n    }\n    async parse(text, cancelToken) {\n        const worker = await this.acquireParserWorker(cancelToken);\n        const deferred = new Deferred();\n        let timeout;\n        // If the cancellation token is requested, we wait for a certain time before terminating the worker.\n        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.\n        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.\n        const cancellation = cancelToken.onCancellationRequested(() => {\n            timeout = setTimeout(() => {\n                this.terminateWorker(worker);\n            }, this.terminationDelay);\n        });\n        worker.parse(text).then(result => {\n            const hydrated = this.hydrator.hydrate(result);\n            deferred.resolve(hydrated);\n        }).catch(err => {\n            deferred.reject(err);\n        }).finally(() => {\n            cancellation.dispose();\n            clearTimeout(timeout);\n        });\n        return deferred.promise;\n    }\n    terminateWorker(worker) {\n        worker.terminate();\n        const index = this.workerPool.indexOf(worker);\n        if (index >= 0) {\n            this.workerPool.splice(index, 1);\n        }\n    }\n    async acquireParserWorker(cancelToken) {\n        this.initializeWorkers();\n        for (const worker of this.workerPool) {\n            if (worker.ready) {\n                worker.lock();\n                return worker;\n            }\n        }\n        const deferred = new Deferred();\n        cancelToken.onCancellationRequested(() => {\n            const index = this.queue.indexOf(deferred);\n            if (index >= 0) {\n                this.queue.splice(index, 1);\n            }\n            deferred.reject(OperationCancelled);\n        });\n        this.queue.push(deferred);\n        return deferred.promise;\n    }\n}\nexport class ParserWorker {\n    get ready() {\n        return this._ready;\n    }\n    get onReady() {\n        return this.onReadyEmitter.event;\n    }\n    constructor(sendMessage, onMessage, onError, terminate) {\n        this.onReadyEmitter = new Emitter();\n        this.deferred = new Deferred();\n        this._ready = true;\n        this._parsing = false;\n        this.sendMessage = sendMessage;\n        this._terminate = terminate;\n        onMessage(result => {\n            const parseResult = result;\n            this.deferred.resolve(parseResult);\n            this.unlock();\n        });\n        onError(error => {\n            this.deferred.reject(error);\n            this.unlock();\n        });\n    }\n    terminate() {\n        this.deferred.reject(OperationCancelled);\n        this._terminate();\n    }\n    lock() {\n        this._ready = false;\n    }\n    unlock() {\n        this._parsing = false;\n        this._ready = true;\n        this.onReadyEmitter.fire();\n    }\n    parse(text) {\n        if (this._parsing) {\n            throw new Error('Parser worker is busy');\n        }\n        this._parsing = true;\n        this.deferred = new Deferred();\n        this.sendMessage(text);\n        return this.deferred.promise;\n    }\n}\n//# sourceMappingURL=async-parser.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\nimport { Deferred, isOperationCancelled, startCancelableOperation } from '../utils/promise-utils.js';\nexport class DefaultWorkspaceLock {\n    constructor() {\n        this.previousTokenSource = new CancellationTokenSource();\n        this.writeQueue = [];\n        this.readQueue = [];\n        this.done = true;\n    }\n    write(action) {\n        this.cancelWrite();\n        const tokenSource = startCancelableOperation();\n        this.previousTokenSource = tokenSource;\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\n    }\n    read(action) {\n        return this.enqueue(this.readQueue, action);\n    }\n    enqueue(queue, action, cancellationToken = CancellationToken.None) {\n        const deferred = new Deferred();\n        const entry = {\n            action,\n            deferred,\n            cancellationToken\n        };\n        queue.push(entry);\n        this.performNextOperation();\n        return deferred.promise;\n    }\n    async performNextOperation() {\n        if (!this.done) {\n            return;\n        }\n        const entries = [];\n        if (this.writeQueue.length > 0) {\n            // Just perform the next write action\n            entries.push(this.writeQueue.shift());\n        }\n        else if (this.readQueue.length > 0) {\n            // Empty the read queue and perform all actions in parallel\n            entries.push(...this.readQueue.splice(0, this.readQueue.length));\n        }\n        else {\n            return;\n        }\n        this.done = false;\n        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n            try {\n                // Move the execution of the action to the next event loop tick via `Promise.resolve()`\n                const result = await Promise.resolve().then(() => action(cancellationToken));\n                deferred.resolve(result);\n            }\n            catch (err) {\n                if (isOperationCancelled(err)) {\n                    // If the operation was cancelled, we don't want to reject the promise\n                    deferred.resolve(undefined);\n                }\n                else {\n                    deferred.reject(err);\n                }\n            }\n        }));\n        this.done = true;\n        this.performNextOperation();\n    }\n    cancelWrite() {\n        this.previousTokenSource.cancel();\n    }\n}\n//# sourceMappingURL=workspace-lock.js.map","/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CompositeCstNodeImpl, LeafCstNodeImpl, RootCstNodeImpl } from '../parser/cst-node-builder.js';\nimport { isAbstractElement } from '../languages/generated/ast.js';\nimport { isRootCstNode, isCompositeCstNode, isLeafCstNode, isAstNode, isReference } from '../syntax-tree.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { BiMap } from '../utils/collections.js';\nimport { streamCst } from '../utils/cst-utils.js';\nexport class DefaultHydrator {\n    constructor(services) {\n        this.grammarElementIdMap = new BiMap();\n        this.tokenTypeIdMap = new BiMap();\n        this.grammar = services.Grammar;\n        this.lexer = services.parser.Lexer;\n        this.linker = services.references.Linker;\n    }\n    dehydrate(result) {\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : undefined,\n            // We need to create shallow copies of the errors\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\n            parserErrors: result.parserErrors.map(e => (Object.assign(Object.assign({}, e), { message: e.message }))),\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n        };\n    }\n    dehydrateLexerReport(lexerReport) {\n        // By default, lexer reports are serializable\n        return lexerReport;\n    }\n    createDehyrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                cstNodes.set(cstNode, {});\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    dehydrateAstNode(node, context) {\n        const obj = context.astNodes.get(node);\n        obj.$type = node.$type;\n        obj.$containerIndex = node.$containerIndex;\n        obj.$containerProperty = node.$containerProperty;\n        if (node.$cstNode !== undefined) {\n            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                obj[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.dehydrateAstNode(item, context));\n                    }\n                    else if (isReference(item)) {\n                        arr.push(this.dehydrateReference(item, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (isAstNode(value)) {\n                obj[name] = this.dehydrateAstNode(value, context);\n            }\n            else if (isReference(value)) {\n                obj[name] = this.dehydrateReference(value, context);\n            }\n            else if (value !== undefined) {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n    dehydrateReference(reference, context) {\n        const obj = {};\n        obj.$refText = reference.$refText;\n        if (reference.$refNode) {\n            obj.$refNode = context.cstNodes.get(reference.$refNode);\n        }\n        return obj;\n    }\n    dehydrateCstNode(node, context) {\n        const cstNode = context.cstNodes.get(node);\n        if (isRootCstNode(node)) {\n            cstNode.fullText = node.fullText;\n        }\n        else {\n            // Note: This returns undefined for hidden nodes (i.e. comments)\n            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n        }\n        cstNode.hidden = node.hidden;\n        cstNode.astNode = context.astNodes.get(node.astNode);\n        if (isCompositeCstNode(node)) {\n            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));\n        }\n        else if (isLeafCstNode(node)) {\n            cstNode.tokenType = node.tokenType.name;\n            cstNode.offset = node.offset;\n            cstNode.length = node.length;\n            cstNode.startLine = node.range.start.line;\n            cstNode.startColumn = node.range.start.character;\n            cstNode.endLine = node.range.end.line;\n            cstNode.endColumn = node.range.end.character;\n        }\n        return cstNode;\n    }\n    hydrate(result) {\n        const node = result.value;\n        const context = this.createHydrationContext(node);\n        if ('$cstNode' in node) {\n            this.hydrateCstNode(node.$cstNode, context);\n        }\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport,\n            parserErrors: result.parserErrors,\n            value: this.hydrateAstNode(node, context)\n        };\n    }\n    createHydrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        let root;\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                let cst;\n                if ('fullText' in cstNode) {\n                    cst = new RootCstNodeImpl(cstNode.fullText);\n                    root = cst;\n                }\n                else if ('content' in cstNode) {\n                    cst = new CompositeCstNodeImpl();\n                }\n                else if ('tokenType' in cstNode) {\n                    cst = this.hydrateCstLeafNode(cstNode);\n                }\n                if (cst) {\n                    cstNodes.set(cstNode, cst);\n                    cst.root = root;\n                }\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    hydrateAstNode(node, context) {\n        const astNode = context.astNodes.get(node);\n        astNode.$type = node.$type;\n        astNode.$containerIndex = node.$containerIndex;\n        astNode.$containerProperty = node.$containerProperty;\n        if (node.$cstNode) {\n            astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                astNode[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n                    }\n                    else if (isReference(item)) {\n                        arr.push(this.hydrateReference(item, astNode, name, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (isAstNode(value)) {\n                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n            }\n            else if (isReference(value)) {\n                astNode[name] = this.hydrateReference(value, astNode, name, context);\n            }\n            else if (value !== undefined) {\n                astNode[name] = value;\n            }\n        }\n        return astNode;\n    }\n    setParent(node, parent) {\n        node.$container = parent;\n        return node;\n    }\n    hydrateReference(reference, node, name, context) {\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n    }\n    hydrateCstNode(cstNode, context, num = 0) {\n        const cstNodeObj = context.cstNodes.get(cstNode);\n        if (typeof cstNode.grammarSource === 'number') {\n            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n        }\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n        if (isCompositeCstNode(cstNodeObj)) {\n            for (const child of cstNode.content) {\n                const hydrated = this.hydrateCstNode(child, context, num++);\n                cstNodeObj.content.push(hydrated);\n            }\n        }\n        return cstNodeObj;\n    }\n    hydrateCstLeafNode(cstNode) {\n        const tokenType = this.getTokenType(cstNode.tokenType);\n        const offset = cstNode.offset;\n        const length = cstNode.length;\n        const startLine = cstNode.startLine;\n        const startColumn = cstNode.startColumn;\n        const endLine = cstNode.endLine;\n        const endColumn = cstNode.endColumn;\n        const hidden = cstNode.hidden;\n        const node = new LeafCstNodeImpl(offset, length, {\n            start: {\n                line: startLine,\n                character: startColumn\n            },\n            end: {\n                line: endLine,\n                character: endColumn\n            }\n        }, tokenType, hidden);\n        return node;\n    }\n    getTokenType(name) {\n        return this.lexer.definition[name];\n    }\n    getGrammarElementId(node) {\n        if (!node) {\n            return undefined;\n        }\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        return this.grammarElementIdMap.get(node);\n    }\n    getGrammarElement(id) {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        const element = this.grammarElementIdMap.getKey(id);\n        return element;\n    }\n    createGrammarElementIdMap() {\n        let id = 0;\n        for (const element of streamAst(this.grammar)) {\n            if (isAbstractElement(element)) {\n                this.grammarElementIdMap.set(element, id++);\n            }\n        }\n    }\n}\n//# sourceMappingURL=hydrator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n******************************************************************************/\nimport { createGrammarConfig } from './languages/grammar-config.js';\nimport { createCompletionParser } from './parser/completion-parser-builder.js';\nimport { createLangiumParser } from './parser/langium-parser-builder.js';\nimport { DefaultTokenBuilder } from './parser/token-builder.js';\nimport { DefaultValueConverter } from './parser/value-converter.js';\nimport { DefaultLinker } from './references/linker.js';\nimport { DefaultNameProvider } from './references/name-provider.js';\nimport { DefaultReferences } from './references/references.js';\nimport { DefaultScopeComputation } from './references/scope-computation.js';\nimport { DefaultScopeProvider } from './references/scope-provider.js';\nimport { DefaultJsonSerializer } from './serializer/json-serializer.js';\nimport { DefaultServiceRegistry } from './service-registry.js';\nimport { DefaultDocumentValidator } from './validation/document-validator.js';\nimport { ValidationRegistry } from './validation/validation-registry.js';\nimport { DefaultAstNodeDescriptionProvider, DefaultReferenceDescriptionProvider } from './workspace/ast-descriptions.js';\nimport { DefaultAstNodeLocator } from './workspace/ast-node-locator.js';\nimport { DefaultConfigurationProvider } from './workspace/configuration.js';\nimport { DefaultDocumentBuilder } from './workspace/document-builder.js';\nimport { DefaultLangiumDocumentFactory, DefaultLangiumDocuments } from './workspace/documents.js';\nimport { DefaultIndexManager } from './workspace/index-manager.js';\nimport { DefaultWorkspaceManager } from './workspace/workspace-manager.js';\nimport { DefaultLexer, DefaultLexerErrorMessageProvider } from './parser/lexer.js';\nimport { JSDocDocumentationProvider } from './documentation/documentation-provider.js';\nimport { DefaultCommentProvider } from './documentation/comment-provider.js';\nimport { LangiumParserErrorMessageProvider } from './parser/langium-parser.js';\nimport { DefaultAsyncParser } from './parser/async-parser.js';\nimport { DefaultWorkspaceLock } from './workspace/workspace-lock.js';\nimport { DefaultHydrator } from './serializer/hydrator.js';\n/**\n * Creates a dependency injection module configuring the default core services.\n * This is a set of services that are dedicated to a specific language.\n */\nexport function createDefaultCoreModule(context) {\n    return {\n        documentation: {\n            CommentProvider: (services) => new DefaultCommentProvider(services),\n            DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\n        },\n        parser: {\n            AsyncParser: (services) => new DefaultAsyncParser(services),\n            GrammarConfig: (services) => createGrammarConfig(services),\n            LangiumParser: (services) => createLangiumParser(services),\n            CompletionParser: (services) => createCompletionParser(services),\n            ValueConverter: () => new DefaultValueConverter(),\n            TokenBuilder: () => new DefaultTokenBuilder(),\n            Lexer: (services) => new DefaultLexer(services),\n            ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider(),\n            LexerErrorMessageProvider: () => new DefaultLexerErrorMessageProvider()\n        },\n        workspace: {\n            AstNodeLocator: () => new DefaultAstNodeLocator(),\n            AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\n            ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\n        },\n        references: {\n            Linker: (services) => new DefaultLinker(services),\n            NameProvider: () => new DefaultNameProvider(),\n            ScopeProvider: (services) => new DefaultScopeProvider(services),\n            ScopeComputation: (services) => new DefaultScopeComputation(services),\n            References: (services) => new DefaultReferences(services)\n        },\n        serializer: {\n            Hydrator: (services) => new DefaultHydrator(services),\n            JsonSerializer: (services) => new DefaultJsonSerializer(services)\n        },\n        validation: {\n            DocumentValidator: (services) => new DefaultDocumentValidator(services),\n            ValidationRegistry: (services) => new ValidationRegistry(services)\n        },\n        shared: () => context.shared\n    };\n}\n/**\n * Creates a dependency injection module configuring the default shared core services.\n * This is the set of services that are shared between multiple languages.\n */\nexport function createDefaultSharedCoreModule(context) {\n    return {\n        ServiceRegistry: (services) => new DefaultServiceRegistry(services),\n        workspace: {\n            LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\n            LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\n            DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\n            IndexManager: (services) => new DefaultIndexManager(services),\n            WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\n            WorkspaceLock: () => new DefaultWorkspaceLock(),\n            ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\n        }\n    };\n}\n//# sourceMappingURL=default-module.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { DefaultNameRegexp } from '../utils/cst-utils.js';\nimport { isCommentTerminal, terminalRegex } from '../utils/grammar-utils.js';\nimport { isMultilineComment } from '../utils/regexp-utils.js';\nimport { isTerminalRule } from './generated/ast.js';\n/**\n * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a\n * language-specific module.\n */\nexport function createGrammarConfig(services) {\n    const rules = [];\n    const grammar = services.Grammar;\n    for (const rule of grammar.rules) {\n        if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\n            rules.push(rule.name);\n        }\n    }\n    return {\n        multilineCommentRules: rules,\n        nameRegexp: DefaultNameRegexp\n    };\n}\n//# sourceMappingURL=grammar-config.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { LangiumParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\n/**\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\n * available at `services.Grammar`.\n */\nexport function createLangiumParser(services) {\n    const parser = prepareLangiumParser(services);\n    parser.finalize();\n    return parser;\n}\n/**\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\n * information when the parser is initially validated.\n */\nexport function prepareLangiumParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumParser(services);\n    return createParser(grammar, parser, lexer.definition);\n}\n//# sourceMappingURL=langium-parser-builder.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { LangiumCompletionParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\nexport function createCompletionParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumCompletionParser(services);\n    createParser(grammar, parser, lexer.definition);\n    parser.finalize();\n    return parser;\n}\n//# sourceMappingURL=completion-parser-builder.js.map","export function cc(char) {\n    return char.charCodeAt(0);\n}\nexport function insertToSet(item, set) {\n    if (Array.isArray(item)) {\n        item.forEach(function (subItem) {\n            set.push(subItem);\n        });\n    }\n    else {\n        set.push(item);\n    }\n}\nexport function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n        throw \"duplicate flag \" + flagKey;\n    }\n    const x = flagObj[flagKey];\n    flagObj[flagKey] = true;\n}\nexport function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n        throw Error(\"Internal Error - Should never get here!\");\n    }\n    return true;\n}\n// istanbul ignore next\nexport function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n}\nexport function isCharacter(obj) {\n    return obj[\"type\"] === \"Character\";\n}\n//# sourceMappingURL=utils.js.map","import { cc } from \"./utils.js\";\nexport const digitsCharCodes = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n}\nexport const wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n}\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\nexport const whitespaceCodes = [\n    cc(\" \"),\n    cc(\"\\f\"),\n    cc(\"\\n\"),\n    cc(\"\\r\"),\n    cc(\"\\t\"),\n    cc(\"\\v\"),\n    cc(\"\\t\"),\n    cc(\"\\u00a0\"),\n    cc(\"\\u1680\"),\n    cc(\"\\u2000\"),\n    cc(\"\\u2001\"),\n    cc(\"\\u2002\"),\n    cc(\"\\u2003\"),\n    cc(\"\\u2004\"),\n    cc(\"\\u2005\"),\n    cc(\"\\u2006\"),\n    cc(\"\\u2007\"),\n    cc(\"\\u2008\"),\n    cc(\"\\u2009\"),\n    cc(\"\\u200a\"),\n    cc(\"\\u2028\"),\n    cc(\"\\u2029\"),\n    cc(\"\\u202f\"),\n    cc(\"\\u205f\"),\n    cc(\"\\u3000\"),\n    cc(\"\\ufeff\"),\n];\n//# sourceMappingURL=character-classes.js.map","import { addFlag, ASSERT_EXISTS, ASSERT_NEVER_REACH_HERE, cc, insertToSet, isCharacter, } from \"./utils.js\";\nimport { digitsCharCodes, whitespaceCodes, wordCharCodes, } from \"./character-classes.js\";\n// consts and utilities\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\nexport class RegExpParser {\n    constructor() {\n        this.idx = 0;\n        this.input = \"\";\n        this.groupIdx = 0;\n    }\n    saveState() {\n        return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx,\n        };\n    }\n    restoreState(newState) {\n        this.idx = newState.idx;\n        this.input = newState.input;\n        this.groupIdx = newState.groupIdx;\n    }\n    pattern(input) {\n        // parser state\n        this.idx = 0;\n        this.input = input;\n        this.groupIdx = 0;\n        this.consumeChar(\"/\");\n        const value = this.disjunction();\n        this.consumeChar(\"/\");\n        const flags = {\n            type: \"Flags\",\n            loc: { begin: this.idx, end: input.length },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false,\n        };\n        while (this.isRegExpFlag()) {\n            switch (this.popChar()) {\n                case \"g\":\n                    addFlag(flags, \"global\");\n                    break;\n                case \"i\":\n                    addFlag(flags, \"ignoreCase\");\n                    break;\n                case \"m\":\n                    addFlag(flags, \"multiLine\");\n                    break;\n                case \"u\":\n                    addFlag(flags, \"unicode\");\n                    break;\n                case \"y\":\n                    addFlag(flags, \"sticky\");\n                    break;\n            }\n        }\n        if (this.idx !== this.input.length) {\n            throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n        }\n        return {\n            type: \"Pattern\",\n            flags: flags,\n            value: value,\n            loc: this.loc(0),\n        };\n    }\n    disjunction() {\n        const alts = [];\n        const begin = this.idx;\n        alts.push(this.alternative());\n        while (this.peekChar() === \"|\") {\n            this.consumeChar(\"|\");\n            alts.push(this.alternative());\n        }\n        return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n    }\n    alternative() {\n        const terms = [];\n        const begin = this.idx;\n        while (this.isTerm()) {\n            terms.push(this.term());\n        }\n        return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n    }\n    term() {\n        if (this.isAssertion()) {\n            return this.assertion();\n        }\n        else {\n            return this.atom();\n        }\n    }\n    assertion() {\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"^\":\n                return {\n                    type: \"StartAnchor\",\n                    loc: this.loc(begin),\n                };\n            case \"$\":\n                return { type: \"EndAnchor\", loc: this.loc(begin) };\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.popChar()) {\n                    case \"b\":\n                        return {\n                            type: \"WordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                    case \"B\":\n                        return {\n                            type: \"NonWordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                }\n                // istanbul ignore next\n                throw Error(\"Invalid Assertion Escape\");\n            // '(?=' or '(?!'\n            case \"(\":\n                this.consumeChar(\"?\");\n                let type;\n                switch (this.popChar()) {\n                    case \"=\":\n                        type = \"Lookahead\";\n                        break;\n                    case \"!\":\n                        type = \"NegativeLookahead\";\n                        break;\n                }\n                ASSERT_EXISTS(type);\n                const disjunction = this.disjunction();\n                this.consumeChar(\")\");\n                return {\n                    type: type,\n                    value: disjunction,\n                    loc: this.loc(begin),\n                };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    quantifier(isBacktracking = false) {\n        let range = undefined;\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"*\":\n                range = {\n                    atLeast: 0,\n                    atMost: Infinity,\n                };\n                break;\n            case \"+\":\n                range = {\n                    atLeast: 1,\n                    atMost: Infinity,\n                };\n                break;\n            case \"?\":\n                range = {\n                    atLeast: 0,\n                    atMost: 1,\n                };\n                break;\n            case \"{\":\n                const atLeast = this.integerIncludingZero();\n                switch (this.popChar()) {\n                    case \"}\":\n                        range = {\n                            atLeast: atLeast,\n                            atMost: atLeast,\n                        };\n                        break;\n                    case \",\":\n                        let atMost;\n                        if (this.isDigit()) {\n                            atMost = this.integerIncludingZero();\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atMost,\n                            };\n                        }\n                        else {\n                            range = {\n                                atLeast: atLeast,\n                                atMost: Infinity,\n                            };\n                        }\n                        this.consumeChar(\"}\");\n                        break;\n                }\n                // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                // causes severe performance degradations\n                if (isBacktracking === true && range === undefined) {\n                    return undefined;\n                }\n                ASSERT_EXISTS(range);\n                break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n            return undefined;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\");\n                range.greedy = false;\n            }\n            else {\n                range.greedy = true;\n            }\n            range.type = \"Quantifier\";\n            range.loc = this.loc(begin);\n            return range;\n        }\n    }\n    atom() {\n        let atom;\n        const begin = this.idx;\n        switch (this.peekChar()) {\n            case \".\":\n                atom = this.dotAll();\n                break;\n            case \"\\\\\":\n                atom = this.atomEscape();\n                break;\n            case \"[\":\n                atom = this.characterClass();\n                break;\n            case \"(\":\n                atom = this.group();\n                break;\n        }\n        if (atom === undefined && this.isPatternCharacter()) {\n            atom = this.patternCharacter();\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(atom)) {\n            atom.loc = this.loc(begin);\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier();\n            }\n            return atom;\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    dotAll() {\n        this.consumeChar(\".\");\n        return {\n            type: \"Set\",\n            complement: true,\n            value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")],\n        };\n    }\n    atomEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                return this.decimalEscapeAtom();\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    decimalEscapeAtom() {\n        const value = this.positiveInteger();\n        return { type: \"GroupBackReference\", value: value };\n    }\n    characterClassEscape() {\n        let set;\n        let complement = false;\n        switch (this.popChar()) {\n            case \"d\":\n                set = digitsCharCodes;\n                break;\n            case \"D\":\n                set = digitsCharCodes;\n                complement = true;\n                break;\n            case \"s\":\n                set = whitespaceCodes;\n                break;\n            case \"S\":\n                set = whitespaceCodes;\n                complement = true;\n                break;\n            case \"w\":\n                set = wordCharCodes;\n                break;\n            case \"W\":\n                set = wordCharCodes;\n                complement = true;\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(set)) {\n            return { type: \"Set\", value: set, complement: complement };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlEscapeAtom() {\n        let escapeCode;\n        switch (this.popChar()) {\n            case \"f\":\n                escapeCode = cc(\"\\f\");\n                break;\n            case \"n\":\n                escapeCode = cc(\"\\n\");\n                break;\n            case \"r\":\n                escapeCode = cc(\"\\r\");\n                break;\n            case \"t\":\n                escapeCode = cc(\"\\t\");\n                break;\n            case \"v\":\n                escapeCode = cc(\"\\v\");\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(escapeCode)) {\n            return { type: \"Character\", value: escapeCode };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlLetterEscapeAtom() {\n        this.consumeChar(\"c\");\n        const letter = this.popChar();\n        if (/[a-zA-Z]/.test(letter) === false) {\n            throw Error(\"Invalid \");\n        }\n        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n        return { type: \"Character\", value: letterCode };\n    }\n    nulCharacterAtom() {\n        // TODO implement '[lookahead  DecimalDigit]'\n        // TODO: for the deprecated octal escape sequence\n        this.consumeChar(\"0\");\n        return { type: \"Character\", value: cc(\"\\0\") };\n    }\n    hexEscapeSequenceAtom() {\n        this.consumeChar(\"x\");\n        return this.parseHexDigits(2);\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n        this.consumeChar(\"u\");\n        return this.parseHexDigits(4);\n    }\n    identityEscapeAtom() {\n        // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n        const escapedChar = this.popChar();\n        return { type: \"Character\", value: cc(escapedChar) };\n    }\n    classPatternCharacterAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \"]\":\n                throw Error(\"TBD\");\n            default:\n                const nextChar = this.popChar();\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    characterClass() {\n        const set = [];\n        let complement = false;\n        this.consumeChar(\"[\");\n        if (this.peekChar(0) === \"^\") {\n            this.consumeChar(\"^\");\n            complement = true;\n        }\n        while (this.isClassAtom()) {\n            const from = this.classAtom();\n            const isFromSingleChar = from.type === \"Character\";\n            if (isCharacter(from) && this.isRangeDash()) {\n                this.consumeChar(\"-\");\n                const to = this.classAtom();\n                const isToSingleChar = to.type === \"Character\";\n                // a range can only be used when both sides are single characters\n                if (isCharacter(to)) {\n                    if (to.value < from.value) {\n                        throw Error(\"Range out of order in character class\");\n                    }\n                    set.push({ from: from.value, to: to.value });\n                }\n                else {\n                    // literal dash\n                    insertToSet(from.value, set);\n                    set.push(cc(\"-\"));\n                    insertToSet(to.value, set);\n                }\n            }\n            else {\n                insertToSet(from.value, set);\n            }\n        }\n        this.consumeChar(\"]\");\n        return { type: \"Set\", complement: complement, value: set };\n    }\n    classAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"]\":\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n                throw Error(\"TBD\");\n            case \"\\\\\":\n                return this.classEscape();\n            default:\n                return this.classPatternCharacterAtom();\n        }\n    }\n    classEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            // Matches a backspace.\n            // (Not to be confused with \\b word boundary outside characterClass)\n            case \"b\":\n                this.consumeChar(\"b\");\n                return { type: \"Character\", value: cc(\"\\u0008\") };\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    group() {\n        let capturing = true;\n        this.consumeChar(\"(\");\n        switch (this.peekChar(0)) {\n            case \"?\":\n                this.consumeChar(\"?\");\n                this.consumeChar(\":\");\n                capturing = false;\n                break;\n            default:\n                this.groupIdx++;\n                break;\n        }\n        const value = this.disjunction();\n        this.consumeChar(\")\");\n        const groupAst = {\n            type: \"Group\",\n            capturing: capturing,\n            value: value,\n        };\n        if (capturing) {\n            groupAst[\"idx\"] = this.groupIdx;\n        }\n        return groupAst;\n    }\n    positiveInteger() {\n        let number = this.popChar();\n        // istanbul ignore next - can't ever get here due to previous lookahead checks\n        // still implementing this error checking in case this ever changes.\n        if (decimalPatternNoZero.test(number) === false) {\n            throw Error(\"Expecting a positive integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    integerIncludingZero() {\n        let number = this.popChar();\n        if (decimalPattern.test(number) === false) {\n            throw Error(\"Expecting an integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    patternCharacter() {\n        const nextChar = this.popChar();\n        switch (nextChar) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"^\":\n            // istanbul ignore next\n            case \"$\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \".\":\n            // istanbul ignore next\n            case \"*\":\n            // istanbul ignore next\n            case \"+\":\n            // istanbul ignore next\n            case \"?\":\n            // istanbul ignore next\n            case \"(\":\n            // istanbul ignore next\n            case \")\":\n            // istanbul ignore next\n            case \"[\":\n            // istanbul ignore next\n            case \"|\":\n                // istanbul ignore next\n                throw Error(\"TBD\");\n            default:\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    isRegExpFlag() {\n        switch (this.peekChar(0)) {\n            case \"g\":\n            case \"i\":\n            case \"m\":\n            case \"u\":\n            case \"y\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    isRangeDash() {\n        return this.peekChar() === \"-\" && this.isClassAtom(1);\n    }\n    isDigit() {\n        return decimalPattern.test(this.peekChar(0));\n    }\n    isClassAtom(howMuch = 0) {\n        switch (this.peekChar(howMuch)) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    isTerm() {\n        return this.isAtom() || this.isAssertion();\n    }\n    isAtom() {\n        if (this.isPatternCharacter()) {\n            return true;\n        }\n        switch (this.peekChar(0)) {\n            case \".\":\n            case \"\\\\\": // atomEscape\n            case \"[\": // characterClass\n            // TODO: isAtom must be called before isAssertion - disambiguate\n            case \"(\": // group\n                return true;\n            default:\n                return false;\n        }\n    }\n    isAssertion() {\n        switch (this.peekChar(0)) {\n            case \"^\":\n            case \"$\":\n                return true;\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.peekChar(1)) {\n                    case \"b\":\n                    case \"B\":\n                        return true;\n                    default:\n                        return false;\n                }\n            // '(?=' or '(?!'\n            case \"(\":\n                return (this.peekChar(1) === \"?\" &&\n                    (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\"));\n            default:\n                return false;\n        }\n    }\n    isQuantifier() {\n        const prevState = this.saveState();\n        try {\n            return this.quantifier(true) !== undefined;\n        }\n        catch (e) {\n            return false;\n        }\n        finally {\n            this.restoreState(prevState);\n        }\n    }\n    isPatternCharacter() {\n        switch (this.peekChar()) {\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n            case \"/\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    parseHexDigits(howMany) {\n        let hexString = \"\";\n        for (let i = 0; i < howMany; i++) {\n            const hexChar = this.popChar();\n            if (hexDigitPattern.test(hexChar) === false) {\n                throw Error(\"Expecting a HexDecimal digits\");\n            }\n            hexString += hexChar;\n        }\n        const charCode = parseInt(hexString, 16);\n        return { type: \"Character\", value: charCode };\n    }\n    peekChar(howMuch = 0) {\n        return this.input[this.idx + howMuch];\n    }\n    popChar() {\n        const nextChar = this.peekChar(0);\n        this.consumeChar(undefined);\n        return nextChar;\n    }\n    consumeChar(char) {\n        if (char !== undefined && this.input[this.idx] !== char) {\n            throw Error(\"Expected: '\" +\n                char +\n                \"' but found: '\" +\n                this.input[this.idx] +\n                \"' at offset: \" +\n                this.idx);\n        }\n        if (this.idx >= this.input.length) {\n            throw Error(\"Unexpected end of input\");\n        }\n        this.idx++;\n    }\n    loc(begin) {\n        return { begin: begin, end: this.idx };\n    }\n}\n//# sourceMappingURL=regexp-parser.js.map","export class BaseRegExpVisitor {\n    visitChildren(node) {\n        for (const key in node) {\n            const child = node[key];\n            /* istanbul ignore else */\n            if (node.hasOwnProperty(key)) {\n                if (child.type !== undefined) {\n                    this.visit(child);\n                }\n                else if (Array.isArray(child)) {\n                    child.forEach((subChild) => {\n                        this.visit(subChild);\n                    }, this);\n                }\n            }\n        }\n    }\n    visit(node) {\n        switch (node.type) {\n            case \"Pattern\":\n                this.visitPattern(node);\n                break;\n            case \"Flags\":\n                this.visitFlags(node);\n                break;\n            case \"Disjunction\":\n                this.visitDisjunction(node);\n                break;\n            case \"Alternative\":\n                this.visitAlternative(node);\n                break;\n            case \"StartAnchor\":\n                this.visitStartAnchor(node);\n                break;\n            case \"EndAnchor\":\n                this.visitEndAnchor(node);\n                break;\n            case \"WordBoundary\":\n                this.visitWordBoundary(node);\n                break;\n            case \"NonWordBoundary\":\n                this.visitNonWordBoundary(node);\n                break;\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                break;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                break;\n            case \"Character\":\n                this.visitCharacter(node);\n                break;\n            case \"Set\":\n                this.visitSet(node);\n                break;\n            case \"Group\":\n                this.visitGroup(node);\n                break;\n            case \"GroupBackReference\":\n                this.visitGroupBackReference(node);\n                break;\n            case \"Quantifier\":\n                this.visitQuantifier(node);\n                break;\n        }\n        this.visitChildren(node);\n    }\n    visitPattern(node) { }\n    visitFlags(node) { }\n    visitDisjunction(node) { }\n    visitAlternative(node) { }\n    // Assertion\n    visitStartAnchor(node) { }\n    visitEndAnchor(node) { }\n    visitWordBoundary(node) { }\n    visitNonWordBoundary(node) { }\n    visitLookahead(node) { }\n    visitNegativeLookahead(node) { }\n    // atoms\n    visitCharacter(node) { }\n    visitSet(node) { }\n    visitGroup(node) { }\n    visitGroupBackReference(node) { }\n    visitQuantifier(node) { }\n}\n//# sourceMappingURL=base-regexp-visitor.js.map","import baseFlatten from './_baseFlatten.js';\nimport map from './map.js';\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nexport default flatMap;\n","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { assertUnreachable } from '../utils/errors.js';\nimport * as ast from '../languages/generated/ast.js';\nimport { isCompositeCstNode } from '../syntax-tree.js';\nimport { getContainerOfType, streamAllContents } from './ast-utils.js';\nimport { streamCst } from './cst-utils.js';\nimport { escapeRegExp, isWhitespace } from './regexp-utils.js';\n/**\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\n * the result is `undefined`.\n */\nexport function getEntryRule(grammar) {\n    return grammar.rules.find(e => ast.isParserRule(e) && e.entry);\n}\n/**\n * Returns all hidden terminal rules of the given grammar, if any.\n */\nexport function getHiddenRules(grammar) {\n    return grammar.rules.filter((e) => ast.isTerminalRule(e) && e.hidden);\n}\n/**\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\n *\n * @param grammar The grammar that contains all rules\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\n *      this function returns all rules of the specified grammar.\n */\nexport function getAllReachableRules(grammar, allTerminals) {\n    const ruleNames = new Set();\n    const entryRule = getEntryRule(grammar);\n    if (!entryRule) {\n        return new Set(grammar.rules);\n    }\n    const topMostRules = [entryRule].concat(getHiddenRules(grammar));\n    for (const rule of topMostRules) {\n        ruleDfs(rule, ruleNames, allTerminals);\n    }\n    const rules = new Set();\n    for (const rule of grammar.rules) {\n        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {\n            rules.add(rule);\n        }\n    }\n    return rules;\n}\nfunction ruleDfs(rule, visitedSet, allTerminals) {\n    visitedSet.add(rule.name);\n    streamAllContents(rule).forEach(node => {\n        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) {\n                ruleDfs(refRule, visitedSet, allTerminals);\n            }\n        }\n    });\n}\n/**\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\n *\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\n * and cannot be inferred.\n */\nexport function getCrossReferenceTerminal(crossRef) {\n    if (crossRef.terminal) {\n        return crossRef.terminal;\n    }\n    else if (crossRef.type.ref) {\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\n        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n    }\n    return undefined;\n}\n/**\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\n * that contains visible characters is considered a comment.\n */\nexport function isCommentTerminal(terminalRule) {\n    return terminalRule.hidden && !isWhitespace(terminalRegex(terminalRule));\n}\n/**\n * Find all CST nodes within the given node that contribute to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\n */\nexport function findNodesForProperty(node, property) {\n    if (!node || !property) {\n        return [];\n    }\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n/**\n * Find a single CST node within the given node that contributes to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForProperty(node, property, index) {\n    if (!node || !property) {\n        return undefined;\n    }\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nfunction findNodesForPropertyInternal(node, property, element, first) {\n    if (!first) {\n        const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) {\n            return [node];\n        }\n    }\n    if (isCompositeCstNode(node) && node.astNode === element) {\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\n    }\n    return [];\n}\n/**\n * Find all CST nodes within the given node that correspond to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\n * @param keyword A keyword as specified in the grammar.\n */\nexport function findNodesForKeyword(node, keyword) {\n    if (!node) {\n        return [];\n    }\n    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n}\n/**\n * Find a single CST node within the given node that corresponds to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\n * @param keyword A keyword as specified in the grammar.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForKeyword(node, keyword, index) {\n    if (!node) {\n        return undefined;\n    }\n    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nexport function findNodesForKeywordInternal(node, keyword, element) {\n    if (node.astNode !== element) {\n        return [];\n    }\n    if (ast.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n        return [node];\n    }\n    const treeIterator = streamCst(node).iterator();\n    let result;\n    const keywordNodes = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if (ast.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n                    keywordNodes.push(childNode);\n                }\n            }\n            else {\n                treeIterator.prune();\n            }\n        }\n    } while (!result.done);\n    return keywordNodes;\n}\n/**\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\n * node is returned. If no assignment is found, the result is `undefined`.\n *\n * @param cstNode A CST node for which to find a property assignment.\n */\nexport function findAssignment(cstNode) {\n    var _a;\n    const astNode = cstNode.astNode;\n    // Only search until the ast node of the parent cst node is no longer the original ast node\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\n    while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {\n        const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);\n        if (assignment) {\n            return assignment;\n        }\n        cstNode = cstNode.container;\n    }\n    return undefined;\n}\n/**\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\n * this function returns `undefined`.\n */\nexport function findNameAssignment(type) {\n    let startNode = type;\n    if (ast.isInferredType(startNode)) {\n        // for inferred types, the location to start searching for the name-assignment is different\n        if (ast.isAction(startNode.$container)) {\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent\n            startNode = startNode.$container.$container;\n        }\n        else if (ast.isParserRule(startNode.$container)) {\n            // investigate the parser rule with the explicitly inferred type\n            startNode = startNode.$container;\n        }\n        else {\n            assertUnreachable(startNode.$container);\n        }\n    }\n    return findNameAssignmentInternal(type, startNode, new Map());\n}\nfunction findNameAssignmentInternal(type, startNode, cache) {\n    var _a;\n    // the cache is only required to prevent infinite loops\n    function go(node, refType) {\n        let childAssignment = undefined;\n        const parentAssignment = getContainerOfType(node, ast.isAssignment);\n        // No parent assignment implies unassigned rule call\n        if (!parentAssignment) {\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\n        }\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n    if (cache.has(type)) {\n        return cache.get(type);\n    }\n    cache.set(type, undefined);\n    for (const node of streamAllContents(startNode)) {\n        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {\n            cache.set(type, node);\n            return node;\n        }\n        else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {\n            return go(node, node.rule.ref);\n        }\n        else if (ast.isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {\n            return go(node, node.typeRef.ref);\n        }\n    }\n    return undefined;\n}\nexport function getActionAtElement(element) {\n    const parent = element.$container;\n    if (ast.isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for (let i = index - 1; i >= 0; i--) {\n            const item = elements[i];\n            if (ast.isAction(item)) {\n                return item;\n            }\n            else {\n                const action = streamAllContents(elements[i]).find(ast.isAction);\n                if (action) {\n                    return action;\n                }\n            }\n        }\n    }\n    if (ast.isAbstractElement(parent)) {\n        return getActionAtElement(parent);\n    }\n    else {\n        return undefined;\n    }\n}\nexport function isOptionalCardinality(cardinality, element) {\n    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));\n}\nexport function isArrayCardinality(cardinality) {\n    return cardinality === '*' || cardinality === '+';\n}\nexport function isArrayOperator(operator) {\n    return operator === '+=';\n}\n/**\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\n * primitive return type like `number`, `boolean`, etc.\n */\nexport function isDataTypeRule(rule) {\n    return isDataTypeRuleInternal(rule, new Set());\n}\nfunction isDataTypeRuleInternal(rule, visited) {\n    if (visited.has(rule)) {\n        return true;\n    }\n    else {\n        visited.add(rule);\n    }\n    for (const node of streamAllContents(rule)) {\n        if (ast.isRuleCall(node)) {\n            if (!node.rule.ref) {\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\n                return false;\n            }\n            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n                return false;\n            }\n        }\n        else if (ast.isAssignment(node)) {\n            return false;\n        }\n        else if (ast.isAction(node)) {\n            return false;\n        }\n    }\n    return Boolean(rule.definition);\n}\nexport function isDataType(type) {\n    return isDataTypeInternal(type.type, new Set());\n}\nfunction isDataTypeInternal(type, visited) {\n    if (visited.has(type)) {\n        return true;\n    }\n    else {\n        visited.add(type);\n    }\n    if (ast.isArrayType(type)) {\n        return false;\n    }\n    else if (ast.isReferenceType(type)) {\n        return false;\n    }\n    else if (ast.isUnionType(type)) {\n        return type.types.every(e => isDataTypeInternal(e, visited));\n    }\n    else if (ast.isSimpleType(type)) {\n        if (type.primitiveType !== undefined) {\n            return true;\n        }\n        else if (type.stringType !== undefined) {\n            return true;\n        }\n        else if (type.typeRef !== undefined) {\n            const ref = type.typeRef.ref;\n            if (ast.isType(ref)) {\n                return isDataTypeInternal(ref.type, visited);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nexport function getExplicitRuleType(rule) {\n    if (rule.inferredType) {\n        return rule.inferredType.name;\n    }\n    else if (rule.dataType) {\n        return rule.dataType;\n    }\n    else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if (refType) {\n            // check if we need to check Action as return type\n            if (ast.isParserRule(refType)) {\n                return refType.name;\n            }\n            else if (ast.isInterface(refType) || ast.isType(refType)) {\n                return refType.name;\n            }\n        }\n    }\n    return undefined;\n}\nexport function getTypeName(type) {\n    var _a;\n    if (ast.isParserRule(type)) {\n        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;\n    }\n    else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {\n        return type.name;\n    }\n    else if (ast.isAction(type)) {\n        const actionType = getActionType(type);\n        if (actionType) {\n            return actionType;\n        }\n    }\n    else if (ast.isInferredType(type)) {\n        return type.name;\n    }\n    throw new Error('Cannot get name of Unknown Type');\n}\nexport function getActionType(action) {\n    var _a;\n    if (action.inferredType) {\n        return action.inferredType.name;\n    }\n    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {\n        return getTypeName(action.type.ref);\n    }\n    return undefined; // not inferring and not referencing a valid type\n}\n/**\n * This function is used at development time (for code generation and the internal type system) to get the type of the AST node produced by the given rule.\n * For data type rules, the name of the rule is returned,\n * e.g. \"INT_value returns number: MY_INT;\" returns \"INT_value\".\n * @param rule the given rule\n * @returns the name of the AST node type of the rule\n */\nexport function getRuleTypeName(rule) {\n    var _a, _b, _c;\n    if (ast.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\n/**\n * This function is used at runtime to get the actual type of the values produced by the given rule at runtime.\n * For data type rules, the name of the declared return type of the rule is returned (if any),\n * e.g. \"INT_value returns number: MY_INT;\" returns \"number\".\n * @param rule the given rule\n * @returns the name of the type of the produced values of the rule at runtime\n */\nexport function getRuleType(rule) {\n    var _a, _b, _c;\n    if (ast.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\nexport function terminalRegex(terminalRule) {\n    const flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\n    return new RegExp(source, flagText);\n}\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\nconst WILDCARD = /[\\s\\S]/.source;\nfunction abstractElementToRegex(element, flags) {\n    if (ast.isTerminalAlternatives(element)) {\n        return terminalAlternativesToRegex(element);\n    }\n    else if (ast.isTerminalGroup(element)) {\n        return terminalGroupToRegex(element);\n    }\n    else if (ast.isCharacterRange(element)) {\n        return characterRangeToRegex(element);\n    }\n    else if (ast.isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) {\n            throw new Error('Missing rule reference.');\n        }\n        return withCardinality(abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else if (ast.isNegatedToken(element)) {\n        return negateTokenToRegex(element);\n    }\n    else if (ast.isUntilToken(element)) {\n        return untilTokenToRegex(element);\n    }\n    else if (ast.isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf('/');\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes('i');\n            flags.s = regexFlags.includes('s');\n            flags.u = regexFlags.includes('u');\n        }\n        return withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    }\n    else if (ast.isWildcard(element)) {\n        return withCardinality(WILDCARD, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else {\n        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n    }\n}\nfunction terminalAlternativesToRegex(alternatives) {\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\nfunction terminalGroupToRegex(group) {\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\nfunction untilTokenToRegex(until) {\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\nfunction negateTokenToRegex(negate) {\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\nfunction characterRangeToRegex(range) {\n    if (range.right) {\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n            cardinality: range.cardinality,\n            lookahead: range.lookahead,\n            wrap: false\n        });\n    }\n    return withCardinality(keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\nfunction keywordToRegex(keyword) {\n    return escapeRegExp(keyword.value);\n}\nfunction withCardinality(regex, options) {\n    var _a;\n    if (options.wrap !== false || options.lookahead) {\n        regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ''}${regex})`;\n    }\n    if (options.cardinality) {\n        return `${regex}${options.cardinality}`;\n    }\n    return regex;\n}\n//# sourceMappingURL=grammar-utils.js.map","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  MermaidGeneratedSharedModule,\n  RadarGeneratedModule,\n  __name\n} from \"./chunk-FPAJGGOC.mjs\";\n\n// src/language/radar/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/radar/tokenBuilder.ts\nvar RadarTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"RadarTokenBuilder\");\n  }\n  constructor() {\n    super([\"radar-beta\"]);\n  }\n};\n\n// src/language/radar/module.ts\nvar RadarModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new RadarTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createRadarServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Radar = inject(\n    createDefaultCoreModule({ shared }),\n    RadarGeneratedModule,\n    RadarModule\n  );\n  shared.ServiceRegistry.register(Radar);\n  return { shared, Radar };\n}\n__name(createRadarServices, \"createRadarServices\");\n\nexport {\n  RadarModule,\n  createRadarServices\n};\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isCrossReference, isRuleCall } from '../languages/generated/ast.js';\nimport { getCrossReferenceTerminal, getRuleType } from '../utils/grammar-utils.js';\nexport class DefaultValueConverter {\n    convert(input, cstNode) {\n        let feature = cstNode.grammarSource;\n        if (isCrossReference(feature)) {\n            feature = getCrossReferenceTerminal(feature);\n        }\n        if (isRuleCall(feature)) {\n            const rule = feature.rule.ref;\n            if (!rule) {\n                throw new Error('This cst node was not parsed by a rule.');\n            }\n            return this.runConverter(rule, input, cstNode);\n        }\n        return input;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runConverter(rule, input, cstNode) {\n        var _a;\n        switch (rule.name.toUpperCase()) {\n            case 'INT': return ValueConverter.convertInt(input);\n            case 'STRING': return ValueConverter.convertString(input);\n            case 'ID': return ValueConverter.convertID(input);\n        }\n        switch ((_a = getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {\n            case 'number': return ValueConverter.convertNumber(input);\n            case 'boolean': return ValueConverter.convertBoolean(input);\n            case 'bigint': return ValueConverter.convertBigint(input);\n            case 'date': return ValueConverter.convertDate(input);\n            default: return input;\n        }\n    }\n}\nexport var ValueConverter;\n(function (ValueConverter) {\n    function convertString(input) {\n        let result = '';\n        for (let i = 1; i < input.length - 1; i++) {\n            const c = input.charAt(i);\n            if (c === '\\\\') {\n                const c1 = input.charAt(++i);\n                result += convertEscapeCharacter(c1);\n            }\n            else {\n                result += c;\n            }\n        }\n        return result;\n    }\n    ValueConverter.convertString = convertString;\n    function convertEscapeCharacter(char) {\n        switch (char) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            case '0': return '\\0';\n            default: return char;\n        }\n    }\n    function convertID(input) {\n        if (input.charAt(0) === '^') {\n            return input.substring(1);\n        }\n        else {\n            return input;\n        }\n    }\n    ValueConverter.convertID = convertID;\n    function convertInt(input) {\n        return parseInt(input);\n    }\n    ValueConverter.convertInt = convertInt;\n    function convertBigint(input) {\n        return BigInt(input);\n    }\n    ValueConverter.convertBigint = convertBigint;\n    function convertDate(input) {\n        return new Date(input);\n    }\n    ValueConverter.convertDate = convertDate;\n    function convertNumber(input) {\n        return Number(input);\n    }\n    ValueConverter.convertNumber = convertNumber;\n    function convertBoolean(input) {\n        return input.toLowerCase() === 'true';\n    }\n    ValueConverter.convertBoolean = convertBoolean;\n})(ValueConverter || (ValueConverter = {}));\n//# sourceMappingURL=value-converter.js.map"],"names":["ErrorWithLocation","Error","constructor","node","message","super","range","start","line","character","assertUnreachable","_","LangiumGrammarTerminals","ID","STRING","NUMBER","RegexLiteral","WS","ML_COMMENT","SL_COMMENT","AbstractRule","isAbstractRule","item","reflection","isInstance","AbstractType","isAbstractType","Condition","isCondition","isFeatureName","isPrimitiveType","test","TypeDefinition","isTypeDefinition","ValueLiteral","isValueLiteral","AbstractElement","isAbstractElement","ArrayLiteral","isArrayLiteral","ArrayType","isArrayType","BooleanLiteral","isBooleanLiteral","Conjunction","isConjunction","Disjunction","isDisjunction","Grammar","isGrammar","GrammarImport","isGrammarImport","InferredType","isInferredType","Interface","isInterface","NamedArgument","isNamedArgument","Negation","isNegation","NumberLiteral","isNumberLiteral","Parameter","isParameter","ParameterReference","isParameterReference","ParserRule","isParserRule","ReferenceType","isReferenceType","ReturnType","isReturnType","SimpleType","isSimpleType","StringLiteral","isStringLiteral","TerminalRule","isTerminalRule","Type","isType","TypeAttribute","isTypeAttribute","UnionType","isUnionType","Action","isAction","Alternatives","isAlternatives","Assignment","isAssignment","CharacterRange","isCharacterRange","CrossReference","isCrossReference","EndOfFile","isEndOfFile","Group","isGroup","Keyword","isKeyword","NegatedToken","isNegatedToken","RegexToken","isRegexToken","RuleCall","isRuleCall","TerminalAlternatives","isTerminalAlternatives","TerminalGroup","isTerminalGroup","TerminalRuleCall","isTerminalRuleCall","UnorderedGroup","isUnorderedGroup","UntilToken","isUntilToken","Wildcard","isWildcard","LangiumGrammarAstReflection","AbstractAstReflection","getAllTypes","computeIsSubtype","subtype","supertype","this","isSubtype","getReferenceType","refInfo","referenceId","container","$type","property","getTypeMetaData","type","name","properties","defaultValue","collection","iteratee","index","result","Array","length","value","key","object","path","customizer","isObject","lastIndex","nested","newValue","objValue","undefined","paths","predicate","array","DefaultTokenBuilder","diagnostics","buildTokens","grammar","options","reachableRules","stream","getAllReachableRules","terminalTokens","buildTerminalTokens","tokens","buildKeywordTokens","forEach","terminalToken","pattern","PATTERN","isWhitespace","unshift","push","flushLexingReport","text","popDiagnostics","rules","filter","e","fragment","map","terminal","buildTerminalToken","toArray","regex","terminalRegex","requiresCustomPattern","regexPatternFunction","tokenType","LINE_BREAKS","hidden","GROUP","Lexer","SKIPPED","flags","includes","source","stickyRegex","RegExp","offset","exec","flatMap","rule","streamAllContents","distinct","sort","a","b","keyword","buildKeywordToken","Boolean","caseInsensitive","keywordPattern","buildKeywordPattern","LONGER_ALT","findLongerAlt","getCaseInsensitivePattern","reduce","longerAlts","token","partialMatches","NEWLINE_REGEXP","regexpParser","RegExpParser","TerminalRegExpVisitor","BaseRegExpVisitor","arguments","isStarting","endRegexpStack","multiline","endRegex","join","reset","startRegexp","visitGroup","quantifier","visitCharacter","char","String","fromCharCode","escapedChar","escapeRegExp","visitSet","set","substring","loc","begin","end","match","visitChildren","visitor","getTerminalParts","regexp","parts","alternative","visit","_a","isMultilineComment","toString","whitespaceCharacters","split","some","ws","replace","prototype","call","letter","toLowerCase","toUpperCase","input","partial","partialRegExp","re","i","process","tmp","appendRaw","nbChars","substr","appendOptional","unicode","indexOf","reWhitespace","reTrimStart","string","slice","charAt","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","INFINITY","isSymbol","other","valueOf","isBinary","isAstNode","obj","isReference","$refText","isAstNodeDescription","isLinkingError","reference","subtypes","allSubtypes","existing","getAllSubTypes","allTypes","types","possibleSubType","isCompositeCstNode","isArray","content","isLeafCstNode","isRootCstNode","fullText","LIB","t","TypeError","JSON","stringify","r","n","o","s","h","charCodeAt","lastIndexOf","resolve","cwd","normalize","isAbsolute","relative","c","f","u","l","g","_makeLong","dirname","basename","extname","format","dir","root","base","ext","parse","sep","delimiter","win32","posix","exports","d","Object","defineProperty","enumerable","get","hasOwnProperty","Symbol","toStringTag","URI","Utils","P","platform","navigator","userAgent","scheme","authority","query","isUri","fsPath","with","m","C","file","from","y","toJSON","revive","_formatted","external","_fsPath","_sep","$mid","encodeURIComponent","p","v","decodeURIComponent","A","w","x","joinPath","resolvePath","remainder","StreamImpl","startFn","nextFn","iterator","state","next","isEmpty","done","count","toSet","Set","toMap","keyFn","valueFn","entryStream","element","Map","concat","first","firstDone","DONE_RESULT","separator","addSeparator","searchElement","fromIndex","every","callbackfn","nonNullable","initialValue","previousValue","reduceRight","recursiveReduce","find","findIndex","mapped","isIterable","flat","depth","head","tail","skipCount","limit","maxSize","size","by","internalState","has","add","exclude","otherKeySet","ownKey","EMPTY_STREAM","freeze","collections","collIndex","arrIndex","TreeStreamImpl","children","iterators","includeRoot","pruned","pop","prune","Reduction","sum","product","min","Math","max","reHasUnicode","EmptyFileSystemProvider","readFile","readDirectory","EmptyFileSystem","fileSystemProvider","PieTokenBuilder","AbstractMermaidTokenBuilder","__name","PieValueConverter","AbstractMermaidValueConverter","runCustomConverter","_cstNode","trim","PieModule","parser","TokenBuilder","ValueConverter","createPieServices","context","shared","inject","createDefaultSharedCoreModule","MermaidGeneratedSharedModule","Pie","createDefaultCoreModule","PieGeneratedModule","ServiceRegistry","register","nativeMax","findIndexFunc","toInteger","iterable","isArrayLike","keys","_ral","RAL","install","ral","TreemapTokenBuilder","classDefRegex","TreemapValueConverter","parseFloat","className","styleText","registerValidationChecks","services","validator","validation","TreemapValidator","registry","ValidationRegistry","checks","Treemap","checkSingleRoot","bind","doc","accept","rootNodeIndentation","row","TreemapRows","indent","TreemapModule","createTreemapServices","TreemapGeneratedModule","VERSION","toFastProperties","toBecomeFast","FakeConstructor","fakeInstance","fakeAccess","bar","guard","props","prop","nodeIsRegExp","isRegExp","isObjectLike","AbstractProduction","definition","_definition","prod","NonTerminal","idx","referencedRule","Rule","orgText","Alternative","ignoreAmbiguities","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","Repetition","RepetitionWithSeparator","Alternation","hasPredicates","Terminal","serializeGrammar","topRules","serializeProduction","convertDefinition","serializedNonTerminal","nonTerminalName","isString","label","terminalType","serializedTerminal","tokType","LABEL","terminalLabel","GAstVisitor","nodeAny","visitNonTerminal","visitAlternative","visitOption","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitRepetition","visitAlternation","visitTerminal","visitRule","func","values","isOptionalProd","alreadyVisited","subProd","getProductionDslName","RestWalker","walk","prevRest","currRest","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","refProd","flatProd","fullOrRest","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","isSequenceProd","firstSet","seq","currSubProd","nextSubProdIdx","hasInnerProdsRemaining","isLastInnerProdOptional","firstForSequence","isBranchingProd","allAlternativesFirsts","innerProd","flatten","firstForBranching","IN","ResyncFollowsWalker","topProd","follows","startWalking","followName","inner","occurenceInParent","fullRest","t_in_topProd_follows","args","apply","difference","isArrayLikeObject","comparator","isCommon","valuesLength","outer","computed","valuesIndex","resIndex","PRINT_ERROR","msg","console","error","PRINT_WARNING","warn","regExpAstCache","regExpParser","getRegExpAst","regExp","regExpStr","regExpAst","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","ensureOptimizations","ast","firstCharOptimizedIndices","ignoreCase","msgSuffix","terms","term","atom","addOptimizedIdxToResult","complement","code","rangeCode","to","minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","atLeast","isWholeOptional","optimizedCharIdx","upperChar","lowerChar","handleIgnoreCase","findCode","setNode","targetCharCodes","codeOrRange","targetCode","CharCodeFinder","found","visitLookahead","visitNegativeLookahead","canMatchCharCode","charCodes","charCodeFinder","DEFAULT_MODE","MODES","SUPPORT_STICKY","sticky","end_of_input","start_of_input","addStartOfInput","addStickyFlag","isCustomPattern","isFunction","isShortPattern","LineTerminatorOptimizedTester","len","checkLineBreaksIssues","lineTerminatorCharCodes","issue","LexerDefinitionErrorType","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","getCharCodes","charsOrCodes","numOrString","addToMapOfArrays","charCodeToOptimizedIdxMap","charCode","timer","Date","getTime","val","time","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","tokenTypeIdx","isParent","categoryMatchesMap","tokenStructuredMatcherNoCategories","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypes","tokenTypesAndParents","clone","categories","searching","currTokType","CATEGORIES","newCategories","expandCategories","hasShortKeyProperty","hasCategoriesProperty","categoryMatches","hasExtendingTokensTypesMapProperty","assignTokenDefaultProps","singleAssignCategoriesToksMap","assignCategoriesMapProp","assignCategoriesTokensProp","nextNode","pathNode","nextCategory","newPath","isTokenType","defaultLexerErrorProvider","buildUnableToPopLexerModeMessage","image","buildUnexpectedCharactersMessage","startOffset","column","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","positionTracking","lineTerminatorsPattern","lineTerminatorCharacters","safeMode","errorMessageProvider","traceInitPerf","skipValidations","recoveryEnabled","lexerDefinition","config","lexerDefinitionErrors","lexerDefinitionWarning","patternIdxToConfig","charCodeToPatternIdxToConfig","modes","emptyGroups","trackStartLines","trackEndLines","hasCustom","canModeBeOptimized","TRACE_INIT","phaseDesc","phaseImpl","traceInitIndent","traceInitMaxIdent","log","traceMethod","traceInitVal","Infinity","actualDefinition","hasOnlySingleMode","defaultMode","errors","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","isUndefined","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","longerAlt","currLongerAlt","MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE","performRuntimeChecks","trackLines","warnings","hasAnyLineBreak","allTokenTypes","concreteTokenTypes","currType","NA","terminatorCharCodes","currIssue","details","buildLineBreakIssueMessage","warningDescriptor","NO_LINE_BREAKS_FLAGS","performWarningRuntimeChecks","allModeNames","currModDef","currModName","validModesNames","missingResult","tokenTypesWithMissingPattern","MISSING_PATTERN","valid","findMissingPatterns","invalidResult","tokenTypesWithInvalidPattern","INVALID_PATTERN","findInvalidPatterns","validTokenTypes","withRegExpPatterns","EndAnchorFinder","visitEndAnchor","invalidRegex","regexpAst","endAnchorVisitor","EOI_ANCHOR_FOUND","findEndOfInputAnchor","StartAnchorFinder","visitStartAnchor","startAnchorVisitor","SOI_ANCHOR_FOUND","findStartOfInputAnchor","invalidFlags","global","UNSUPPORTED_FLAGS_FOUND","findUnsupportedFlags","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","DUPLICATE_PATTERNS_FOUND","findDuplicatePatterns","matchesEmptyString","EMPTY_MATCH_PATTERN","findEmptyMatchRegExps","validateRegExpPattern","invalidTypes","clazz","group","INVALID_GROUP_TYPE_FOUND","findInvalidGroupType","validModes","invalidModes","PUSH_MODE","PUSH_MODE_DOES_NOT_EXIST","findModesThatDoNotExist","canBeTested","str","testIdx","regExpArray","testTokenType","UNREACHABLE_PATTERN","findUnreachablePatterns","validatePatterns","currAnalyzeResult","tracer","defaults","useSticky","debug","action","onlyRelevantTypes","initCharCodeToOptimizedIndexMap","allTransformedPatterns","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdxArr","patternIdxToPushMode","patternIdxToPopMode","patternIdxToCanLineTerminator","patternIdxToIsCustom","patternIdxToShort","currPattern","regExpSource","escapedRegExpString","wrappedRegExp","groupName","longerAltType","acc","canLineTerminator","isCustom","short","canBeOptimized","optimizedIdx","START_CHARS_HINT","lastOptimizedIdx","charOrInt","currOptimizedIdx","optimizedCodes","analyzeTokenTypes","allErrMessagesString","chopInput","identity","matchWithTest","updateLastIndex","noop","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","tokenize","initialMode","tokenizeInternal","j","k","matchAltImage","matchedImage","payload","altPayload","imageLength","newToken","errLength","orgLength","matchedTokensIndex","guessedNumberOfTokens","floor","matchedTokens","groups","clonedResult","groupKeys","currKey","currGroupValue","cloneEmptyGroups","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","possiblePatterns","pop_mode","popToken","startLine","startColumn","newMode","last","modeCanBeOptimized","push_mode","currConfig","nextCharCode","chosenPatternIdxToConfig","chosenPatternsLength","singleCharCode","longerAltLength","longerAltConfig","longerAltPattern","foundTerminator","lastLTEndOffset","numOfLTsInMatch","errorStartOffset","errorLine","errorColumn","foundResyncPoint","pushMode","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","endOffset","tokenVector","tokenToAdd","tokenName","PARENT","POP_MODE","createToken","createTokenInternal","EOF","tokenMatcher","defaultParserErrorProvider","buildMismatchTokenMessage","expected","actual","previous","ruleName","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","errSuffix","allLookAheadPaths","currAltPaths","nextValidTokenSequences","currPath","currTokenType","itemMsg","buildEarlyExitMessage","expectedIterationPaths","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","topLevelName","duplicateProd","dslName","extraArgument","buildNamespaceConflictError","buildAlternationPrefixAmbiguityError","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","buildLeftRecursionError","leftRecursionPath","currRule","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName","GastRefResolverVisitor","nameToTopRule","errMsgProvider","resolveRefs","currTopLevel","ref","ParserDefinitionErrorType","UNRESOLVED_SUBRULE_REF","unresolvedRefName","setter","accumulator","initializer","AbstractNextPossibleTokensWalker","possibleTokTypes","nextProductionName","nextProductionOccurrence","isAtEndOfPath","ruleStack","reverse","occurrenceStack","updateExpectedNext","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","restProd","AbstractNextTerminalAfterProductionWalker","topRule","isEndOfRule","NextTerminalAfterManyWalker","firstAfterMany","NextTerminalAfterManySepWalker","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","getAlternativesForProd","alternatives","newDef","currAlt","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currRuleStack","currOccurrenceStack","nextPath","nextIdx","nextTokenType","nextTokenOccurrence","newRuleStack","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack","PROD_TYPE","getProdType","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","getLookaheadPaths","prodType","maxLookahead","getLookaheadPathsForOr","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","dynamicTokensEnabled","numOfAlts","areAllOneTokenLookahead","orAlts","predicates","GATE","currNumOfPaths","currPredicate","currPathLength","nextToken","LA","singleTokenAlts","choiceToAlt","currExtendingType","buildSingleAlternativeLookaheadFunction","numOfPaths","singleTokensTypes","expectedTokenUniqueKey","RestDefinitionFinderWalker","targetOccurrence","targetProdType","restDef","checkIsTarget","expectedProdType","InsideDefinitionFinderVisitor","targetRef","expectedProdName","initializeArrayOfArrays","pathToHashKeys","longerKeys","currShorterKey","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","dict","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","prefixKeys","currAltResult","containsPath","newPartialPathsAndSuffixes","ruleGrammar","insideDefVisitor","insideDef","afterDef","searchPath","compareOtherPath","otherPath","searchTok","otherTok","areTokenCategoriesNotUsed","lookAheadPaths","singleAltPaths","singlePath","identifyProductionForDuplicates","getExtraProductionArgument","OccurrenceValidationCollector","allProductions","subrule","option","manySep","atLeastOne","atLeastOneSep","many","or","validateNoLeftRecursion","nextNonTerminals","getFirstNoneTerminal","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","firstProd","currSubDef","isFirstOptional","hasMore","rest","OrCollector","alternations","RepetitionCollector","MISMATCHED_TOKEN_EXCEPTION","NO_VIABLE_ALT_EXCEPTION","EARLY_EXIT_EXCEPTION","NOT_ALL_INPUT_PARSED_EXCEPTION","RECOGNITION_EXCEPTION_NAMES","isRecognitionException","RecognitionException","resyncedTokens","setPrototypeOf","captureStackTrace","MismatchedTokenException","previousToken","NoViableAltException","NotAllInputParsedException","EarlyExitException","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","attemptInRepetitionRecovery","prodFunc","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","notStuck","getKeyForAutomaticLookahead","firstAfterRepInfo","firstAfterRepMap","currRuleName","getCurrRuleFullName","getGAstProductions","expectTokAfterLastMatch","nextTokIdx","RULE_STACK","shouldInRepetitionRecoveryBeTried","tryInRepetitionRecovery","AT_LEAST_ONE_IDX","MANY_SEP_IDX","AT_LEAST_ONE_SEP_IDX","ruleIdx","LLkLookaheadStrategy","DEFAULT_PARSER_CONFIG","validate","leftRecursionErrors","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","validateAmbiguousAlternationAlternatives","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","currTopRule","orCollector","ors","currOr","exceptLast","currAlternative","possibleFirstInAlt","NONE_LAST_EMPTY_ALT","validateEmptyOrAlternative","globalMaxLookahead","currOccurrence","actualMaxLookahead","altsAmbiguityErrors","foundAmbiguousPaths","identicalAmbiguities","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","currAmbDescriptor","ambgIndices","AMBIGUOUS_ALTS","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","pathsAndIndices","currPathsAndIdx","currPathAndIdx","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","prefix","otherTokType","currAmbPathAndIdx","AMBIGUOUS_PREFIX_ALTS","checkPrefixAlternativesAmbiguities","topLevelRules","collectorVisitor","allRuleProductions","currProd","pathsInsideProduction","NO_NON_EMPTY_LOOKAHEAD","buildLookaheadForAlternation","laFuncBuilder","buildLookaheadFuncForOr","buildLookaheadForOptional","lookaheadBuilder","buildLookaheadFuncForOptionalProd","dslMethods","repetitionWithSeparator","repetitionMandatory","repetitionMandatoryWithSeparator","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","setNodeLocationFull","defineNameProp","nameValue","configurable","writable","defaultVisit","ctx","param","childrenNames","childrenNamesLength","currChildArray","currChildArrayLength","currChild","CstVisitorDefinitionError","RECORDING_NULL_OBJECT","description","HANDLE_SEPARATOR","MAX_METHOD_IDX","pow","RFT","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","recordProd","prodConstructor","mainProdArg","handleSep","assertMethodIdxIsValid","prevProd","recordingProdStack","grammarAction","DEF","newProd","SEP","MAX_LOOKAHEAD","recordOrProd","hasOptions","newOrProd","IGNORE_AMBIGUITIES","currAltFlat","ALT","getIdxSuffix","KNOWN_RECORDER_ERROR","END_OF_FILE","NaN","outputCst","nodeLocationTracking","DEFAULT_RULE_CONFIG","recoveryValueFunc","resyncEnabled","derivedCtor","EMPTY_ALT","Parser","performSelfAnalysis","parserInstance","defErrorsMsgs","selfAnalysisDone","enableRecording","definedRulesNames","originalGrammarAction","recordedRuleGast","topLevelRuleRecord","gastProductionsCache","disableRecording","resolverErrors","actualOptions","topRulesTable","topLevels","refResolver","definitionErrors","validationErrors","tokensMap","duplicateErrors","productionGroups","duplicates","currGroup","currDuplicates","defError","DUPLICATE_PRODUCTIONS","parameter","validateDuplicateProductions","termsNamespaceConflictErrors","tokenNames","currToken","CONFLICT_TOKENS_RULES_NAMESPACE","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","TOO_MANY_ALTS","validateTooManyAlts","duplicateRulesError","allRules","occurrences","DUPLICATE_RULE_NAME","validateRuleDoesNotAlreadyExist","lookaheadValidationErrors","lookaheadValidationErrorMessages","lookaheadStrategy","errorMessage","assign","CUSTOM_LOOKAHEAD_VALIDATION","validateLookahead","allFollows","topProductions","reSyncFollows","currRefsFollow","computeAllProdsFollows","resyncFollows","_b","initialize","preComputeLookaheadFunctions","DEFER_DEFINITION_ERRORS_HANDLING","tokenVocabulary","that","initErrorHandler","initLexerAdapter","initLooksAhead","initRecognizerEngine","initRecoverable","initTreeBuilder","initContentAssist","initGastRecorder","initPerformanceTracer","getTokenToInsert","tokToInsert","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","canTokenTypeBeDeletedInRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","passedResyncPoint","nextTokenWithoutResync","generateErrorMessage","SAVE_ERROR","SKIP_TOKEN","addToResyncTokens","importLexerState","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","mismatchedTok","possibleFollowsTokType","isInCurrentRuleReSyncSet","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","foundMatch","resyncTokType","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","followStack","resyncTokens","reSyncTo","getHumanReadableRuleStack","currShortName","lookAheadFuncsCache","collectMethods","prodIdx","laFunc","fullRuleNameToShort","setLaFuncCache","computeLookaheadFunc","prodKey","prodMaxLookahead","dslMethodName","getLaFuncFromCache","CST_STACK","setNodeLocationFromToken","setNodeLocationFromNode","cstPostRule","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstNode","location","fullRuleName","create","ruleCstNode","prevToken","consumedToken","rootCst","tokenTypeName","ruleCstResult","preCstNode","ruleResult","addNoneTerminalToCst","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","ruleNames","derivedConstructor","semanticProto","validateVisitor","semanticDefinitionErrors","visitorInstance","missingErrors","missingRuleNames","MISSING_METHOD","methodName","validateMissingCstMethods","errorMessages","currDefError","_RULE_NAMES","createBaseSemanticVisitorConstructor","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","baseConstructor","withDefaultsProto","createBaseVisitorConstructorWithDefaults","tokVector","tokVectorLength","newInput","howMuch","soughtIdx","newState","resetLexerState","moveToTerminatedState","getLexerPosition","shortRuleNameToFull","ruleShortNameIdx","subruleIdx","isBackTrackingStack","uniqueTokens","noTokenCategoriesUsed","tokenConstructor","defineRule","impl","shortName","invokeRuleWithTry","ruleInvocationStateUpdate","cst","invokeRuleCatch","ruleFinallyStateUpdate","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","recogError","partialCstResult","recoveredNode","optionInternal","actionORMethodDef","optionInternalLogic","orgLookaheadFunction","atLeastOneInternal","laKey","atLeastOneInternalLogic","raiseEarlyExitException","ERR_MSG","doSingleRepetition","atLeastOneSepFirstInternal","atLeastOneSepFirstInternalLogic","separatorLookAheadFunc","CONSUME","repetitionSepSecondInternal","manyInternal","manyInternalLogic","lookaheadFunction","manySepFirstInternal","manySepFirstInternalLogic","nextTerminalAfterWalker","beforeIteration","orInternal","altsOrOpts","altIdxToTake","raiseNoAltException","isAtEndOfInput","firstRedundantTok","subruleInternal","ruleToCall","ARGS","subruleInternalError","consumeInternal","consumeInternalError","eFromConsumption","consumeInternalRecovery","eFromInRuleRecovery","saveRecogState","savedErrors","savedRuleStack","lexerState","reloadRecogState","fullName","ACTION","consume","CONSUME1","CONSUME2","CONSUME3","CONSUME4","CONSUME5","CONSUME6","CONSUME7","CONSUME8","CONSUME9","SUBRULE","SUBRULE1","SUBRULE2","SUBRULE3","SUBRULE4","SUBRULE5","SUBRULE6","SUBRULE7","SUBRULE8","SUBRULE9","OPTION1","OPTION2","OPTION3","OPTION4","OPTION5","OPTION6","OPTION7","OPTION8","OPTION9","OR","OR1","OR2","OR3","OR4","OR5","OR6","OR7","OR8","OR9","MANY","MANY1","MANY2","MANY3","MANY4","MANY5","MANY6","MANY7","MANY8","MANY9","MANY_SEP","MANY_SEP1","MANY_SEP2","MANY_SEP3","MANY_SEP4","MANY_SEP5","MANY_SEP6","MANY_SEP7","MANY_SEP8","MANY_SEP9","AT_LEAST_ONE","AT_LEAST_ONE1","AT_LEAST_ONE2","AT_LEAST_ONE3","AT_LEAST_ONE4","AT_LEAST_ONE5","AT_LEAST_ONE6","AT_LEAST_ONE7","AT_LEAST_ONE8","AT_LEAST_ONE9","AT_LEAST_ONE_SEP","AT_LEAST_ONE_SEP1","AT_LEAST_ONE_SEP2","AT_LEAST_ONE_SEP3","AT_LEAST_ONE_SEP4","AT_LEAST_ONE_SEP5","AT_LEAST_ONE_SEP6","AT_LEAST_ONE_SEP7","AT_LEAST_ONE_SEP8","AT_LEAST_ONE_SEP9","RULE","implementation","ruleImplementation","OVERRIDE_RULE","ruleErrors","INVALID_RULE_OVERRIDE","validateRuleIsOverridden","BACKTRACK","orgState","getSerializedGastProductions","_errors","ruleOccurrenceStack","newErrors","userDefinedErrMsg","insideProdPaths","actualTokens","errMsgTypes","lookAheadPathsPerAlternative","computeContentAssist","startRuleName","precedingInput","startRuleGast","topRuleName","topProduction","RECORDING_PHASE","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION_RECORD","BACKTRACK_RECORD","LA_RECORD","newTopLevelRule","originalError","mutabilityError","newNoneTerminal","userTraceInitPerf","traceIsNumber","baseCtor","baseProto","getOwnPropertyNames","propName","basePropDescriptor","getOwnPropertyDescriptor","CstParser","configClone","EmbeddedActionsParser","CstNodeDefinitionGenerator","rawElements","visitEach","grouped","el","propertyName","allNullable","canBeNull","propertyType","optional","visitEachAndOverrideWith","getType","override","production","kind","rsAstralRange","rsAstral","rsCombo","rsFitz","rsNonAstral","rsRegional","rsSurrPair","reOptMod","rsModifier","rsOptVar","rsSeq","rsSymbol","reUnicode","strSymbols","chr","trailing","getTypeString","getNodeInterfaceName","getNodeChildrenTypeName","defaultOptions","includeVisitorInterface","visitorInterfaceName","generateCstDts","productions","effectiveOptions","model","generator","buildModel","contentParts","nodes","nodeCstInterface","nodeInterfaceName","childrenTypeName","genNodeInterface","nodeChildrenInterface","typeName","typeNames","buildTypeString","genChildProperty","genNodeChildrenType","genCstNodeTypes","genVisitorFunction","genDts","createSyntaxDiagramsCode","resourceBase","css","clearCache","GitGraphTokenBuilder","GitGraphModule","CommonValueConverter","createGitGraphServices","GitGraph","GitGraphGeneratedModule","InfoTokenBuilder","InfoModule","createInfoServices","Info","InfoGeneratedModule","Emitter","Event","ral_1","_disposable","dispose","None","CallbackList","callback","bucket","_callbacks","_contexts","remove","foundCallbackWithDifferentContext","splice","invoke","ret","callbacks","contexts","default","_options","event","_event","listener","thisArgs","disposables","onFirstListenerAdd","_noop","onLastListenerRemove","fire","RangeComparison","streamCst","flattenCst","isChildNode","child","parent","tokenToRange","toDocumentSegment","compareRange","Before","After","startInside","endInside","Inside","OverlapBack","OverlapFront","Outside","inRange","DefaultNameRegexp","findDeclarationNodeAtOffset","nameRegexp","localOffset","textAtOffset","findLeafNodeAtOffset","findCommentNode","commentNames","getPreviousNode","isCommentNode","searchResult","binarySearch","findLeafNodeBeforeOffset","closest","closestNode","left","right","middle","middleNode","getNextNode","getStartlineNode","selfIndex","getInteriorNodes","commonParent","aParents","getParentChain","bParents","current","aParent","bParent","getCommonParent","chain","linkContentToContainer","entries","startsWith","$container","$containerProperty","$containerIndex","getContainerOfType","typePredicate","hasContainerOfType","getDocument","findRootNode","$document","streamContents","keyIndex","arrayIndex","isAstNodeInRange","streamAst","astNode","nodeRange","$cstNode","streamReferences","findLocalReferences","targetNode","lookup","parseResult","refs","assignMandatoryProperties","typeMetaData","genericNode","copyDefaultValue","copyAstNode","buildReference","copy","$refNode","copiedArray","objectProto","sources","propsIndex","propsLength","PacketTokenBuilder","PacketModule","createPacketServices","Packet","PacketGeneratedModule","parsers","initializers","info","async","createInfoServices2","LangiumParser","packet","createPacketServices2","pie","createPieServices2","architecture","createArchitectureServices","createArchitectureServices2","Architecture","gitGraph","createGitGraphServices2","radar","createRadarServices","createRadarServices2","Radar","treemap","createTreemapServices2","diagramType","lexerErrors","parserErrors","MermaidParseError","err","minimalGrammarModule","LanguageMetaData","fileExtensions","languageId","minimalSharedGrammarModule","AstReflection","loadGrammarFromJson","json","createMinimalGrammarServices","serializer","JsonSerializer","deserialize","workspace","LangiumDocumentFactory","fromModel","__defProp","target","Statement","isArchitecture","Axis","Branch","isBranch","Checkout","CherryPicking","ClassDefStatement","Commit","isCommit","Curve","Edge","Entry","isGitGraph","isInfo","Item","Junction","Merge","isMerge","isPacket","PacketBlock","isPacketBlock","isPie","PieSection","isPieSection","Service","isTreemap","loadedInfoGrammar","loadedPacketGrammar","loadedPieGrammar","loadedArchitectureGrammar","loadedGitGraphGrammar","loadedRadarGrammar","loadedTreemapGrammar","TreemapRow","Direction","Leaf","Section","MermaidAstReflection","InfoGrammar","PacketGrammar","PieGrammar","ArchitectureGrammar","GitGraphGrammar","RadarGrammar","TreemapGrammar","InfoLanguageMetaData","mode","PacketLanguageMetaData","PieLanguageMetaData","ArchitectureLanguageMetaData","GitGraphLanguageMetaData","RadarLanguageMetaData","TreemapLanguageMetaData","ArchitectureGeneratedModule","RadarGeneratedModule","rulesRegexes","ACC_DESCR","ACC_TITLE","TITLE","DefaultValueConverter","runConverter","runCommonConverter","_rule","_input","keywords","CommonTokenBuilder","CancellationTokenSource","CancellationToken","Is","events_1","isCancellationRequested","onCancellationRequested","Cancelled","is","candidate","boolean","shortcutEvent","handle","setTimeout","MutableToken","_isCancelled","cancel","_emitter","_token","ArchitectureTokenBuilder","ArchitectureValueConverter","ArchitectureModule","Module","module1","module2","module3","module4","module5","module6","module7","module8","module9","_inject","_merge","merge","m1","m2","isProxy","eagerLoad","module","injector","proxy","Proxy","deleteProperty","_resolve","ownKeys","__requested__","cause","value2","value1","stringArray","number","Number","elem","buildATNKey","AbstractTransition","isEpsilon","AtomTransition","EpsilonTransition","RuleTransition","ruleStart","followState","atn","tokenRef","currentRule","nonTerminal","ruleToStartState","addTransition","ruleRef","defineDecisionState","makeAlts","epsilon","decisionMap","block","starState","star","repetitionSep","plusState","plus","repetitionMandatorySep","handles","altsLength","transition","transitions","isRuleTransition","ruleTransition","removeState","makeBlock","blkStart","blkEnd","loop","loopback","entry","loopEnd","decisionStates","decision","buildRuleHandle","stop","ruleToStopState","epsilonOnlyTransitions","nextTokenWithinRule","stateNumber","states","DFA_ERROR","ATNConfigSet","configs","finalize","getATNConfigKey","elements","stack","createDFACache","startState","predicateSet","atnStartState","PredicateSet","EMPTY_PREDICATES","LLStarLookaheadStrategy","logging","ruleLength","createRuleStartAndStopATNStates","ruleBlock","createATN","dfas","decisionLength","decisionToDFA","initATNSimulator","decisionIndex","isLL1Sequence","prediction","gate","adaptivePredict","sequences","allowEmpty","fullSet","altSet","indices","dfaCaches","dfa","addDFAState","newDFAState","atnState","numberOfTransitions","closure","computeStartState","performLookahead","s0","previousD","getExistingTargetState","computeLookaheadTarget","buildAdaptivePredictError","isAcceptState","lookahead","reach","intermediate","skippedStopStates","transitionLength","getReachableTarget","hasConfigInRuleStopState","computeReachSet","addDFAEdge","predictedAlt","getUniqueAlt","uniqueAlt","allConfigsInRuleStopStates","altSets","configToAlts","getConflictingAltSets","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasConflictTerminatingPrediction","reportLookaheadAmbiguity","tokenLabel","buildAmbiguityError","nextTransitions","actualToken","possibleTokenTypes","tokenPath","edges","mapKey","atnStack","getEpsilonTarget","CstNodeBuilder","nodeStack","rootNode","buildRootNode","RootCstNodeImpl","buildCompositeNode","feature","compositeNode","CompositeCstNodeImpl","grammarSource","buildLeafNode","leafNode","LeafCstNodeImpl","removeNode","addHiddenNodes","added","construct","AbstractCstNode","_astNode","_offset","_length","_hidden","_tokenType","_range","CstNodeContainer","firstNonHiddenNode","lastNonHiddenNode","firstNode","lastNode","_rangeCache","firstRange","lastRange","Position","items","addParents","_text","DatatypeSymbol","isDataTypeNode","withRuleSuffix","endsWith","AbstractLangiumParser","_unorderedGroups","lexer","wrapper","ChevrotainWrapper","ParserConfig","ParserErrorMessageProvider","choices","wrapOr","wrapOption","wrapMany","wrapAtLeastOne","getRule","isRecording","IS_RECORDING","unorderedGroups","getRuleStack","wrapSelfAnalysis","nodeBuilder","assignmentMap","linker","references","Linker","converter","astReflection","computeRuleType","ruleMethod","DEFINE_RULE","startImplementation","mainRule","isDataTypeRule","explicit","getExplicitRuleType","lexerResult","clear","lexerReport","report","createNode","extractHiddenTokens","hiddenTokens","wrapConsume","isValidToken","assignment","isCrossRef","getAssignment","convertedValue","convert","operator","subruleResult","wrapSubrule","performSubruleAssignment","newItem","assignWithoutOverride","existingValue","targetCstNode","AbstractParserErrorMessageProvider","LangiumParserErrorMessageProvider","LangiumCompletionParser","elementStack","lastElementStack","nextTokenIndex","stackSize","resetState","tokenIndex","keepStackSize","resetStackSize","removeUnexpectedElements","before","after","defaultConfig","useDefaultLookahead","createParser","parserContext","reachable","parserRules","buildElement","buildRules","ignoreGuard","method","buildKeyword","actionType","getTypeName","buildAction","buildCrossReference","ruleCall","namedArgs","buildPredicate","ruleArgs","ruleTarget","parameters","buildRuleCallPredicate","getToken","buildRuleCall","methods","predicatedMethod","getGuardCondition","buildAlternatives","orIdx","idFunc","groupIdx","lParser","wrapped","wrap","groupState","trackedAlternatives","delete","buildUnorderedGroup","buildGroup","cardinality","condition","true","guardCondition","crossRef","terminalRule","findNameAssignment","assignTerminal","getRuleName","lastTick","OperationCancelled","isOperationCancelled","interruptAndCheck","performance","now","Promise","setImmediate","Deferred","promise","reject","arg","FullTextDocument","uri","version","_uri","_languageId","_version","_content","_lineOffsets","getText","offsetAt","update","changes","change","isIncremental","getWellformedRange","lineOffsets","addedLineOffsets","computeLineOffsets","diff","isFull","getLineOffsets","positionAt","low","high","mid","ensureBeforeEOL","position","lineOffset","nextLineOffset","isEOL","lineCount","rangeLength","TextDocument","mergeSort","data","compare","leftIdx","rightIdx","isAtLineStart","textOffset","ch","getWellformedEdit","textEdit","newText","document","applyEdits","edits","sortedEdits","lastModifiedOffset","spans","DocumentState","DefaultLangiumDocumentFactory","serviceRegistry","textDocuments","TextDocuments","FileSystemProvider","fromUri","cancellationToken","createAsync","fromTextDocument","textDocument","fromString","$model","createLangiumDocument","cancelToken","parseAsync","Parsed","textDocumentGetter","createTextDocumentGetter","oldText","getServices","AsyncParser","textDoc","DefaultLangiumDocuments","documentMap","langiumDocumentFactory","all","addDocument","uriString","getOrCreateDocument","createDocument","then","hasDocument","invalidateDocument","langiumDoc","unlink","Changed","precomputedScopes","deleteDocument","ref_resolving","DefaultLinker","langiumDocuments","LangiumDocuments","scopeProvider","ScopeProvider","astNodeLocator","AstNodeLocator","link","doLink","_ref","getCandidate","_nodeDescription","documentUri","linkedNode","loadAstNode","createLinkingError","getScope","getElement","refNode","refText","refData","getLinkedNode","ComputedScopes","descr","getAstNodePath","$nodeDescription","nodeDescription","getAstNode","targetDescription","referenceType","DefaultNameProvider","getName","isNamed","getNameNode","findNodeForProperty","UriUtils","ValidationCategory","DocumentValidator","equals","fromPath","toPath","fromParts","toParts","repeat","DefaultReferences","nameProvider","NameProvider","IndexManager","nodeLocator","findDeclaration","sourceCstNode","findAssignment","nodeElem","nameNode","findDeclarationNode","findReferences","includeDeclaration","getReferenceToSelf","indexReferences","findAllReferences","sourceUri","sourcePath","targetUri","segment","local","MultiMap","addAll","entriesGroupedByKey","BiMap","inverse","getKey","DefaultScopeComputation","descriptions","AstNodeDescriptionProvider","computeExports","computeExportsForNode","parentNode","exportNode","createDescription","computeLocalScopes","scopes","processNode","StreamScope","outerScope","getAllElements","MapScope","localName","elementStream","DisposableCache","toDispose","isDisposed","onDispose","disposable","throwIfDisposed","SimpleCache","cache","provider","ContextCache","contextKey","cacheForContext","contextCache","documentCache","WorkspaceCache","sharedServices","DocumentBuilder","onBuildPhase","onUpdate","_changed","deleted","DefaultScopeProvider","indexManager","globalScopeCache","precomputed","currentNode","allDescriptions","desc","getGlobalScope","createScope","createScopeForNodes","_context","allElements","isIntermediateReference","DefaultJsonSerializer","ignoreProperties","commentProvider","documentation","CommentProvider","serialize","serializeOptions","specificReplacer","replacer","defaultReplacer","currentDocument","space","deserializeOptions","linkNode","sourceText","textRegions","comments","uriConverter","_c","_d","refValue","targetDocument","$ref","$error","addAstNodeRegionWithAssignmentsTo","$textRegion","documentURI","$sourceText","comment","getComment","$comment","createDocumentSegment","assignments","propertyAssignments","findNodesForProperty","containerProperty","containerIndex","reviveReference","mutable","getRefNode","fragmentIndex","DefaultServiceRegistry","fileExtensionMap","languageIdMap","language","singleton","hasServices","diagnosticData","entriesBefore","entriesAfter","checksRecord","thisObj","category","check","wrapValidationException","addEntry","handleException","functionality","messageContext","getChecks","registerBeforeDocument","checkBefore","wrapPreparationException","registerAfterDocument","checkAfter","checksBefore","checksAfter","DefaultDocumentValidator","validationRegistry","metadata","validateDocument","processLexingErrors","stopAfterLexingErrors","LexingError","processParsingErrors","stopAfterParsingErrors","ParsingError","processLinkingErrors","stopAfterLinkingErrors","LinkingError","validateAst","lexerDiagnostics","lexerDiagnostic","severity","diagnostic","toDiagnosticSeverity","toDiagnosticData","getSource","parserError","linkingError","containerType","toDiagnostic","validationItems","acceptor","validateAstBefore","validateAstNodes","validateAstAfter","getDiagnosticRange","codeDescription","tags","relatedInformation","findNodeForKeyword","LexingWarning","LexingInfo","LexingHint","DefaultAstNodeDescriptionProvider","nameNodeSegment","nameSegmentGetter","nameSegment","selectionSegment","DefaultReferenceDescriptionProvider","createDescriptions","targetNodeDescr","refCstNode","docUri","DefaultAstNodeLocator","segmentSeparator","indexSeparator","containerPath","newSegment","getPathSegment","currentValue","propertyIndex","Disposable","DefaultConfigurationProvider","_ready","settings","workspaceConfig","onConfigurationSectionUpdateEmitter","ready","params","capabilities","configuration","initialized","languages","section","lang","toSectionName","fetchConfiguration","configToUpdate","conf","updateSectionConfiguration","updateConfiguration","getConfiguration","sectionName","onConfigurationSectionUpdate","DefaultDocumentBuilder","updateBuildOptions","updateListeners","buildPhaseListeners","documentPhaseListeners","buildState","documentBuildWaiters","currentState","build","documents","Validated","IndexedReferences","previousCategories","validationChecks","completed","emitUpdate","buildDocuments","changed","deletedUri","changedUri","newDocument","allChangedUris","shouldRelink","rebuildDocuments","sortDocuments","Linked","hasTextDocument","changedUris","isAffected","prepareBuild","runCancelable","IndexedContent","updateContent","scopeComputation","ScopeComputation","updateReferences","toBeValidated","shouldValidate","targetState","filtered","notifyDocumentPhase","targetStateDocs","notifyBuildPhase","onDocumentPhase","waitUntil","uriOrToken","buildDisposable","cancelDisposable","listenersCopy","getBuildOptions","validationSetting","DefaultIndexManager","symbolIndex","symbolByTypeIndex","referenceIndex","astNodePath","targetDocUri","docRefs","refDescr","nodeType","uris","documentUris","getFileDescriptions","indexData","ReferenceDescriptionProvider","DefaultWorkspaceManager","initialBuildOptions","documentBuilder","mutex","WorkspaceLock","workspaceFolders","folders","_params","write","initializeWorkspace","performStartup","collector","loadAdditionalDocuments","wf","getRootFolder","traverseFolder","_folders","_collector","workspaceFolder","folderPath","includeEntry","isDirectory","isFile","_workspaceFolder","DefaultLexerErrorMessageProvider","DEFAULT_TOKENIZE_OPTIONS","DefaultLexer","LexerErrorMessageProvider","tokenBuilder","toTokenTypeDictionary","lexerTokens","isTokenTypeDictionary","chevrotainLexer","chevrotainResult","isIMultiModeLexerDefinition","res","isTokenTypeArray","getLines","tagRegex","inlineTagRegex","buildInlineTokens","lineIndex","characterIndex","Range","matchIndex","startContent","tagName","endContent","nonWhitespaceRegex","whitespaceEndRegex","skipWhitespace","lastCharacter","parseJSDocElement","parseJSDocTag","parseJSDocText","JSDocLineImpl","inlines","appendEmptyLine","firstToken","lastToken","lines","parseJSDocInline","JSDocTextImpl","parseJSDocLine","inline","tagToken","docLine","JSDocTagImpl","normalizeOptions","normalizeOption","escaped","JSDocCommentImpl","getTag","getAllTags","getTags","fillNewlines","toMarkdown","renderTag","toMarkdownDefault","rendered","tag","display","displayStart","renderedLink","renderLink","renderLinkDefault","renderInlineTag","marker","JSDocDocumentationProvider","getDocumentation","normalizedOptions","isJSDoc","firstRegex","lastRegex","opts","currentLine","currentCharacter","tagMatch","fullMatch","inlineTagMatches","matchAll","startPosition","parseJSDocComment","parseJSDoc","documentationLinkRenderer","documentationTagRenderer","findNameInPrecomputedScopes","findNameInGlobalScope","_node","_tag","DefaultCommentProvider","grammarConfig","GrammarConfig","isAstNodeWithComment","multilineCommentRules","DefaultAsyncParser","syncParser","_cancelToken","DefaultWorkspaceLock","previousTokenSource","writeQueue","readQueue","cancelWrite","tokenSource","enqueue","read","queue","deferred","performNextOperation","shift","DefaultHydrator","grammarElementIdMap","tokenTypeIdMap","dehydrate","dehydrateLexerReport","dehydrateAstNode","createDehyrationContext","astNodes","cstNodes","dehydrateCstNode","arr","dehydrateReference","getGrammarElementId","hydrate","createHydrationContext","hydrateCstNode","hydrateAstNode","hydrateCstLeafNode","setParent","hydrateReference","num","cstNodeObj","getGrammarElement","hydrated","getTokenType","createGrammarElementIdMap","id","DocumentationProvider","isCommentTerminal","createGrammarConfig","prepareLangiumParser","createLangiumParser","CompletionParser","createCompletionParser","References","Hydrator","WorkspaceManager","ConfigurationProvider","cc","insertToSet","subItem","addFlag","flagObj","flagKey","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","isCharacter","digitsCharCodes","wordCharCodes","whitespaceCodes","hexDigitPattern","decimalPattern","decimalPatternNoZero","saveState","restoreState","consumeChar","disjunction","multiLine","isRegExpFlag","popChar","peekChar","isTerm","isAssertion","assertion","isBacktracking","atMost","integerIncludingZero","isDigit","greedy","dotAll","atomEscape","characterClass","isPatternCharacter","patternCharacter","isQuantifier","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","escapeCode","parseHexDigits","classPatternCharacterAtom","isClassAtom","classAtom","isRangeDash","classEscape","capturing","groupAst","nextChar","isAtom","prevState","howMany","hexString","hexChar","subChild","visitPattern","visitFlags","visitDisjunction","visitWordBoundary","visitNonWordBoundary","visitGroupBackReference","visitQuantifier","getEntryRule","getHiddenRules","allTerminals","entryRule","topMostRules","ruleDfs","visitedSet","refRule","getCrossReferenceTerminal","nameAssigment","findNodesForPropertyInternal","nodeFeature","findNodesForKeyword","findNodesForKeywordInternal","treeIterator","keywordNodes","childNode","startNode","findNameAssignmentInternal","go","refType","childAssignment","typeRef","getActionAtElement","isOptionalCardinality","isArrayCardinality","isArrayOperator","isDataTypeRuleInternal","visited","isDataType","isDataTypeInternal","primitiveType","stringType","inferredType","dataType","returnType","getActionType","getRuleTypeName","getRuleType","abstractElementToRegex","flagText","WILDCARD","withCardinality","keywordToRegex","until","negate","lastSlash","regexFlags","RadarTokenBuilder","RadarModule","convertInt","convertString","convertID","convertNumber","convertBoolean","convertBigint","convertDate","convertEscapeCharacter","BigInt"],"ignoreList":[],"sourceRoot":""}