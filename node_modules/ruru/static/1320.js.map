{"version":3,"file":"1320.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/buffer.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoGroup(); }\n}\nexport class UndoRedoSource {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoSource(); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', null, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'));\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'));\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorPrimaryForeground = registerColor('editorMultiCursor.primary.foreground', editorCursorForeground, nls.localize('editorMultiCursorPrimaryForeground', 'Color of the primary editor cursor when multiple cursors are present.'));\nexport const editorMultiCursorPrimaryBackground = registerColor('editorMultiCursor.primary.background', editorCursorBackground, nls.localize('editorMultiCursorPrimaryBackground', 'The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorSecondaryForeground = registerColor('editorMultiCursor.secondary.foreground', editorCursorForeground, nls.localize('editorMultiCursorSecondaryForeground', 'Color of secondary editor cursors when multiple cursors are present.'));\nexport const editorMultiCursorSecondaryBackground = registerColor('editorMultiCursor.secondary.background', editorCursorBackground, nls.localize('editorMultiCursorSecondaryBackground', 'The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', editorWhitespaces, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', editorWhitespaces, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', deprecatedEditorIndentGuides, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', '#00000000', nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', '#00000000', nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', '#00000000', nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', '#00000000', nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', '#00000000', nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', deprecatedEditorActiveIndentGuides, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', '#00000000', nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', '#00000000', nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', '#00000000', nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', '#00000000', nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', '#00000000', nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', deprecatedEditorActiveLineNumber, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', null, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', editorBackground, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', null, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', rulerRangeDefault, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', '#00000000', nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', '#00000000', nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', '#00000000', nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: 'new Color(new RGBA(255, 50, 50, 1))', hcLight: '#B5200D' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', '#00000000', nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', '#00000000', nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', '#00000000', nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', '#00000000', nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', '#00000000', nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', '#00000000', nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', '#00000000', nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', '#00000000', nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', '#00000000', nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', '#00000000', nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', '#00000000', nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', '#00000000', nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', editorWarningForeground, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', editorWarningBackground, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITreeSitterParserService = createDecorator('treeSitterParserService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n"],"names":["emptyArr","SmallImmutableSet","this","cache","Array","create","items","additionalItems","length","cached","empty","getEmpty","constructor","add","value","keyProvider","key","getKey","idx","newItem","newItems","slice","push","merge","other","merged","i","Math","max","item1","item2","intersects","min","identityKeyProvider","DenseKeyProvider","Map","existing","get","undefined","size","set","ModelRawFlush","changeType","LineInjectedText","applyInjectedText","lineText","injectedTexts","result","lastOriginalOffset","injectedText","substring","column","options","content","fromDecorations","decorations","decoration","before","ownerId","range","startLineNumber","startColumn","after","endLineNumber","endColumn","sort","a","b","lineNumber","order","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","resultingSelection","containsEvent","type","len","concat","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","_mergeChangeEvents","eol","isFlush","isEolChange","IUndoRedoService","createDecorator","ResourceEditStackSnapshot","resource","elements","UndoRedoGroup","_ID","id","nextOrder","None","UndoRedoSource","escapeNewLine","str","replace","TextChange","oldLength","oldText","oldEnd","oldPosition","newLength","newText","newEnd","newPosition","toString","_writeStringSize","_writeString","offset","charCodeAt","_readString","decodeUTF16LE","writeSize","write","read","dest","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","e1","e2","_splitCurr","_splitPrev","mergePrev","mergeCurr","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","resultLen","prev","curr","CursorColumns","_nextVisibleColumn","codePoint","visibleColumn","tabSize","nextRenderTabStop","visibleColumnFromColumn","lineContent","textLen","text","iterator","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","nextIndentTabStop","indentSize","prevRenderTabStop","prevIndentTabStop","BracketInfo","nestingLevel","nestingLevelOfEqualBracketType","isInvalid","BracketPairInfo","openingBracketRange","closingBracketRange","bracketPairNode","openingBracketInfo","openingBracket","bracketInfo","BracketPairWithMinIndentationInfo","minVisibleColumnIndentation","super","BracketPairsTree","Disposable","didLanguageChange","languageId","brackets","textModel","getLanguageConfiguration","didChangeEmitter","Emitter","denseKeyProvider","LanguageAgnosticBracketTokens","onDidChange","event","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","tokenization","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","getLanguageId","tokenizer","FastTokenizer","getValue","parseDocument","handleDidChangeBackgroundTokenizationState","wasUndefined","fire","handleDidChangeTokens","ranges","map","r","TextEditInfo","toLength","handleEdits","handleContentChanged","change","fromModelContentChanges","tokenChange","combineTextEditInfos","flushQueue","previousAst","immutable","previousAstClone","TextBufferTokenizer","getBracketsInRange","onlyColorizedBrackets","startOffset","endOffset","CallbackIterable","cb","node","collectBrackets","lengthZero","getBracketPairsInRange","includeMinIndentation","startLength","positionToLength","getStartPosition","endLength","getEndPosition","context","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","position","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","kind","lengths","child","children","lengthAdd","lengthLessThan","lengthsToRange","level","levelPerBracketType","parentPairIsIncomplete","whileLoop","childCount","childrenLength","getChild","lengthLessThanEqual","lengthGreaterThanEqual","colorize","closingBracket","closesColorized","levelPerBracket","shouldContinue","openingBracketEnd","minIndentation","computeMinIndentation","curOffset","childOffset","BracketPairsTextModelPart","canBuildAST","getValueLength","languageConfigurationService","bracketPairsTree","_register","MutableDisposable","onDidChangeEmitter","bracketsRequested","handleLanguageConfigurationServiceChange","e","object","clear","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","store","DisposableStore","disposable","dispose","getBracketPairsInRangeWithMinIndentation","findMatchingBracketUp","_bracket","_position","maxDuration","validatePosition","getLanguageIdAtPosition","closingBracketInfo","bracketsNew","getClosingBracketInfo","bracketPair","Range","fromPositions","findLast","closes","bracket","toLowerCase","bracketsSupport","data","textIsBracket","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","filter","item","containsPosition","findLastMaxBy","compareBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","lineTokens","modeBrackets","tokenIndex","tokenCount","getCount","currentLanguageId","searchStartOffset","maxBracketLength","tokenEndOffset","getEndOffset","ignoreBracketsInToken","getStandardTokenType","searchEndOffset","getLineContent","tokenStartOffset","getStartOffset","getLineTokens","findTokenIndexAtOffset","currentModeBrackets","bestResult","foundBracket","BracketsUtils","findNextBracketInRange","forwardRegex","foundBracketText","_matchFoundBracket","textIsOpenBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","findPrevBracketInRange","reversedRegex","isOpen","matched","_findMatchingBracketDown","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","lineCount","getLineCount","findPrevBracket","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","strictContainsRange","savedCounts","counts","resetCounts","has","tmp","searchInRange","index","getValueInRange","getBracketInfo","startTime","Date","now","_searchCanceledBrand","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","getOptions","bracketPairColorizationOptions","bracketPairs","getDecorationsInRange","filterOutValidation","onlyMinimapDecorations","enabled","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","toArray","getAllDecorations","unexpectedClosingBracketClassName","getInlineClassNameOfLevel","registerThemingParticipant","theme","collector","colors","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","addRule","getColor","editorBracketHighlightingUnexpectedBracketForeground","colorValues","c","isTransparent","color","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","j","bSpacesCnt","bTabsCount","tabsDiff","abs","guessIndentation","source","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineText","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","spacesDiffCount","currentLineLength","getLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","charCode","getLineCharCode","currentSpacesDiff","insertSpaces","tabSizeScore","forEach","possibleTabSize","possibleTabSizeScore","getNodeColor","metadata","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","start","end","parent","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","reset","setOptions","className","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","acceptReplace","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","TreeNode","piece","size_left","lf_left","next","righttest","calculateSize","calculateLF","lineFeedCnt","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","arr","Uint16Array","Uint32Array","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","readonly","rLength","chr","Piece","bufferIndex","StringBuffer","buffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","nodePos","nodeStartOffset","get2","nodeStartLineNumber","nodePosition","shift","validate","hasInvalidVal","newArr","entry","PieceTreeBase","chunks","eolNormalized","_buffers","_lastChangeBufferPos","line","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","floor","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","getEOL","setEOL","newEOL","createSnapshot","getOffsetAt","leftLen","getAccumulatedValue","getPositionAt","lfCnt","originalOffset","out","getIndexOf","Position","remainder","startPosition","nodeAt2","endPosition","getValueInRange2","offsetInBuffer","ret","getLinesContent","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineRawContent","_getCharCode","matchingNode","targetOffset","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","m","searchText","_wordSeparators","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","createFindMatch","findMatchesLineByLine","searchRange","Searcher","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","lastMatchIndex","indexOf","isValidMatch","FindMatch","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","nodeCharCodeAt","newStart","startWithLF","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","nPiece","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","previousCharOffset","cursor","nodes","lastChar","splitText","endIndex","endPos","newPiece","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","originalStartPos","originalEndPos","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","newOffset","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","p","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","_onDidChangeContent","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","preserveBOM","getRangeAt","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","eolOffsetCompensation","desiredEOL","actualEOL","getCharacterCountInRange","fromOffset","toOffset","strings","isHighSurrogate","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","op","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","countEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","Boolean","isAutoWhitespaceEdit","_sortOpsAscending","hasTouchingRanges","rangeEnd","nextRangeStart","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","ApplyEditsResult","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_sortOpsDescending","delete","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","compareRangesUsingEnds","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","acceptChunk","chunk","startsWithUTF8BOM","UTF8_BOM_CHARACTER","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","createLineStarts","finish","_finish","lastChunk","newLineStarts","FixedArray","_default","_store","insertArr","arrayFill","deleteIndex","deleteCount","splice","insertIndex","insertCount","arrayInsert","ContiguousMultilineTokens","_startLineNumber","_tokens","tokens","appendLineTokens","ContiguousMultilineTokensBuilder","last","finalize","TokenizerWithStateStore","tokenizationSupport","initialState","getInitialState","TrackingTokenizationStateStore","getStartState","getFirstInvalidLine","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","updateTokensUntilLine","builder","lineToTokenize","safeTokenize","startState","setEndState","endState","getTokenTypeIfInsertingCharacter","character","lineStartState","LineTokens","tokenizeLineWithEdit","curLineContent","newLineContent","hasAccurateTokensForLine","getFirstInvalidEndStateLineNumberOrMax","isCheapToTokenize","firstInvalidLineNumber","tokenizeHeuristically","heuristicTokens","state","guessStartState","nonWhitespaceColumn","likelyRelevantLines","newNonWhitespaceIndex","reverse","_tokenizationStateStore","TokenizationStateStore","_invalidEndStatesLineNumbers","RangePriorityQueueImpl","addRange","OffsetRange","getEndState","BugIndicatingError","acceptChange","newLineCount","addRangeAndResize","endLineNumberExclusive","acceptChanges","LineRange","invalidateEndStateRange","getFirstInvalidEndStateLineNumber","Number","MAX_SAFE_INTEGER","allStatesValid","_lineEndStates","oldState","equals","_ranges","findIndex","contains","endExclusive","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","languageIdCodec","hasEOL","tokenizeEncoded","clone","onUnexpectedError","nullTokenize","nullTokenizeEncoded","encodeLanguageId","convertToEndOffset","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","_isDisposed","_isScheduled","handleChanges","_beginBackgroundTokenization","isAttachedToEditor","_hasLinesToTokenize","runWhenGlobalIdle","deadline","_backgroundTokenizeWithDeadline","endTime","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","setTimeout0","sw","StopWatch","elapsed","_tokenizeOneInvalidLine","setTokens","checkFinished","firstInvalidLine","backgroundTokenizationFinished","requestTokens","AttachedViews","_onDidChangeVisibleRanges","onDidChangeVisibleRanges","_views","Set","attachView","view","AttachedViewImpl","detachView","handleStateChange","setVisibleLines","visibleLines","stabilized","visibleLineRanges","AttachedViewHandler","lineRanges","_lineRanges","_refreshTokens","runner","RunOnceScheduler","update","_computedLineRanges","cancel","schedule","AbstractTokens","_backgroundTokenizationState","_onDidChangeBackgroundTokenizationState","onDidChangeBackgroundTokenizationState","_onDidChangeTokens","onDidChangeTokens","tokenizeIfCheap","forceTokenization","TreeSitterTokens","_treeSitterService","_tokenizationSupport","_initialize","newLanguage","_lastLanguageId","TreeSitterTokenizationRegistry","rawTokens","createEmpty","resetTokenization","fireTokenChangeEvent","semanticTokensApplied","handleDidChangeAttached","getParseResult","EMPTY_LINE_TOKENS","ContiguousTokensEditing","deleteBeginning","toChIndex","deleteEnding","fromChIndex","toUint32Array","lineTextLength","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","lastEnd","subarray","append","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","ContiguousTokensStore","_lineTokens","_len","flush","getTokens","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","_massageTokens","hasDifferentLanguageId","TokenMetadata","byteOffset","byteLength","_ensureLine","_deleteLines","_insertLines","arrays","checkEquality","oldTokens","_equals","_a","_b","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","lastLineTokens","setMultilineTokens","element","minChangedLineNumber","maxChangedLineNumber","hasChange","SparseTokensStore","_isComplete","isComplete","setPartial","_range","_firstRange","getRange","_lastRange","plusRange","insertPosition","removeTokens","split","addSparseTokens","aTokens","bTokens","_findFirstPieceWithLine","aLen","bLen","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","getMetadata","bMask","aMask","aMergeIndex","firstCharCode","TokenizationTextModelPart_1","__param","paramIndex","decorator","target","TokenizationTextModelPart","TextModelPart","_bracketPairsTextModelPart","_languageId","_attachedViews","_languageService","_languageConfigurationService","_semanticTokens","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_tokensDisposables","affects","Event","changedLanguages","includes","createPreferredTokenProvider","createGrammarTokens","GrammarTokens","createTreeSitterTokens","createTokens","useTreeSitter","needsReset","_emitModelTokensChangedEvent","validateLineNumber","syntacticTokens","_isDisposing","setSemanticTokens","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","validateRange","getWordAtPosition","assertNotDisposed","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordAtText","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","getWordUntilPosition","wordAtPosition","word","setLanguageId","oldLanguage","decorators","desc","d","arguments","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__decorate","ILanguageService","ILanguageConfigurationService","ITreeSitterParserService","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_debugBackgroundTokenizer","_attachedViewStates","DisposableMap","TokenizationRegistry","refreshRanges","deleteAndDispose","_debugBackgroundTokens","_debugBackgroundStates","isTooLargeForTokenization","initializeTokenization","firstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","refreshAllVisibleLineTokens","joinMany","_","s","refreshRange","changedTokens","backgroundResult","reportMismatchingTokens","validatedPosition","TextModel_1","createTextBufferFactory","createTextBufferFactoryFromSnapshot","snapshot","createTextBuffer","factory","model","isITextSnapshot","MODEL_ID","TextModelSnapshot","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","_MODEL_SYNC_LIMIT","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","LARGE_FILE_HEAP_OPERATION_THRESHOLD","DEFAULT_CREATION_OPTIONS","isForSimpleWidget","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","resolveOptions","guessedIndentation","TextModelResolvedOptions","_tokenizationTextModelPart","onDidChangeContent","listener","_eventEmitter","slowEvent","onDidChangeContentOrInjectedText","combinedDisposable","fastEvent","_onDidChangeInjectedText","__isDisposing","_bracketPairs","guides","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","instantiationService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","_associatedResource","URI","parse","_attachedEditorCount","_buffer","_bufferDisposable","_options","_setLanguage","GuidesTextModelPart","_decorationProvider","createInstance","bufferLineCount","bufferTextLength","_isTooLargeForTokenization","_isTooLargeForHeapOperation","_isTooLargeForSyncing","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_instanceId","singleLetterHash","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","EditStack","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","requestRichLanguageFeatures","emptyDisposedTextBuffer","_assertNotDisposed","_emitContentChangedEvent","rawChange","setValue","illegalArgument","_setValueFromTextBuffer","_createContentChanged2","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","getLineMaxColumn","_increaseVersionId","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","onBeforeAttached","onBeforeDetached","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineLength","uri","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","createChangeEvent","normalizeIndentation","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","pushEditOperations","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","_validatePosition","rawOffset","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","getEndOfLineSequence","getLineMinColumn","_validateRangeRelaxedNoAllocations","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","Selection","_isValidPosition","validationType","charCodeBefore","_lineNumber","_column","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","modifyPosition","candidate","rawSearchScope","isRegex","matchCase","searchRanges","isArray","every","searchScope","isIRange","d1","d2","uniqueSearchRanges","matchMapper","reduce","areIntersecting","SearchParams","parseSearchRequest","TextModelSearch","findNextMatch","rawSearchStart","searchStart","findPreviousMatch","pushStackElement","popStackElement","pushEOL","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","_validateEditOperations","beforeCursorState","editOperations","cursorStateComputer","group","_pushEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","rangeStart","_applyUndoRedoEdits","_applyRedo","oldLineCount","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","injectedTextInEditedRangeQueue","ArrayQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","lineChangeEvents","from","_getInjectedTextInLine","changeDecorations","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","removeAllDecorationsWithOwnerId","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","getLinesDecorations","_endLineNumber","_getDecorationsInRange","pushMany","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","t","getAllMarginDecorations","filterRange","getAllInInterval","oldRange","recordLineAffectedByInjectedText","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setLanguage","normalizePosition","affinity","getLineIndentColumn","indentOfLine","indent","isNodeInOverviewRuler","IInstantiationService","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","r1","r2","showIfCollapsed","overviewRulerOnly","_search","_resolveNode","cleanClassName","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","_resolveColor","invalidateCachedColor","ModelDecorationGlyphMarginOptions","GlyphMarginLane","persistLane","ModelDecorationMinimapOptions","sectionHeaderStyle","sectionHeaderText","Color","fromHex","ModelDecorationInjectedTextOptions","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","register","createDynamic","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","minimap","glyphMargin","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","htmlAttributeEncodeValue","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","doFire","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_completedStrings","_bufferLength","build","_flushBuffer","_buildBuffer","bufferString","appendCharCode","remainingSpace","appendASCIICharCode","appendString","strLen","_registry","registerSingleton","ctorOrDescriptor","supportsDelayedInstantiation","SyncDescriptor","getSingletonServiceDescriptors","hasBuffer","Buffer","textDecoder","Lazy","Uint8Array","VSBuffer","wrap","actual","isBuffer","readUInt16LE","writeUInt16LE","destination","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","lift","lengthOfString","lengthToObj","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","lengthDiffNonNegative","oldOffsetObj","columnCount","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","RichEditBracket","open","close","_richEditBracketBrand","_openSet","_toSet","_closeSet","RichEditBrackets","_brackets","_richEditBracketsBrand","N","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","g","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","collectSuperstrings","unique","lengthcmp","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","seen","prepareBracketForRegExp","insertWordBoundaries","test","regexStr","lastInput","lastOutput","_findPrevBracketInText","reversedText","match","matchOffset","matchLength","absoluteMatchOffset","reversedSubstr","findNextBracketInText","BaseAstNode","PairAstNode","missingOpeningBracketIds","listHeight","canBeReused","openBracketIds","deepClone","ListAstNode","create23","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","unopenedBrackets","_item3","_item1","_item2","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","unshift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","lengthGetLineCount","firstNonWsColumn","BracketAstNode","bracketIds","bracketText","InvalidBracketAstNode","closingBrackets","openedBracketIds","IndentAction","StandardAutoClosingPairConditional","_neutralCharacter","_neutralCharacterSearched","_inString","_inComment","_inRegEx","notIn","isOK","standardToken","shouldAutoClose","getTokenCount","standardTokenType","_findNeutralCharacterInRange","toCharCode","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","NullState","TokenizationResult","Token","EncodedTokenizationResult","editorLineHighlight","registerColor","editorLineHighlightBorder","dark","light","hcDark","hcLight","contrastBorder","editorRangeHighlight","editorRangeHighlightBorder","activeContrastBorder","editorSymbolHighlight","editorFindMatchHighlight","editorSymbolHighlightBorder","editorCursorForeground","black","white","editorCursorBackground","editorMultiCursorPrimaryForeground","editorMultiCursorPrimaryBackground","editorMultiCursorSecondaryForeground","editorMultiCursorSecondaryBackground","editorWhitespaces","editorLineNumbers","deprecatedEditorIndentGuides","deprecatedEditorActiveIndentGuides","editorIndentGuide1","editorIndentGuide2","editorIndentGuide3","editorIndentGuide4","editorIndentGuide5","editorIndentGuide6","editorActiveIndentGuide1","editorActiveIndentGuide2","editorActiveIndentGuide3","editorActiveIndentGuide4","editorActiveIndentGuide5","editorActiveIndentGuide6","deprecatedEditorActiveLineNumber","editorActiveLineNumber","editorDimmedLineNumber","editorRuler","lightgrey","editorCodeLensForeground","editorBracketMatchBackground","editorBracketMatchBorder","editorOverviewRulerBorder","editorOverviewRulerBackground","editorGutter","editorBackground","editorUnnecessaryCodeBorder","transparent","editorUnnecessaryCodeOpacity","ghostTextBorder","ghostTextForeground","ghostTextBackground","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","editorUnicodeHighlightBorder","editorUnicodeHighlightBackground","editorWarningBackground","background","lineHighlight","imeBackground","_computeIndentLevel","computeIndentLevel","getActiveIndentGuide","minLineNumber","maxLineNumber","foldingRules","offSide","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","activeBracketPairRange","bracketsContainingActivePosition","bp","strictContainsPosition","BracketPairGuidesClassNames","isActive","equalsRange","includeInactive","highlightActive","activeClassName","horizontalGuides","HorizontalGuidesState","Enabled","EnabledForActive","IndentGuide","IndentGuideHorizontalLine","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","l","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","BracketTokens","createFromLanguage","configuration","getId","openingBrackets","openingTextId","getOpeningBrackets","hasRegExp","_regExpGlobal","getRegExpStr","keys","escaped","escapeRegExpCharacters","regExpGlobal","regExpStr","RegExp","getToken","findClosingTokenText","openingBracketIds","closingText","info","languageIdToBracketTokens","singleLanguageBracketTokens","CharacterPairSupport","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","config","_autoClosingPairs","el","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","_autoCloseBeforeForBrackets","_surroundingPairs","surroundingPairs","getAutoClosingPairs","getAutoCloseBeforeSet","forQuotes","getSurroundingPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","getElectricCharacters","distinct","onElectricCharacter","textBeforeBracket","getActualLineContentBefore","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","shouldIncrease","increaseIndentPattern","shouldDecrease","decreaseIndentPattern","shouldIndentNextLine","indentNextLinePattern","shouldIgnore","unIndentedLinePattern","getIndentMetadata","OnEnterSupport","opts","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","onEnter","autoIndent","beforeEnterText","afterEnterText","rule","beforeText","afterText","obj","action","indentAction","IndentOutdent","Indent","_safeRegExp","def","err","LanguageBracketsConfiguration","filterValidBrackets","openingBracketInfos","CachedFunction","closing","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","colorizedBracketPairs","_openingBrackets","cachedValues","v","_closingBrackets","values","getOpeningBracketInfo","getBracketRegExp","BracketKindBase","openedBrackets","isOpeningBracket","openingColorizedBrackets","LanguageConfigurationServiceChangeEvent","LanguageConfigurationService","configurationService","languageService","LanguageConfigurationRegistry","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","globalConfigChanged","some","localConfigChanged","overrides","overrideLangName","isRegisteredLanguageId","priority","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","IConfigurationService","getIndentationAtPosition","indentation","getLeadingWhitespace","ComposedLanguageConfiguration","_resolved","_entries","_order","LanguageConfigurationContribution","toDisposable","getResolvedConfiguration","_resolve","cmp","configs","comments","wordPattern","folding","LanguageConfigurationChangeEvent","_onDidChange","PLAINTEXT_LANGUAGE_ID","entries","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","indentRulesSupport","ensureValidWordDefinition","electricCharacter","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","bracketId","astNode","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","skip","setPosition","token","peek","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","lengthGetColumnCountIfZeroLineCount","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","regexp","exec","lengthDiff","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","colCount","NotSupportedError","defaultTokenMetadata","decoder","defaultMetadata","createFromTextAndMetadata","fullText","_lineTokensBrand","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","decodeLanguageId","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","inflate","sliceAndInflate","SliceLineTokens","lastTokenIndex","desiredIndex","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","nextOriginalTokenEndOffset","nextInsertToken","getTokenText","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","adjustedTokenIndex","getStandardTokenTypeAtPosition","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","nodeToPrependOfCorrectHeight","prepend","NodeReader","lastOffset","nextNodes","offsets","idxs","readLongestNodeAt","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","curIdx","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","tryReadChildFromCache","parseChild","readNode","height","first","second","concat23Trees","maxCacheableLength","lengthIsZero","cachedNode","nextToken","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","toLengthMapping","s1ToS2Map","modified","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","remainingItem","splitAt","LengthMapping","pushEdit","lengthEquals","lastResult","s0offset","s1ToS2","s0Length","sumLengths","s0EndOffset","s1","s0startOffset","remainingLengthAfter","textEditInfos","textEditInfo","spaceLength","ctor","staticArguments","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","top","chCode","startLineCount","startColumnCount","endLineCount","endColumnCount","factor","TextLength","l1","l2","lengthFn","length1","length2","lineCount1","lineCount2","colCount2","lengthStart","lengthEnd","splitLines","ModelService_1","ModelData","_modelEventListeners","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","heapSize","sha1","alternativeVersionId","ModelService","MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK","_configurationService","_resourcePropertiesService","_instantiationService","_onModelAdded","onModelAdded","_onModelRemoved","onModelRemoved","_onModelModeChanged","onModelLanguageChanged","_modelCreationOptionsByLanguageAndResource","_models","_disposedModels","_disposedModelsHeapSize","_updateModelOptions","_readModelOptions","editor","parsedTabSize","parseInt","parsedIndentSize","newDefaultEOL","bracketPairColorization","language","_shouldRestoreUndoStack","getCreationOptions","oldOptionsByLanguageAndResource","modelId","modelData","affectsConfiguration","oldOptions","newOptions","_setModelOptionsForModel","currentOptions","_insertDisposedModel","disposedModelData","_removeDisposedModel","_ensureDisposedModelsHeapSize","maxModelsHeapSize","disposedModels","disposedModel","restoreSnapshot","_createModelData","getElements","sha1Computer","_getSHA1Computer","sha1IsEqual","canComputeSHA1","computeSHA1","past","isEditStackElement","matchesResource","setModel","future","setElementsValidFlag","createModel","languageSelection","getModels","getModel","_schemaShouldMaintainUndoRedoElements","scheme","Schemas","file","vscodeRemote","vscodeUserData","vscodeNotebookCell","getUriComparisonKey","maintainUndoRedoStack","maxMemory","oldLanguageId","newLanguageId","DefaultModelSHA1Computer","ITextResourcePropertiesService","MAX_MODEL_SIZE","shaComputer","StringSHA1","digest","spacesCnt","tabsCnt","_normalizeIndentationFromWhitespace","ITextResourceConfigurationService","createScopedLineTokens","desiredLanguageId","firstTokenIndex","ScopedLineTokens","firstCharOffset","lastCharOffset","_scopedLineTokensBrand","_lastTokenIndex","_lastCharOffset","toIViewLineTokens","uriGetComparisonKey","SingleModelEditStackData","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","_writeSelectionsSize","_writeSelections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_readSelections","serialize","necessarySize","deserialize","changeCount","SingleModelEditStackElement","isUri","label","code","_data","canAppend","MultiModelEditStackElement","resources","_editStackElementsArr","editStackElement","editStackElements","_isOpen","_editStackElementsMap","_delegate","prepareUndoRedo","basename","undoRedoService","_model","lastElement","getLastElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","inverseEditOperations","_computeCursorState"],"ignoreList":[],"sourceRoot":""}